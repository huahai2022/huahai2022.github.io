<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spider</title>
      <link href="/2023/09/05/spider/"/>
      <url>/2023/09/05/spider/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录笔记</title>
      <link href="/2023/08/25/dai-ma-sui-xiang-lu-bi-ji/"/>
      <url>/2023/08/25/dai-ma-sui-xiang-lu-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>选择一些重点进行记录，不要求多，但要求熟练，笔记上的内容全会。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-数组基础理论"><a href="#1-数组基础理论" class="headerlink" title="1.数组基础理论"></a>1.数组基础理论</h3><p>数组是存放在连续内存空间上的相同类型数据的集合。</p><ul><li>数组下标都是从0开始的。</li><li>数组内存空间的地址是连续的</li></ul><p>正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</p><p>数组中的元素不能删除，只能覆盖。</p><p>在C++中二维数组在地址空间上是连续的。像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。</p><h3 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2.二分查找"></a>2.二分查找</h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230825200058478.png" alt="image-20230825200058478"></p><pre class="line-numbers language-none"><code class="language-none">class Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left, right = 0, len(nums) - 1  # 定义target在左闭右闭的区间里，[left, right]        while left &lt;= right:            middle = left + (right - left) // 2                        if nums[middle] &gt; target:                right = middle - 1  # target在左区间，所以[left, middle - 1]            elif nums[middle] &lt; target:                left = middle + 1  # target在右区间，所以[middle + 1, right]            else:                return middle  # 数组中找到目标值，直接返回下标        return -1  # 未找到目标值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-移除元素"><a href="#3-移除元素" class="headerlink" title="3.移除元素"></a>3.移除元素</h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p><p>示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><pre class="line-numbers language-none"><code class="language-none">class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        i,j=0,len(nums)        while i&lt;j:            if nums[i]==val:                for a in range (i,j-1):                    nums[a]=nums[a+1]                i-=1                j-=1            i+=1        return j通过两个循环遍历<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        size=len(nums)        index=0        for i in range (size):            if nums[i]==val:                pass            else:                nums[index]=nums[i]                index+=1        return index让两个下表去寻找，找到了就赋值给另外一个下标，找不到就继续寻找。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-有序数组的平方"><a href="#4-有序数组的平方" class="headerlink" title="4.有序数组的平方"></a>4.有序数组的平方</h3><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1：</p><ul><li>输入：nums = [-4,-1,0,3,10]</li><li>输出：[0,1,9,16,100]</li><li>解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</li></ul><pre class="line-numbers language-none"><code class="language-none">class Solution:    def sortedSquares(self, nums: List[int]) -&gt; List[int]:        left,right=0,len(nums)-1        nums2_size=len(nums)-1        nums2=[0]*len(nums)        while left&lt;=right:            if(abs(nums[left])&lt;abs(nums[right])):                nums2[nums2_size]=nums[right]**2                right-=1                nums2_size-=1            else:                nums2[nums2_size]=nums[left]**2                left+=1                nums2_size-=1        return nums2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-长度最小的子数组"><a href="#5-长度最小的子数组" class="headerlink" title="5.长度最小的子数组"></a>5.长度最小的子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><ul><li>输入：s = 7, nums = [2,3,1,2,4,3]</li><li>输出：2</li><li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li></ul><pre class="line-numbers language-none"><code class="language-none">class Solution:    def minSubArrayLen(self, s: int, nums: List[int]) -&gt; int:        l = len(nums)        min_len = float('inf')                for i in range(l):            cur_sum = 0            for j in range(i, l):                cur_sum += nums[j]                if cur_sum &gt;= s:                    min_len = min(min_len, j - i + 1)                    break                return min_len if min_len != float('inf') else 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#滑动窗口</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        left<span class="token operator">=</span>right<span class="token operator">=</span><span class="token number">0</span>        length<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        min_len<span class="token operator">=</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>        count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>            count<span class="token operator">+=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">while</span> count<span class="token operator">&gt;=</span>s<span class="token punctuation">:</span>                min_len<span class="token operator">=</span><span class="token builtin">min</span><span class="token punctuation">(</span>min_len<span class="token punctuation">,</span>i<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                count<span class="token operator">-=</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                left<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> min_len <span class="token keyword">if</span> min_len <span class="token operator">!=</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-螺旋矩阵II"><a href="#6-螺旋矩阵II" class="headerlink" title="6.螺旋矩阵II"></a>6.螺旋矩阵II</h3><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><pre class="line-numbers language-none"><code class="language-none">#模拟，思路要清晰class Solution:    def generateMatrix(self, n: int) -&gt; List[List[int]]:        nums = [[0] * n for _ in range(n)]        startx, starty = 0, 0               # 起始点        loop, mid = n // 2, n // 2          # 迭代次数、n为奇数时，矩阵的中心点        count = 1                           # 计数        for offset in range(1, loop + 1) :      # 每循环一层偏移量加1，偏移量从1开始            for i in range(starty, n - offset) :    # 从左至右，左闭右开                nums[startx][i] = count                count += 1            for i in range(startx, n - offset) :    # 从上至下                nums[i][n - offset] = count                count += 1            for i in range(n - offset, starty, -1) : # 从右至左                nums[n - offset][i] = count                count += 1            for i in range(n - offset, startx, -1) : # 从下至上                nums[i][starty] = count                count += 1                            startx += 1         # 更新起始点            starty += 1        if n % 2 != 0 :# n为奇数时，填充中心点            nums[mid][mid] = count         return nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。双链表 既可以向前查询也可以向后查询。</p><p>循环链表，顾名思义，就是链表首尾相连。循环链表可以用来解决约瑟夫环问题。首尾相连的单链表。</p><p>链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><h3 id="1-移除链表元素"><a href="#1-移除链表元素" class="headerlink" title="1.移除链表元素"></a>1.移除链表元素</h3><p>题意：删除链表中等于给定值 val 的所有节点。</p><p>示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]</p><p>示例 2： 输入：head = [], val = 1 输出：[]</p><p>示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]</p><pre class="line-numbers language-none"><code class="language-none"># Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        while head is not None and head.val==val:            head=head.next        current=head        while current is not None and current.next is not None:            if current.next.val==val:                current.next=current.next.next            else:                current=current.next        return head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = next#虚拟头节点class Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        new_node=ListNode(next=head)        current=new_node        while current.next is not None :            if current.next.val==val:                current.next=current.next.next            else:                current=current.next        return new_node.next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-设计链表"><a href="#2-设计链表" class="headerlink" title="2.设计链表"></a>2.设计链表</h3><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li></ul><pre class="line-numbers language-none"><code class="language-none">class ListNode:    def __init__(self, val=0, next=None):        self.val = val        self.next = next        class MyLinkedList:    def __init__(self):        self.dummy_head = ListNode()        self.size = 0    def get(self, index: int) -&gt; int:        if index &lt; 0 or index &gt;= self.size:            return -1                current = self.dummy_head.next        for i in range(index):            current = current.next                    return current.val    def addAtHead(self, val: int) -&gt; None:        self.dummy_head.next = ListNode(val, self.dummy_head.next)        self.size += 1    def addAtTail(self, val: int) -&gt; None:        current = self.dummy_head        while current.next:            current = current.next        current.next = ListNode(val)        self.size += 1    def addAtIndex(self, index: int, val: int) -&gt; None:        if index &lt; 0 or index &gt; self.size:            return                current = self.dummy_head        for i in range(index):            current = current.next        current.next = ListNode(val, current.next)        self.size += 1    def deleteAtIndex(self, index: int) -&gt; None:        if index &lt; 0 or index &gt;= self.size:            return                current = self.dummy_head        for i in range(index):            current = current.next        current.next = current.next.next        self.size -= 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-反转列表"><a href="#3-反转列表" class="headerlink" title="3.反转列表"></a>3.反转列表</h3><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#改变指针的指向</span><span class="token comment"># Definition for singly-linked list.</span><span class="token comment"># class ListNode:</span><span class="token comment">#     def __init__(self, val=0, next=None):</span><span class="token comment">#         self.val = val</span><span class="token comment">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        cur<span class="token operator">=</span>head        pre<span class="token operator">=</span><span class="token boolean">None</span>        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            temp<span class="token operator">=</span>cur<span class="token punctuation">.</span><span class="token builtin">next</span>            cur<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token operator">=</span>pre            pre<span class="token operator">=</span>cur            cur<span class="token operator">=</span>temp        <span class="token keyword">return</span> pre<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#使用虚拟头节点解决链表反转</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val        self<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token builtin">next</span><span class="token keyword">def</span> <span class="token function">reverseList1</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 创建虚头结点</span>    dumpyHead <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    dumpyHead<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>    <span class="token comment"># 遍历所有节点</span>    cur <span class="token operator">=</span> head    <span class="token keyword">while</span> cur <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        temp <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span>        <span class="token comment"># 头插法</span>        cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> dumpyHead<span class="token punctuation">.</span><span class="token builtin">next</span>        dumpyHead<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> cur        cur <span class="token operator">=</span> temp    <span class="token keyword">return</span> dumpyHead<span class="token punctuation">.</span><span class="token builtin">next</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Definition for singly-linked list.</span><span class="token comment"># class ListNode:</span><span class="token comment">#     def __init__(self, val=0, next=None):</span><span class="token comment">#         self.val = val</span><span class="token comment">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment"># 如果链表为空，则返回空</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 如果链表中只有只有一个元素，则直接返回</span>        <span class="token keyword">if</span> head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token comment"># 创建栈 每一个结点都入栈</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        cur <span class="token operator">=</span> head        <span class="token keyword">while</span> cur <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span>        <span class="token comment"># 创建一个虚拟头结点</span>        pHead <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        cur <span class="token operator">=</span> pHead        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> node            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span>        <span class="token comment"># 最后一个元素的next要赋值为空</span>        cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>        <span class="token keyword">return</span> pHead<span class="token punctuation">.</span><span class="token builtin">next</span>            <span class="token comment">#使用栈来进行反转</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-两两交换链表中的节点"><a href="#4-两两交换链表中的节点" class="headerlink" title="4.两两交换链表中的节点"></a>4.两两交换链表中的节点</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230826174717230.png" alt="image-20230826174717230"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token comment"># 待翻转的两个node分别是pre和cur</span>        pre <span class="token operator">=</span> head        cur <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>        <span class="token builtin">next</span> <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span>                cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> pre  <span class="token comment"># 交换</span>        pre<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>swapPairs<span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">)</span> <span class="token comment"># 将以next为head的后续链表两两交换</span>                 <span class="token keyword">return</span> cur        <span class="token comment">#递归</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class Solution:    def swapPairs(self, head: ListNode) -&gt; ListNode:        dummy_head = ListNode(next=head)        current = dummy_head                # 必须有cur的下一个和下下个才能交换，否则说明已经交换结束了        while current.next and current.next.next:            temp = current.next # 防止节点修改            temp1 = current.next.next.next                        current.next = current.next.next            current.next.next = temp            temp.next = temp1            current = current.next.next        return dummy_head.next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-删除链表倒数第N个节点"><a href="#5-删除链表倒数第N个节点" class="headerlink" title="5.删除链表倒数第N个节点"></a>5.删除链表倒数第N个节点</h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p><img src="C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20230827112657649.png" alt="image-20230827112657649"></p><pre class="line-numbers language-none"><code class="language-none">#超出时间限制class Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        length=0        while head:            length+=1        if k&lt;=0 or k&gt;length:            return        index=length-n        cur=head        while index&gt;1:            cur=cur.next            index-=1        cur.next=cur.next.next        return head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class Solution:    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:        # 创建一个虚拟节点，并将其下一个指针设置为链表的头部        dummy_head = ListNode(0, head)                # 创建两个指针，慢指针和快指针，并将它们初始化为虚拟节点        slow = fast = dummy_head                # 快指针比慢指针快 n+1 步        for i in range(n+1):            fast = fast.next                # 移动两个指针，直到快速指针到达链表的末尾        while fast:            slow = slow.next            fast = fast.next                # 通过更新第 (n-1) 个节点的 next 指针删除第 n 个节点        slow.next = slow.next.next                return dummy_head.next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-链表相交"><a href="#6-链表相交" class="headerlink" title="6.链表相交"></a>6.链表相交</h3><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20230827114237852.png" alt="image-20230827114237852"></p><p>很差劲呀，这道题</p><pre class="line-numbers language-none"><code class="language-none">class Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:        lenA, lenB = 0, 0        cur = headA        while cur:         # 求链表A的长度            cur = cur.next             lenA += 1        cur = headB         while cur:         # 求链表B的长度            cur = cur.next             lenB += 1        curA, curB = headA, headB        if lenA &gt; lenB:     # 让curB为最长链表的头，lenB为其长度            curA, curB = curB, curA            lenA, lenB = lenB, lenA         for _ in range(lenB - lenA):  # 让curA和curB在同一起点上（末尾位置对齐）            curB = curB.next         while curA:         #  遍历curA 和 curB，遇到相同则直接返回            if curA == curB:                return curA            else:                curA = curA.next                 curB = curB.next        return None                  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#这段代码真的装逼class Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:        # 处理边缘情况        if not headA or not headB:            return None                # 在每个链表的头部初始化两个指针        pointerA = headA        pointerB = headB                # 遍历两个链表直到指针相交        while pointerA != pointerB:            # 将指针向前移动一个节点            pointerA = pointerA.next if pointerA else headB            pointerB = pointerB.next if pointerB else headA                # 如果相交，指针将位于交点节点，如果没有交点，值为None        return pointerA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-环形链表II"><a href="#7-环形链表II" class="headerlink" title="7.环形链表II"></a>7.环形链表II</h3><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>说明</strong>：不允许修改给定的链表。<img src="C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20230827122256887.png" alt="image-20230827122256887"></p><pre class="line-numbers language-none"><code class="language-none"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        cur=head        my_dict={}        while cur:            my_dict[cur] = my_dict.get(cur, 0) + 1            for value in my_dict.values():                if value==2:                    return cur            cur=cur.next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230827122320958.png" alt="image-20230827122320958"></p><p>可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</p><p>为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢？很显然，他们之间距离差在一步一步缩小。</p><pre class="line-numbers language-none"><code class="language-none"># （版本一）快慢指针法# Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def detectCycle(self, head: ListNode) -&gt; ListNode:        slow = head        fast = head                while fast and fast.next:            slow = slow.next            fast = fast.next.next                        # If there is a cycle, the slow and fast pointers will eventually meet            if slow == fast:                # Move one of the pointers back to the start of the list                slow = head                while slow != fast:                    slow = slow.next                    fast = fast.next                return slow        # If there is no cycle, return None        return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># （版本二）集合法# Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def detectCycle(self, head: ListNode) -&gt; ListNode:        visited = set()                while head:            if head in visited:                return head            visited.add(head)            head = head.next                return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h3><h5 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1.哈希表"></a>1.哈希表</h5><p>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230827141058153.png" alt="image-20230827141058153"></p><p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong>例如要查询一个名字是否在这所学校里。</p><h5 id="2-哈希函数"><a href="#2-哈希函数" class="headerlink" title="2.哈希函数"></a>2.哈希函数</h5><p>要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。将学生姓名映射到哈希表上就涉及到了<strong>hash function ，也就是哈希函数</strong></p><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。<img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230827141225308.png" alt="image-20230827141225308">哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。</p><h5 id="3-哈希碰撞"><a href="#3-哈希碰撞" class="headerlink" title="3.哈希碰撞"></a>3.哈希碰撞</h5><p>如图所示，小李和小王都映射到了索引下标 1 的位置，<strong>这一现象叫做哈希碰撞</strong>。<img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230827141425333.png" alt="image-20230827141425333"></p><h6 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h6><p>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了</p><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><h6 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h6><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：<img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230827141632405.png" alt="image-20230827141632405"></p><h5 id="4-常见3中哈希结构"><a href="#4-常见3中哈希结构" class="headerlink" title="4.常见3中哈希结构"></a>4.常见3中哈希结构</h5><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set （集合）</li><li>map(映射)</li></ul><h3 id="2-有效的字母异位词"><a href="#2-有效的字母异位词" class="headerlink" title="2.有效的字母异位词"></a>2.有效的字母异位词</h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s = “anagram”, t = “nagaram” 输出: true</p><p>示例 2: 输入: s = “rat”, t = “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><pre class="line-numbers language-none"><code class="language-none">使用了两个字典来存放字母class Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        my_s={}        my_t={}        for i in range(len(s)):            my_s[s[i]] = 1 if s[i] not in my_s else my_s[s[i]] + 1        for i in range(len(t)):            my_t[t[i]]=1 if t[i] not in my_t else my_t[t[i]] +1        if my_s==my_t:            return True        return False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">维护了一个数组，存放字母class Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        record = [0] * 26        for i in s:            #并不需要记住字符a的ASCII，只要求出一个相对数值就可以了            record[ord(i) - ord("a")] += 1        for i in t:            record[ord(i) - ord("a")] -= 1        for i in range(26):            if record[i] != 0:                #record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。                return False        return True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        from collections import defaultdict                s_dict = defaultdict(int)        t_dict = defaultdict(int)        for x in s:            s_dict[x] += 1                for x in t:            t_dict[x] += 1        return s_dict == t_dict                defaultdict是Python标准库collections模块中的一个类，它是字典（dict）的一个子类，用于创建具有默认值的字典。主要区别如下：默认值：defaultdict在创建时需要指定一个默认值的类型或者一个默认值生成函数。当访问一个不存在的键时，defaultdict会自动返回默认值，而不会引发KeyError异常。这使得在处理缺失键时更加方便，无需显式设置默认值或使用if语句来检查键的存在性。创建方式：创建一个普通的字典时，可以直接使用花括号语法或dict()构造函数。而创建defaultdict时，需要使用defaultdict()构造函数，并传入一个默认值类型或者默认值生成函数作为参数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class Solution(object):    def isAnagram(self, s: str, t: str) -&gt; bool:        from collections import Counter        a_count = Counter(s)        b_count = Counter(t)        return a_count == b_count                具体解释如下：from collections import Counter：从collections模块导入Counter类，用于创建计数器对象。a_count = Counter(s)：使用Counter类创建一个计数器对象a_count，统计字符串s中每个字符出现的次数。b_count = Counter(t)：使用Counter类创建另一个计数器对象b_count，统计字符串t中每个字符出现的次数。return a_count == b_count：比较两个计数器对象a_count和b_count是否相等。如果两个计数器对象相等，意味着两个字符串中的字符及其出现次数完全一致，即s和t是字母异位词，返回True；否则，返回False。该解法利用了Counter类的特性，通过统计两个字符串中每个字符出现的次数，然后比较两个计数器对象是否相等来判断异位词的关系。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-两个数组的交集"><a href="#3-两个数组的交集" class="headerlink" title="3.两个数组的交集"></a>3.两个数组的交集</h3><p>题意：给定两个数组，编写一个函数来计算它们的交集。<img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230827145216943.png" alt="image-20230827145216943"></p><p><strong>说明：</strong> 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">intersection</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        set1<span class="token operator">=</span><span class="token builtin">set</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span>        set2<span class="token operator">=</span><span class="token builtin">set</span><span class="token punctuation">(</span>nums2<span class="token punctuation">)</span>        set3<span class="token operator">=</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> set1<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token keyword">in</span> set2<span class="token punctuation">:</span>                set3<span class="token punctuation">.</span>add<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        my_list<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span>set3<span class="token punctuation">)</span>        <span class="token keyword">return</span> my_list    <span class="token comment">#python中|表示并集，&amp;表示交集</span><span class="token comment">#下面的是代码随想录写的，和我的一样，速度比我的快</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">intersection</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token builtin">set</span><span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用数组进行实现class Solution:    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        count1 = [0]*1001        count2 = [0]*1001        result = []        for i in range(len(nums1)):            count1[nums1[i]]+=1        for j in range(len(nums2)):            count2[nums2[j]]+=1        for k in range(1001):            if count1[k]*count2[k]&gt;0:                result.append(k)        return result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-快乐数"><a href="#4-快乐数" class="headerlink" title="4.快乐数"></a>4.快乐数</h3><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><pre class="line-numbers language-none"><code class="language-none">class Solution:    def isHappy(self, n: int) -&gt; bool:        m=n        while True:            num_sum=0            my_set=set()            for i in str(m):                num_sum+=int(i)**2            if num_sum==1:                return True            if num_sum not in my_set:                my_set.add(num_sum)            else:                return False            m=num_sum#自己写的写错了，gpt帮我修改的，有空了一定要研究研究gptclass Solution:    def isHappy(self, n: int) -&gt; bool:        my_set = set()        while True:            num_sum = 0            for i in str(n):                num_sum += int(i) ** 2            if num_sum == 1:                return True            if num_sum in my_set:                return False            my_set.add(num_sum)            n = num_sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用数组class Solution:   def isHappy(self, n: int) -&gt; bool:       record = []       while n not in record:           record.append(n)           new_num = 0           n_str = str(n)           for i in n_str:               new_num+=int(i)**2           if new_num==1: return True           else: n = new_num       return False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用快慢指针，这个原理是，这个会形成一个循环，也就是一个环，快慢指针一定会相遇，class Solution:   def isHappy(self, n: int) -&gt; bool:               slow = n       fast = n       while self.get_sum(fast) != 1 and self.get_sum(self.get_sum(fast)):           slow = self.get_sum(slow)           fast = self.get_sum(self.get_sum(fast))           if slow == fast:               return False       return True   def get_sum(self,n: int) -&gt; int:        new_num = 0       while n:           n, r = divmod(n, 10)           new_num += r ** 2       return new_num<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-两数之和"><a href="#5-两数之和" class="headerlink" title="5.两数之和"></a>5.两数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p><pre class="line-numbers language-none"><code class="language-none">#暴力法，两次循环class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        for i in range(len(nums)):            for j in range(i+1, len(nums)):                if nums[i] + nums[j] == target:                    return [i,j]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用字典class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        records = dict()        for index, value in enumerate(nums):  #这个写法指的借鉴            if target - value in records:   # 遍历当前元素，并在map中寻找是否有匹配的key                return [records[target- value], index]            records[value] = index    # 如果没找到匹配对，就把访问过的元素和下标加入到map中        return []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用集合class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        #创建一个集合来存储我们目前看到的数字        seen = set()                     for i, num in enumerate(nums):            complement = target - num            if complement in seen:                return [nums.index(complement), i]            seen.add(num)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用双指针，这个爱看就自己去看吧class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        # 对输入列表进行排序        nums_sorted = sorted(nums)                # 使用双指针        left = 0        right = len(nums_sorted) - 1        while left &lt; right:            current_sum = nums_sorted[left] + nums_sorted[right]            if current_sum == target:                # 如果和等于目标数，则返回两个数的下标                left_index = nums.index(nums_sorted[left])                right_index = nums.index(nums_sorted[right])                if left_index == right_index:                    right_index = nums[left_index+1:].index(nums_sorted[right]) + left_index + 1                return [left_index, right_index]            elif current_sum &lt; target:                # 如果总和小于目标，则将左侧指针向右移动                left += 1            else:                # 如果总和大于目标值，则将右指针向左移动                right -= 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-四数相加"><a href="#6-四数相加" class="headerlink" title="6.四数相加"></a>6.四数相加</h3><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><p><strong>例如:</strong></p><p>输入:</p><ul><li>A = [ 1, 2]</li><li>B = [-2,-1]</li><li>C = [-1, 2]</li><li>D = [ 0, 2]</li></ul><p>输出:</p><p>2</p><pre class="line-numbers language-none"><code class="language-none">这个我使用的暴力求和，超时了class Solution:    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:        count=0        length=len(nums1)        for i in nums1:            for j in nums2:                for k in nums3:                    for l in nums4:                        if i+j+k+l==0:                            count+=1        return count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class Solution(object):    def fourSumCount(self, nums1, nums2, nums3, nums4):        # 使用字典存储nums1和nums2中的元素及其和        hashmap = dict()        for n1 in nums1:            for n2 in nums2:                if n1 + n2 in hashmap:                    hashmap[n1+n2] += 1                else:                    hashmap[n1+n2] = 1                # 如果 -(n1+n2) 存在于nums3和nums4, 存入结果        count = 0        for n3 in nums3:            for n4 in nums4:                key = - n3 - n4                if key in hashmap:                    count += hashmap[key]        return count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">from collections import defaultdict class Solution:    def fourSumCount(self, nums1: list, nums2: list, nums3: list, nums4: list) -&gt; int:        rec, cnt = defaultdict(lambda : 0), 0        for i in nums1:            for j in nums2:                rec[i+j] += 1        for i in nums3:            for j in nums4:                cnt += rec.get(-(i+j), 0)         return cnt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-赎回信"><a href="#7-赎回信" class="headerlink" title="7.赎回信"></a>7.赎回信</h3><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p><strong>注意：</strong></p><p>你可以假设两个字符串均只含有小写字母。</p><p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p><pre class="line-numbers language-none"><code class="language-none">#使用字典class Solution:    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:        ran_dict={}        maga_dict={}        for i in ransomNote:            ran_dict[i]=ran_dict.get(i,0)+1        for i in magazine:            maga_dict[i]=maga_dict.get(i,0)+1        for key,value in ran_dict.items():            if value&gt;maga_dict.get(key,0):                return False        return True        class Solution:    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:        counts = {}        for c in magazine:            counts[c] = counts.get(c, 0) + 1        for c in ransomNote:            if c not in counts or counts[c] == 0:                return False            counts[c] -= 1        return True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用数组class Solution:    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:        ransom_count = [0] * 26        magazine_count = [0] * 26        for c in ransomNote:            ransom_count[ord(c) - ord('a')] += 1        for c in magazine:            magazine_count[ord(c) - ord('a')] += 1        return all(ransom_count[i] &lt;= magazine_count[i] for i in range(26))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用Counterfrom collections import Counterclass Solution:    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:        return not Counter(ransomNote) - Counter(magazine)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用countclass Solution:    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:        return all(ransomNote.count(c) &lt;= magazine.count(c) for c in set(ransomNote))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-三数之和"><a href="#8-三数之和" class="headerlink" title="8.三数之和"></a>8.三数之和</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p><p>示例：</p><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p><pre class="line-numbers language-none"><code class="language-none">#双指针法class Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        result = []        nums.sort()                for i in range(len(nums)):            # 如果第一个元素已经大于0，不需要进一步检查            if nums[i] &gt; 0:                return result                        # 跳过相同的元素以避免重复            if i &gt; 0 and nums[i] == nums[i - 1]:                continue                            left = i + 1            right = len(nums) - 1                        while right &gt; left:                sum_ = nums[i] + nums[left] + nums[right]                                if sum_ &lt; 0:                    left += 1                elif sum_ &gt; 0:                    right -= 1                else:                    result.append([nums[i], nums[left], nums[right]])                                        # 跳过相同的元素以避免重复                    while right &gt; left and nums[right] == nums[right - 1]:                        right -= 1                    while right &gt; left and nums[left] == nums[left + 1]:                        left += 1                                            right -= 1                    left += 1                            return result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用字典class Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        result = []        nums.sort()        # 找出a + b + c = 0        # a = nums[i], b = nums[j], c = -(a + b)        for i in range(len(nums)):            # 排序之后如果第一个元素已经大于零，那么不可能凑成三元组            if nums[i] &gt; 0:                break            if i &gt; 0 and nums[i] == nums[i - 1]: #三元组元素a去重                continue            d = {}            for j in range(i + 1, len(nums)):                if j &gt; i + 2 and nums[j] == nums[j-1] == nums[j-2]: # 三元组元素b去重                    continue                c = 0 - (nums[i] + nums[j])                if c in d:                    result.append([nums[i], nums[j], c])                    d.pop(c) # 三元组元素c去重                else:                    d[nums[j]] = j        return result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-四数之和"><a href="#9-四数之和" class="headerlink" title="9.四数之和"></a>9.四数之和</h3><p>题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p>示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p><pre class="line-numbers language-none"><code class="language-none">#和前面三数之和思路一致，多一层循环，多一些判断条件class Solution:    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:        result=[]        nums.sort()        print(nums)        for i in range(len(nums)-3):            # print(f"i的值是{i}")            if i&gt;0 and nums[i]==nums[i-1]:                continue            #在后面求三个数            for j in range(i+1,len(nums)-2):                # print(f"j的值是{j}")                if j&gt;i+1 and nums[j]==nums[j-1]:                    continue                my_target=target-nums[i]-nums[j]                left=j+1                right=len(nums)-1                while right&gt;left:                    # print(f"l的值，r的值是{left},{right}")                    if nums[right]+nums[left]&gt;my_target:                        right-=1                    elif nums[right]+nums[left]&lt;my_target:                        left+=1                    else:                        result.append([nums[i],nums[j],nums[right],nums[left]])                        left+=1                        while nums[left]==nums[left-1] and left&lt;right:                            left+=1                        right-=1                        while nums[right]==nums[right+1] and right&gt;left:                            right-=1        return result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用字典class Solution(object):    def fourSum(self, nums, target):        """        :type nums: List[int]        :type target: int        :rtype: List[List[int]]        """        # 创建一个字典来存储输入列表中每个数字的频率        freq = {}        for num in nums:            freq[num] = freq.get(num, 0) + 1                # 创建一个集合来存储最终答案，并遍历4个数字的所有唯一组合        ans = set()        for i in range(len(nums)):            for j in range(i + 1, len(nums)):                for k in range(j + 1, len(nums)):                    val = target - (nums[i] + nums[j] + nums[k])                    if val in freq:                        # 确保没有重复                        count = (nums[i] == val) + (nums[j] == val) + (nums[k] == val)                        if freq[val] &gt; count:                            ans.add(tuple(sorted([nums[i], nums[j], nums[k], val])))                return [list(x) for x in ans]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>一般来说哈希表都是用来快速判断一个元素是否出现集合里</strong></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="1-反转字符串"><a href="#1-反转字符串" class="headerlink" title="1.反转字符串"></a>1.反转字符串</h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><pre class="line-numbers language-none"><code class="language-none">#我是🤡class Solution:    def reverseString(self, s: List[str]) -&gt; None:        """        Do not return anything, modify s in-place instead.        """        length=len(s)        for i in range(int(length/2)):            temp=s[i]            s[i]=s[length-1-i]            s[length-1-i]=temp        return s          class Solution:    def reverseString(self, s: List[str]) -&gt; None:        """        Do not return anything, modify s in-place instead.        """        left, right = 0, len(s) - 1                # 该方法已经不需要判断奇偶数，经测试后时间空间复杂度比用 for i in range(len(s)//2)更低        # 因为while每次循环需要进行条件判断，而range函数不需要，直接生成数字，因此时间复杂度更低。推荐使用range        while left &lt; right:            s[left], s[right] = s[right], s[left]            left += 1            right -= 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class Solution:    def reverseString(self, s: List[str]) -&gt; None:        """        Do not return anything, modify s in-place instead.        """        stack = []        for char in s:            stack.append(char)        for i in range(len(s)):            s[i] = stack.pop()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class Solution:    def reverseString(self, s: List[str]) -&gt; None:        """        Do not return anything, modify s in-place instead.        """        s[:] = reversed(s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class Solution:    def reverseString(self, s: List[str]) -&gt; None:        """        Do not return anything, modify s in-place instead.        """        s[:] = s[::-1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class Solution:    def reverseString(self, s: List[str]) -&gt; None:        """        Do not return anything, modify s in-place instead.        """        s[:] = [s[i] for i in range(len(s) - 1, -1, -1)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-反转字符串II"><a href="#2-反转字符串II" class="headerlink" title="2.反转字符串II"></a>2.反转字符串II</h3><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s = “abcdefg”, k = 2<br>输出: “bacdfeg”</p><pre class="line-numbers language-none"><code class="language-none">class Solution:    def reverseStr(self, s: str, k: int) -&gt; str:        """        1. 使用range(start, end, step)来确定需要调换的初始位置        2. 对于字符串s = 'abc'，如果使用s[0:999] ===&gt; 'abc'。字符串末尾如果超过最大长度，则会返回至字符串最后一个值，这个特性可以避免一些边界条件的处理。        3. 用切片整体替换，而不是一个个替换.        """        def reverse_substring(text):            left, right = 0, len(text) - 1            while left &lt; right:                text[left], text[right] = text[right], text[left]                left += 1                right -= 1            return text                res = list(s)        for cur in range(0, len(s), 2 * k):                        res[cur: cur + k] = reverse_substring(res[cur: cur + k])        return ''.join(res)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class Solution:    def reverseStr(self, s: str, k: int) -&gt; str:        # Two pointers. Another is inside the loop.        p = 0        while p &lt; len(s):            p2 = p + k            # Written in this could be more pythonic.            s = s[:p] + s[p: p2][::-1] + s[p2:]            p = p + 2 * k        return s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python中字符串和列表都是可以越界的</p><h3 id="3-替换空格"><a href="#3-替换空格" class="headerlink" title="3.替换空格"></a>3.替换空格</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1： 输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><pre class="line-numbers language-none"><code class="language-none">#双指针法class Solution:    def replaceSpace(self, s: str) -&gt; str:        counter = s.count(' ')                res = list(s)        # 每碰到一个空格就多拓展两个格子，1 + 2 = 3个位置存’%20‘        res.extend([' '] * counter * 2)                # 原始字符串的末尾，拓展后的末尾        left, right = len(s) - 1, len(res) - 1                while left &gt;= 0:            if res[left] != ' ':                res[right] = res[left]                right -= 1            else:                # [right - 2, right), 左闭右开                res[right - 2: right + 1] = '%20'                right -= 3            left -= 1        return ''.join(res)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#额外使用一个空列表class Solution:    def replaceSpace(self, s: str) -&gt; str:        res = []        for i in range(len(s)):            if s[i] == ' ':                res.append('%20')            else:                res.append(s[i])        return ''.join(res)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用切片、class Solution:    def replaceSpace(self, s: str) -&gt; str:        n = len(s)        for e, i in enumerate(s[::-1]):            print(i, e)            if i == " ":                s = s[: n - (e + 1)] + "%20" + s[n - e:]            print("")        return s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用join和splitclass Solution:    def replaceSpace(self, s: str) -&gt; str:        return "%20".join(s.split(" "))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用rclass Solution:    def replaceSpace(self, s: str) -&gt; str:        return s.replace(' ', '%20')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-反转字符串中的单词"><a href="#4-反转字符串中的单词" class="headerlink" title="4.反转字符串中的单词"></a>4.反转字符串中的单词</h3><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good  example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个</p><pre class="line-numbers language-none"><code class="language-none">class Solution:    def reverseWords(self, s: str) -&gt; str:        s=s.strip()        s_list=s.split()        print(s_list)        ss_list=[]        for i in range(len(s_list)-1,-1,-1):            ss_list.append(s_list[i])        return " ".join(ss_list)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">双指针class Solution:    def reverseWords(self, s: str) -&gt; str:        # 将字符串拆分为单词，即转换成列表类型        words = s.split()        # 反转单词        left, right = 0, len(words) - 1        while left &lt; right:            words[left], words[right] = words[right], words[left]            left += 1            right -= 1        # 将列表转换成字符串        return " ".join(words)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-左旋转字符串"><a href="#5-左旋转字符串" class="headerlink" title="5.左旋转字符串"></a>5.左旋转字符串</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>示例 1：<br>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”</p><p>示例 2：<br>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p><p>限制：<br>1 &lt;= k &lt; s.length &lt;= 10000</p><pre class="line-numbers language-none"><code class="language-none">class Solution:    def reverseLeftWords(self, s: str, n: int) -&gt; str:        return s[n:]+s[0:n]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#反转reversed+joinclass Solution:    def reverseLeftWords(self, s: str, n: int) -&gt; str:        s = list(s)        s[0:n] = list(reversed(s[0:n]))        s[n:] = list(reversed(s[n:]))        s.reverse()                return "".join(s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#自定义实现reverse功能class Solution:    def reverseLeftWords(self, s: str, n: int) -&gt; str:               s_list = list(s)                self.reverse(s_list, 0, n - 1)                self.reverse(s_list, n, len(s_list) - 1)        self.reverse(s_list, 0, len(s_list) - 1)        return ''.join(s_list)            def reverse(self, s, start, end):        while start &lt; end:            s[start], s[end] = s[end], s[start]            start += 1            end -= 1   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用模加下标class Solution:    def reverseLeftWords(self, s: str, n: int) -&gt; str:        new_s = ''        for i in range(len(s)):            j = (i+n)%len(s)            new_s = new_s + s[j]        return new_s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用模加切片class Solution:    def reverseLeftWords(self, s: str, n: int) -&gt; str:        l = len(s)        # 复制输入字符串与它自己连接        s = s + s                # 计算旋转字符串的起始索引        k = n % (l * 2)                # 从连接的字符串中提取旋转后的字符串并返回        return s[k : k + l]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-实现strStr"><a href="#6-实现strStr" class="headerlink" title="6.实现strStr()"></a>6.实现strStr()</h3><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p><p>示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2</p><p>示例 2: 输入: haystack = “aaaaa”, needle = “bba” 输出: -1</p><p>说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p><pre class="line-numbers language-none"><code class="language-none">#利用切片class Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        for i in range(len(haystack)-len(needle)+1):            if haystack[i:i+len(needle)]==needle:                return i        return -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong>所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。</p><h5 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h5><p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong>next数组就是一个前缀表。那么什么是前缀表：<strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p><p>之前在码蹄集上做过求最长公共前后缀的题目。</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230901170010973.png" alt="image-20230901170010973"></p><pre class="line-numbers language-none"><code class="language-none">#使用findclass Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        return haystack.find(needle)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用indexclass Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        try:            return haystack.index(needle)        except ValueError:            return -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#KMP算法，不减一class Solution:    def getNext(self, next: List[int], s: str) -&gt; None:        j = 0        next[0] = 0        for i in range(1, len(s)):            while j &gt; 0 and s[i] != s[j]:                j = next[j - 1]            if s[i] == s[j]:                j += 1            next[i] = j        def strStr(self, haystack: str, needle: str) -&gt; int:        if len(needle) == 0:            return 0        next = [0] * len(needle)        self.getNext(next, needle)        j = 0        for i in range(len(haystack)):            while j &gt; 0 and haystack[i] != needle[j]:                j = next[j - 1]            if haystack[i] == needle[j]:                j += 1            if j == len(needle):                return i - len(needle) + 1        return -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class Solution:    def getNext(self, next: List[int], s: str) -&gt; None:        j = 0        next[0] = 0        for i in range(1, len(s)):            while j &gt; 0 and s[i] != s[j]:                j = next[j - 1]            if s[i] == s[j]:                j += 1            next[i] = j        def strStr(self, haystack: str, needle: str) -&gt; int:        if len(needle) == 0:            return 0        next = [0] * len(needle)        self.getNext(next, needle)        j = 0        for i in range(len(haystack)):            while j &gt; 0 and haystack[i] != needle[j]:                j = next[j - 1]            if haystack[i] == needle[j]:                j += 1            if j == len(needle):                return i - len(needle) + 1        return -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-重复的子字符串"><a href="#7-重复的子字符串" class="headerlink" title="7.重复的子字符串"></a>7.重复的子字符串</h3><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:</p><ul><li>输入: “abab”</li><li>输出: True</li><li>解释: 可由子字符串 “ab” 重复两次构成。</li></ul><p>示例 2:</p><ul><li>输入: “aba”</li><li>输出: False</li></ul><p>示例 3:</p><ul><li>输入: “abcabcabcabc”</li><li>输出: True</li><li>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成</li></ul><pre class="line-numbers language-none"><code class="language-none">#暴力匹配class Solution:    def repeatedSubstringPattern(self, s: str) -&gt; bool:        for i in range(len(s)-1):            new_s=s[:i+1]            add_s=s[:i+1]            while len(new_s)&lt;=len(s):                if new_s==s:                    return True                new_s=new_s+add_s        return False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#移动匹配，原理是：如果子串可以形成s，将两个s拼接起来，还可以形成一个sclass Solution:    def repeatedSubstringPattern(self, s: str) -&gt; bool:        new_s=s+s        for i in range(1,len(s)):            if new_s[i:i+len(s)]==s:                return True        return False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用findclass Solution:    def repeatedSubstringPattern(self, s: str) -&gt; bool:        n = len(s)        if n &lt;= 1:            return False        ss = s[1:] + s[:-1]         print(ss.find(s))                      return ss.find(s) != -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#使用前缀表class Solution:    def repeatedSubstringPattern(self, s: str) -&gt; bool:          if len(s) == 0:            return False        nxt = [0] * len(s)        self.getNext(nxt, s)        if nxt[-1] != 0 and len(s) % (len(s) - nxt[-1]) == 0:            return True        return False        def getNext(self, nxt, s):        nxt[0] = 0        j = 0        for i in range(1, len(s)):            while j &gt; 0 and s[i] != s[j]:                j = nxt[j - 1]            if s[i] == s[j]:                j += 1            nxt[i] = j        return nxt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><h3 id="1-移除元素"><a href="#1-移除元素" class="headerlink" title="1.移除元素"></a>1.移除元素</h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p><p>示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><pre class="line-numbers language-none"><code class="language-none">class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        # 快慢指针        fast = 0  # 快指针        slow = 0  # 慢指针        size = len(nums)        while fast &lt; size:  # 不加等于是因为，a = size 时，nums[a] 会越界            # slow 用来收集不等于 val 的值，如果 fast 对应值不等于 val，则把它与 slow 替换            if nums[fast] != val:                nums[slow] = nums[fast]                slow += 1            fast += 1        return slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        i, l = 0, len(nums)        while i &lt; l:            if nums[i] == val: # 找到等于目标值的节点                for j in range(i+1, l): # 移除该元素，并将后面元素向前平移                    nums[j - 1] = nums[j]                l -= 1                i -= 1            i += 1        return l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-反转字符串"><a href="#2-反转字符串" class="headerlink" title="2.反转字符串"></a>2.反转字符串</h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><pre class="line-numbers language-none"><code class="language-none">class Solution:    def reverseString(self, s: List[str]) -&gt; None:        """        Do not return anything, modify s in-place instead.        """        left, right = 0, len(s) - 1                # 该方法已经不需要判断奇偶数，经测试后时间空间复杂度比用 for i in range(len(s)//2)更低        # 因为while每次循环需要进行条件判断，而range函数不需要，直接生成数字，因此时间复杂度更低。推荐使用range        while left &lt; right:            s[left], s[right] = s[right], s[left]            left += 1            right -= 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class Solution:    def reverseString(self, s: List[str]) -&gt; None:        """        Do not return anything, modify s in-place instead.        """        stack = []        for char in s:            stack.append(char)        for i in range(len(s)):            s[i] = stack.pop()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="1-栈与队列理论基础"><a href="#1-栈与队列理论基础" class="headerlink" title="1.栈与队列理论基础"></a>1.栈与队列理论基础</h3><p>利用C++讲的，我感觉好难。。。。</p><h3 id="2-用栈实现队列"><a href="#2-用栈实现队列" class="headerlink" title="2.用栈实现队列"></a>2.用栈实现队列</h3><p>使用栈实现队列的下列操作：</p><p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。</p><pre class="line-numbers language-none"><code class="language-none">class MyQueue:    def __init__(self):        self.my_list=[]    def push(self, x: int) -&gt; None:        self.my_list.append(x)    def pop(self) -&gt; int:        return self.my_list.pop(0)    def peek(self) -&gt; int:        return self.my_list[0]    def empty(self) -&gt; bool:        return True if len(self.my_list)==0 else False# Your MyQueue object will be instantiated and called as such:# obj = MyQueue()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.peek()# param_4 = obj.empty()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-用队列实现栈"><a href="#3-用队列实现栈" class="headerlink" title="3.用队列实现栈"></a>3.用队列实现栈</h3><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p>注意:</p><ul><li>你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）</li></ul><pre class="line-numbers language-none"><code class="language-none">class MyStack:    def __init__(self):        self.my_list=[]    def push(self, x: int) -&gt; None:        self.my_list.append(x)    def pop(self) -&gt; int:        return self.my_list.pop()    def top(self) -&gt; int:        return self.my_list[len(self.my_list)-1]    def empty(self) -&gt; bool:        return False if len(self.my_list)!=0 else True# Your MyStack object will be instantiated and called as such:# obj = MyStack()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.top()# param_4 = obj.empty()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class MyStack:    def __init__(self):        self.que = deque()    def push(self, x: int) -&gt; None:        self.que.append(x)    def pop(self) -&gt; int:        if self.empty():            return None        for i in range(len(self.que)-1):            self.que.append(self.que.popleft())        return self.que.popleft()    def top(self) -&gt; int:        if self.empty():            return None        return self.que[-1]    def empty(self) -&gt; bool:        return not self.que<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日常笔记</title>
      <link href="/2023/08/25/ri-chang-bi-ji/"/>
      <url>/2023/08/25/ri-chang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230825194527495.png" alt="image-20230825194527495"></p><h4 id="代码随想录计划："><a href="#代码随想录计划：" class="headerlink" title="代码随想录计划："></a>代码随想录计划：</h4><pre class="line-numbers language-none"><code class="language-none">允许超额完成，数组：7√链表：9√哈希表：10前5个√8月29日完成字符串：8 8月30日完成双指针法：11 8月31日完成栈和队列：99月1日二叉树：349月4日回溯算法：229月7日贪心算法：249月10日动态规划：549月15日单调栈：59月16日额外题目：找一个时间测试，一套题目给15分钟。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="百度飞桨实训："><a href="#百度飞桨实训：" class="headerlink" title="百度飞桨实训："></a>百度飞桨实训：</h4><pre class="line-numbers language-none"><code class="language-none">一天保证2节即可<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="jack的网站"><a href="#jack的网站" class="headerlink" title="jack的网站"></a>jack的网站</h4><pre class="line-numbers language-none"><code class="language-none">至少一篇学习3篇博客<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2023/08/25/zheng-ze-biao-da-shi/"/>
      <url>/2023/08/25/zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<p>学了很多遍，忘了无数遍O(∩_∩)O(来源于菜鸟教程)</p><p>正则表达式是一种用于模式匹配和搜索文本的工具。</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230825133746992.png" alt="r"></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230825133820586.png" alt="image-20230825133820586"></p><h2 id="正则表达式元字符和特性"><a href="#正则表达式元字符和特性" class="headerlink" title="正则表达式元字符和特性"></a>正则表达式元字符和特性</h2><h3 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h3><ul><li>普通字符：普通字符按照字面意义进行匹配，例如匹配字母 “a” 将匹配到文本中的 “a” 字符。</li><li>元字符：元字符具有特殊的含义，例如 <code>\d</code> 匹配任意数字字符，<code>\w</code> 匹配任意字母数字字符，<code>.</code> 匹配任意字符（除了换行符）等。</li></ul><h4 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h4><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><p>[ABC]：匹配[…]中的所有字符；</p><p>[^ABC]：匹配除了[…]中的所有字符；</p><p>[A-Z]：匹配所有的大写字母；</p><p>.   ：匹配除了换行符(\n，\r)之外的任何单个字符；相当于[^\r\n]</p><p>[\s\S]：匹配所有,   \s是匹配所有的空白符，包括换行，\S匹配所有的非空白符，不包括换行。</p><p>\w  :匹配字母、数字、下划线；等价于[A-Za-z0-9_]</p><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><ul><li><code>*</code>：匹配前面的模式零次或多次。</li><li><code>+</code>：匹配前面的模式一次或多次。</li><li><code>?</code>：匹配前面的模式零次或一次。</li><li><code>{n}</code>：匹配前面的模式恰好 n 次。</li><li><code>{n,}</code>：匹配前面的模式至少 n 次。</li><li><code>{n,m}</code>：匹配前面的模式至少 n 次且不超过 m 次。</li></ul><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><ul><li><code>[ ]</code>：匹配括号内的任意一个字符。例如，<code>[abc]</code> 匹配字符 “a”、”b” 或 “c”。</li><li><code>[^ ]</code>：匹配除了括号内的字符以外的任意一个字符。例如，<code>[^abc]</code> 匹配除了字符 “a”、”b” 或 “c” 以外的任意字符。</li></ul><h3 id="边界匹配"><a href="#边界匹配" class="headerlink" title="边界匹配"></a>边界匹配</h3><ul><li><code>^</code>：匹配字符串的开头。</li><li><code>$</code>：匹配字符串的结尾。</li><li><code>\b</code>：匹配单词边界。</li><li><code>\B</code>：匹配非单词边界。</li></ul><h3 id="分组和捕获"><a href="#分组和捕获" class="headerlink" title="分组和捕获"></a>分组和捕获</h3><ul><li><code>( )</code>：用于分组和捕获子表达式。</li><li><code>(?: )</code>：用于分组但不捕获子表达式。</li></ul><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><ul><li><code>\</code>：转义字符，用于匹配特殊字符本身。</li><li><code>.</code>：匹配任意字符（除了换行符）。</li><li><code>|</code>：用于指定多个模式的选择。</li></ul><h2 id="python中的正则表达式"><a href="#python中的正则表达式" class="headerlink" title="python中的正则表达式"></a>python中的正则表达式</h2><h5 id="re-match函数"><a href="#re-match函数" class="headerlink" title="re.match函数"></a>re.match函数</h5><p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match() 就返回 none。</p><pre class="line-numbers language-none"><code class="language-none">re.match(pattern, string, flags=0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">pattern</td><td align="left">匹配的正则表达式</td></tr><tr><td align="left">string</td><td align="left">要匹配的字符串。</td></tr><tr><td align="left">flags</td><td align="left">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：<a href="https://www.runoob.com/python/python-reg-expressions.html#flags">正则表达式修饰符 - 可选标志</a></td></tr></tbody></table><p>匹配成功 re.match 方法返回一个匹配的对象，否则返回 None。</p><p>实例</p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/pythonimport re line = "Cats are smarter than dogs" matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I) if matchObj:   print "matchObj.group() : ", matchObj.group()   print "matchObj.group(1) : ", matchObj.group(1)   print "matchObj.group(2) : ", matchObj.group(2)else:   print "No match!!"   matchObj.group() :  Cats are smarter than dogsmatchObj.group(1) :  CatsmatchObj.group(2) :  smarter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释：</p><pre class="line-numbers language-none"><code class="language-none">这个正则表达式 r'(.*) are (.*?) .*' 使用了Python中的原始字符串（raw string），其中包含了一些特殊的正则表达式语法。解释这个正则表达式的含义如下：(.*)：这是一个捕获组（Capturing Group），用括号括起来。它匹配任意字符（除了换行符）零次或多次。.* 表示匹配任意字符（除了换行符）零次或多次。are：匹配字面值字符串 "are"。(.*?)：这是另一个捕获组。它使用了非贪婪（non-greedy）的匹配方式，表示尽可能少地匹配任意字符。.*? 表示匹配任意字符零次或多次，但尽可能少地匹配。.*：匹配任意字符（除了换行符）零次或多次。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="re-search函数"><a href="#re-search函数" class="headerlink" title="re.search函数"></a>re.search函数</h5><p>扫描整个字符串返回第一个成功的匹配。</p><p>函数语法：</p><pre class="line-numbers language-none"><code class="language-none">re.search(pattern, string, flags=0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">pattern</td><td align="left">匹配的正则表达式</td></tr><tr><td align="left">string</td><td align="left">要匹配的字符串。</td></tr><tr><td align="left">flags</td><td align="left">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</td></tr></tbody></table><p>匹配成功re.search方法返回一个匹配的对象，否则返回None。</p><p>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。</p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/pythonimport re line = "Cats are smarter than dogs"; searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I) if searchObj:   print "searchObj.group() : ", searchObj.group()   print "searchObj.group(1) : ", searchObj.group(1)   print "searchObj.group(2) : ", searchObj.group(2)else:   print "Nothing found!!"      searchObj.group() :  Cats are smarter than dogssearchObj.group(1) :  CatssearchObj.group(2) :  smarter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="re-match与re-search的区别"><a href="#re-match与re-search的区别" class="headerlink" title="re.match与re.search的区别"></a>re.match与re.search的区别</h5><p>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p><h5 id="检索和替换"><a href="#检索和替换" class="headerlink" title="检索和替换"></a>检索和替换</h5><pre class="line-numbers language-none"><code class="language-none">re.sub(pattern, repl, string, count=0, flags=0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数：</p><ul><li>pattern : 正则中的模式字符串。</li><li>repl : 替换的字符串，也可为一个函数。</li><li>string : 要被查找替换的原始字符串。</li><li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li></ul><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/python# -*- coding: UTF-8 -*- import re phone = "2004-959-559 # 这是一个国外电话号码" # 删除字符串中的 Python注释 num = re.sub(r'#.*$', "", phone)print "电话号码是: ", num # 删除非数字(-)的字符串 num = re.sub(r'\D', "", phone)print "电话号码是 : ", num电话号码是:  2004-959-559 电话号码是 :  2004959559<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/python# -*- coding: UTF-8 -*- import re # 将匹配的数字乘以 2def double(matched):    value = int(matched.group('value'))    return str(value * 2) s = 'A23G4HFD567'print(re.sub('(?P&lt;value&gt;\d+)', double, s))A46G8HFD1134<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="re-compile函数"><a href="#re-compile函数" class="headerlink" title="re.compile函数"></a>re.compile函数</h5><p>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</p><p>语法格式为：</p><pre class="line-numbers language-none"><code class="language-none">re.compile(pattern[, flags])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数：</p><ul><li><strong>pattern</strong> : 一个字符串形式的正则表达式</li><li><strong>flags</strong> : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：<ol><li><strong>re.I</strong> 忽略大小写</li><li><strong>re.L</strong> 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境</li><li><strong>re.M</strong> 多行模式</li><li><strong>re.S</strong> 即为 <strong>.</strong> 并且包括换行符在内的任意字符（**.** 不包括换行符）</li><li><strong>re.U</strong> 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库</li><li><strong>re.X</strong> 为了增加可读性，忽略空格和 <strong>#</strong> 后面的注释</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt;import re&gt;&gt;&gt; pattern = re.compile(r'\d+')                    # 用于匹配至少一个数字&gt;&gt;&gt; m = pattern.match('one12twothree34four')        # 查找头部，没有匹配&gt;&gt;&gt; print mNone&gt;&gt;&gt; m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配&gt;&gt;&gt; print mNone&gt;&gt;&gt; m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配&gt;&gt;&gt; print m                                         # 返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10a42aac0&gt;&gt;&gt;&gt; m.group(0)   # 可省略 0'12'&gt;&gt;&gt; m.start(0)   # 可省略 03&gt;&gt;&gt; m.end(0)     # 可省略 05&gt;&gt;&gt; m.span(0)    # 可省略 0(3, 5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="re-split"><a href="#re-split" class="headerlink" title="re.split"></a>re.split</h5><p>split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：</p><pre class="line-numbers language-none"><code class="language-none">re.split(pattern, string[, maxsplit=0, flags=0])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">pattern</td><td align="left">匹配的正则表达式</td></tr><tr><td align="left">string</td><td align="left">要匹配的字符串。</td></tr><tr><td align="left">maxsplit</td><td align="left">分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。</td></tr><tr><td align="left">flags</td><td align="left">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：<a href="https://www.runoob.com/python/python-reg-expressions.html#flags">正则表达式修饰符 - 可选标志</a></td></tr></tbody></table><h4 id="特殊字符类"><a href="#特殊字符类" class="headerlink" title="特殊字符类"></a>特殊字符类</h4><table><thead><tr><th align="left">实例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">.</td><td align="left">匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</td></tr><tr><td align="left">\d</td><td align="left">匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td align="left">\D</td><td align="left">匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\w</td><td align="left">匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。</td></tr><tr><td align="left">\W</td><td align="left">匹配任何非单词字符。等价于’[^A-Za-z0-9_]’。</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AI工程师调研</title>
      <link href="/2023/08/22/ai-gong-cheng-shi-diao-yan/"/>
      <url>/2023/08/22/ai-gong-cheng-shi-diao-yan/</url>
      
        <content type="html"><![CDATA[<p>1</p><p>每天要学习一点算法，然后是机器学习</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230822164524095.png" alt="image-20230822164524095"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AI studio实践</title>
      <link href="/2023/08/13/ai-studio-shi-jian/"/>
      <url>/2023/08/13/ai-studio-shi-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="机器学习实践"><a href="#机器学习实践" class="headerlink" title="机器学习实践"></a>机器学习实践</h2><h3 id="一：海量文件遍历"><a href="#一：海量文件遍历" class="headerlink" title="一：海量文件遍历"></a>一：海量文件遍历</h3><p>工作目录：</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230813174911046.png" alt="image-20230813174911046"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">!tree <span class="token operator">-</span>L <span class="token number">3</span> <span class="token punctuation">.</span><span class="token operator">/</span>data<span class="token operator">/</span><span class="token punctuation">.</span><span class="token operator">/</span>data<span class="token operator">/</span>└── data10954    ├── cat_12_test<span class="token punctuation">.</span><span class="token builtin">zip</span>    ├── cat_12_train<span class="token punctuation">.</span><span class="token builtin">zip</span>    └── train_list<span class="token punctuation">.</span>txt<span class="token comment">#显示文件目录详情</span><span class="token keyword">import</span> zipfile<span class="token keyword">import</span> os<span class="token keyword">def</span> <span class="token function">unzip_data</span><span class="token punctuation">(</span>src_path<span class="token punctuation">,</span>target_path<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 解压原始数据集，将src_path路径下的zip包解压至target_path目录下</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>target_path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>             z <span class="token operator">=</span> zipfile<span class="token punctuation">.</span>ZipFile<span class="token punctuation">(</span>src_path<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span>        z<span class="token punctuation">.</span>extractall<span class="token punctuation">(</span>path<span class="token operator">=</span>target_path<span class="token punctuation">)</span>        z<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>unzip_data<span class="token punctuation">(</span><span class="token string">'data/data10954/cat_12_train.zip'</span><span class="token punctuation">,</span><span class="token string">'data/data10954/cat_12_train'</span><span class="token punctuation">)</span>unzip_data<span class="token punctuation">(</span><span class="token string">'data/data10954/cat_12_test.zip'</span><span class="token punctuation">,</span><span class="token string">'data/data10954/cat_12_test'</span><span class="token punctuation">)</span><span class="token comment">#解压文件</span><span class="token keyword">import</span> os <span class="token triple-quoted-string string">"""通过给定目录，统计所有的不同子文件类型及占用内存"""</span>size_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>type_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">get_size_type</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>        files <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span>    <span class="token keyword">for</span> filename <span class="token keyword">in</span> files<span class="token punctuation">:</span>        temp_path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>path<span class="token punctuation">,</span> filename<span class="token punctuation">)</span>        <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>temp_path<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 递归调用函数，实现深度文件名解析</span>            get_size_type<span class="token punctuation">(</span>temp_path<span class="token punctuation">)</span>             <span class="token keyword">elif</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isfile<span class="token punctuation">(</span>temp_path<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 获取文件后缀</span>            type_name<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>splitext<span class="token punctuation">(</span>temp_path<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>               <span class="token comment">#无后缀名的文件</span>            <span class="token keyword">if</span> <span class="token keyword">not</span> type_name<span class="token punctuation">:</span>                type_dict<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span><span class="token string">"None"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>                type_dict<span class="token punctuation">[</span><span class="token string">"None"</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                size_dict<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span><span class="token string">"None"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>                size_dict<span class="token punctuation">[</span><span class="token string">"None"</span><span class="token punctuation">]</span> <span class="token operator">+=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>getsize<span class="token punctuation">(</span>temp_path<span class="token punctuation">)</span>            <span class="token comment"># 有后缀的文件</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                type_dict<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>type_name<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>                type_dict<span class="token punctuation">[</span>type_name<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                size_dict<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>type_name<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token comment"># 获取文件大小</span>                size_dict<span class="token punctuation">[</span>type_name<span class="token punctuation">]</span> <span class="token operator">+=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>getsize<span class="token punctuation">(</span>temp_path<span class="token punctuation">)</span>      path<span class="token operator">=</span> <span class="token string">"data/"</span>get_size_type<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token keyword">for</span> each_type <span class="token keyword">in</span> type_dict<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"%5s下共有【%5s】的文件【%5d】个,占用内存【%7.2f】MB"</span> <span class="token operator">%</span>                 <span class="token punctuation">(</span>path<span class="token punctuation">,</span>each_type<span class="token punctuation">,</span>type_dict<span class="token punctuation">[</span>each_type<span class="token punctuation">]</span><span class="token punctuation">,</span>\            size_dict<span class="token punctuation">[</span>each_type<span class="token punctuation">]</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"总文件数:  【%d】"</span><span class="token operator">%</span><span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">(</span>type_dict<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"总内存大小:【%.2f】GB"</span><span class="token operator">%</span><span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">(</span>size_dict<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">**</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二：简单计算器实现"><a href="#二：简单计算器实现" class="headerlink" title="二：简单计算器实现"></a>二：简单计算器实现</h3><p>抽象出几个函数：</p><p>（1）弹栈时计算‘两个数字和运算符组成的算式’结果的函数。</p><p>（2）判断元素是数字还是运算符的函数。</p><p>（3）把算式处理成列表形式的函数。如：’-1-2*((-2+3)+(-2/2))’ 应该处理成：[‘-1’, ‘-‘, ‘2’, ‘*’, ‘(‘, ‘(‘, ‘-2’, ‘+’, ‘3’, ‘)’, ‘+’, ‘(‘, ‘-2’, ‘/‘, ‘2’, ‘)’, ‘)’] 。</p><p>（4）决策函数，决定应该是入栈，弹栈运算，还是弹栈丢弃。</p><p>（5）主函数，遍历算式列表，计算最终结果。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> re<span class="token keyword">def</span> <span class="token function">calculate</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> operator<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''    :param n1: float    :param n2: float    :param operator: + - * /    :return: float    '''</span>    result <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">if</span> operator <span class="token operator">==</span> <span class="token string">"+"</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> n1 <span class="token operator">+</span> n2    <span class="token keyword">if</span> operator <span class="token operator">==</span> <span class="token string">"-"</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> n1 <span class="token operator">-</span> n2    <span class="token keyword">if</span> operator <span class="token operator">==</span> <span class="token string">"*"</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> n1 <span class="token operator">*</span> n2    <span class="token keyword">if</span> operator <span class="token operator">==</span> <span class="token string">"/"</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> n1 <span class="token operator">/</span> n2    <span class="token keyword">return</span> resultdef calculate<span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> operator<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''    :param n1: float    :param n2: float    :param operator: + - * /    :return: float    '''</span>    result <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">if</span> operator <span class="token operator">==</span> <span class="token string">"+"</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> n1 <span class="token operator">+</span> n2    <span class="token keyword">if</span> operator <span class="token operator">==</span> <span class="token string">"-"</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> n1 <span class="token operator">-</span> n2    <span class="token keyword">if</span> operator <span class="token operator">==</span> <span class="token string">"*"</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> n1 <span class="token operator">*</span> n2    <span class="token keyword">if</span> operator <span class="token operator">==</span> <span class="token string">"/"</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> n1 <span class="token operator">/</span> n2    <span class="token keyword">return</span> result     <span class="token comment"># 判断是否是运算符，如果是返回True</span><span class="token keyword">def</span> <span class="token function">is_operator</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''    :param e: str    :return: bool    '''</span>    opers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token boolean">True</span> <span class="token keyword">if</span> e <span class="token keyword">in</span> opers <span class="token keyword">else</span> <span class="token boolean">False</span>    <span class="token comment"># 将算式处理成列表，解决-是负数还是减号</span><span class="token keyword">def</span> <span class="token function">formula_format</span><span class="token punctuation">(</span>formula<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 去掉算式中的空格</span>    formula <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> formula<span class="token punctuation">)</span>    <span class="token comment"># 以 '横杠数字' 分割， 其中正则表达式：(\-\d+\.?\d*) 括号内：</span>    <span class="token comment"># \- 表示匹配横杠开头； \d+ 表示匹配数字1次或多次；\.?表示匹配小数点0次或1次;\d*表示匹配数字1次或多次。</span>    formula_list <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'(\-\d+\.?\d*)'</span><span class="token punctuation">,</span> formula<span class="token punctuation">)</span> <span class="token keyword">if</span> i<span class="token punctuation">]</span>     <span class="token comment"># 最终的算式列表</span>    final_formula <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> item <span class="token keyword">in</span> formula_list<span class="token punctuation">:</span>        <span class="token comment"># 第一个是以横杠开头的数字（包括小数）final_formula。即第一个是负数，横杠就不是减号</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>final_formula<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'^\-\d+\.?\d*$'</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>            final_formula<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">)</span>            <span class="token keyword">continue</span>         <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>final_formula<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># 如果final_formal最后一个元素是运算符['+', '-', '*', '/', '('], 则横杠数字不是负数</span>            <span class="token keyword">if</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'[\+\-\*\/\(]$'</span><span class="token punctuation">,</span> final_formula<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                final_formula<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">)</span>                <span class="token keyword">continue</span>        <span class="token comment"># 按照运算符分割开</span>        item_split <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'([\+\-\*\/\(\)])'</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span> <span class="token keyword">if</span> i<span class="token punctuation">]</span>        final_formula <span class="token operator">+=</span> item_split    <span class="token keyword">return</span> final_formula        <span class="token keyword">def</span> <span class="token function">decision</span><span class="token punctuation">(</span>tail_op<span class="token punctuation">,</span> now_op<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''    :param tail_op: 运算符栈的最后一个运算符    :param now_op: 从算式列表取出的当前运算符    :return: 1 代表弹栈运算，0 代表弹运算符栈最后一个元素， -1 表示入栈    '''</span>     <span class="token comment"># 定义4种运算符级别</span>    rate1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">]</span>    rate2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'*'</span><span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">]</span>    rate3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'('</span><span class="token punctuation">]</span>    rate4 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">')'</span><span class="token punctuation">]</span>     <span class="token keyword">if</span> tail_op <span class="token keyword">in</span> rate1<span class="token punctuation">:</span>        <span class="token keyword">if</span> now_op <span class="token keyword">in</span> rate2 <span class="token keyword">or</span> now_op <span class="token keyword">in</span> rate3<span class="token punctuation">:</span>            <span class="token comment"># 说明连续两个运算优先级不一样，需要入栈</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>     <span class="token keyword">elif</span> tail_op <span class="token keyword">in</span> rate2<span class="token punctuation">:</span>        <span class="token keyword">if</span> now_op <span class="token keyword">in</span> rate3<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>     <span class="token keyword">elif</span> tail_op <span class="token keyword">in</span> rate3<span class="token punctuation">:</span>        <span class="token keyword">if</span> now_op <span class="token keyword">in</span> rate4<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>   <span class="token comment"># ( 遇上 ) 需要弹出 (，丢掉 )</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>  <span class="token comment"># 只要栈顶元素为(，当前元素不是)都应入栈。</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>                        <span class="token keyword">def</span> <span class="token function">final_calc</span><span class="token punctuation">(</span>formula_list<span class="token punctuation">)</span><span class="token punctuation">:</span>    num_stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>       <span class="token comment"># 数字栈</span>    op_stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 运算符栈</span>    <span class="token keyword">for</span> e <span class="token keyword">in</span> formula_list<span class="token punctuation">:</span>        operator <span class="token operator">=</span> is_operator<span class="token punctuation">(</span>e<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> operator<span class="token punctuation">:</span>            <span class="token comment"># 压入数字栈</span>            <span class="token comment"># 字符串转换为符点数</span>            num_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">float</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 如果是运算符</span>            <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>                <span class="token comment"># 如果运算符栈等于0无条件入栈</span>                <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>op_stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    op_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>e<span class="token punctuation">)</span>                    <span class="token keyword">break</span>                 <span class="token comment"># decision 函数做决策</span>                tag <span class="token operator">=</span> decision<span class="token punctuation">(</span>op_stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>                <span class="token keyword">if</span> tag <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token comment"># 如果是-1压入运算符栈进入下一次循环</span>                    op_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>e<span class="token punctuation">)</span>                    <span class="token keyword">break</span>                <span class="token keyword">elif</span> tag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token comment"># 如果是0弹出运算符栈内最后一个(, 丢掉当前)，进入下一次循环</span>                    op_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span>                <span class="token keyword">elif</span> tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token comment"># 如果是1弹出运算符栈内最后两个元素，弹出数字栈最后两位元素。</span>                    op <span class="token operator">=</span> op_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                    num2 <span class="token operator">=</span> num_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                    num1 <span class="token operator">=</span> num_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment"># 执行计算</span>                    <span class="token comment"># 计算之后压入数字栈</span>                    num_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>calculate<span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">,</span> op<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 处理大循环结束后 数字栈和运算符栈中可能还有元素 的情况</span>    <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>op_stack<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>        op <span class="token operator">=</span> op_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        num2 <span class="token operator">=</span> num_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        num1 <span class="token operator">=</span> num_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        num_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>calculate<span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">,</span> op<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> num_stack<span class="token punctuation">,</span> op_stack    <span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    formula <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入：\n'</span><span class="token punctuation">)</span>    <span class="token comment"># formula = "1 - 2 * ( (60-30 +(-40/5) * (9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14 )) - (-4*3)/ (16-3*2))"</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"算式："</span><span class="token punctuation">,</span> formula<span class="token punctuation">)</span>    formula_list <span class="token operator">=</span> formula_format<span class="token punctuation">(</span>formula<span class="token punctuation">)</span>    result<span class="token punctuation">,</span> _ <span class="token operator">=</span> final_calc<span class="token punctuation">(</span>formula_list<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"计算结果："</span><span class="token punctuation">,</span> result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三：数据直方图统计分析"><a href="#三：数据直方图统计分析" class="headerlink" title="三：数据直方图统计分析"></a>三：数据直方图统计分析</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#准备数据集</span>!mkdir <span class="token operator">/</span>home<span class="token operator">/</span>aistudio<span class="token operator">/</span>external<span class="token operator">-</span>libraries!pip install beautifulsoup4 <span class="token operator">-</span>t <span class="token operator">/</span>home<span class="token operator">/</span>aistudio<span class="token operator">/</span>external<span class="token operator">-</span>libraries灰度直方图概括了图像的灰度级信息，简单的来说就是每个灰度级图像中的像素个数以及占有率，创建直方图无外乎两个步骤，统计直方图数据，再用绘图库绘制直方图。统计直方图数据  首先要稍微理解一些与函数相关的术语，方便理解其在python3库中的应用和处理  BINS<span class="token punctuation">:</span> 在上面的直方图当中，如果像素值是<span class="token number">0</span>到<span class="token number">255</span>，则需要<span class="token number">256</span>个值来显示直 方图。但是，如果不需要知道每个像素值的像素数目，只想知道两个像素值之间的像素点数目怎么办？例如，想知道像素值在<span class="token number">0</span>到<span class="token number">15</span>之间的像素点数目，然后是<span class="token number">16</span>到<span class="token number">31</span>。。。<span class="token number">240</span>到<span class="token number">255</span>。可以将<span class="token number">256</span>个值分成<span class="token number">16</span>份，每份计算综合。每个分成的小组就是一个BIN（箱）。在opencv中使用histSize表示BINS。  DIMS<span class="token punctuation">:</span> 数据的参数数目。当前例子当中，对收集到的数据只考虑灰度值，所以该值为<span class="token number">1</span>。 RANGE<span class="token punctuation">:</span> 灰度值范围，通常是<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">]</span>，也就是灰度所有的取值范围。 统计直方图同样有两种方法，使用opencv统计直方图，函数如下：cv2<span class="token punctuation">.</span>calcHist<span class="token punctuation">(</span>images<span class="token punctuation">,</span> channels<span class="token punctuation">,</span> mask<span class="token punctuation">,</span> histSize<span class="token punctuation">,</span> ranges<span class="token punctuation">[</span><span class="token punctuation">,</span> hist<span class="token punctuation">[</span><span class="token punctuation">,</span> accumulate<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#利用hist直接绘制图像</span><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltimg <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'nezha.jpg'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token comment"># img_np = np.array(img) </span>plt<span class="token punctuation">.</span>hist<span class="token punctuation">(</span>img<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#这里因为像素点都是0~255，所以这里的bin选择是256</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>calcHist<span class="token punctuation">(</span><span class="token punctuation">[</span>images<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>channels<span class="token punctuation">]</span><span class="token punctuation">,</span> mask<span class="token punctuation">,</span> histSize<span class="token punctuation">,</span> ranges<span class="token punctuation">[</span><span class="token punctuation">,</span> hist<span class="token punctuation">[</span><span class="token punctuation">,</span> accumulate <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>imaes<span class="token punctuation">:</span>输入的图像channels<span class="token punctuation">:</span>选择图像的通道mask<span class="token punctuation">:</span>掩膜，是一个大小和image一样的np数组，其中把需要处理的部分指定为<span class="token number">1</span>，不需要处理的部分指定为<span class="token number">0</span>，一般设置为<span class="token boolean">None</span>，表示处理整幅图像histSize<span class="token punctuation">:</span>使用多少个<span class="token builtin">bin</span><span class="token punctuation">(</span>柱子<span class="token punctuation">)</span>，一般为<span class="token number">256</span>ranges<span class="token punctuation">:</span>像素值的范围，一般为<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">]</span>表示<span class="token number">0</span><span class="token operator">~</span><span class="token number">255</span>        <span class="token comment">#显示灰色通道，只有一个通道</span><span class="token keyword">import</span> cv2<span class="token comment"># import numpy as np</span><span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltimg <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'nezha.jpg'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>histr <span class="token operator">=</span> cv2<span class="token punctuation">.</span>calcHist<span class="token punctuation">(</span><span class="token punctuation">[</span>img<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token boolean">None</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">#hist是一个shape为(256,1)的数组，表示0-255每个像素值对应的像素个数，下标即为相应的像素值</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>histr<span class="token punctuation">,</span>color <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlim<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#显示三色通道，每一个通道展示像素点</span><span class="token keyword">import</span> cv2<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltimg <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'nezha.jpg'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> color <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'g'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>col <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">:</span>    histr <span class="token operator">=</span> cv2<span class="token punctuation">.</span>calcHist<span class="token punctuation">(</span><span class="token punctuation">[</span>img<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token boolean">None</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment">#hist是一个shape为(256,1)的数组，表示0-255每个像素值对应的像素个数，下标即为相应的像素值</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>histr<span class="token punctuation">,</span>color <span class="token operator">=</span> col<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlim<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">import</span> sys<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> cv2<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'nezha.jpg'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token comment">#得到计算灰度直方图的值</span>    n <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>img<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    xy<span class="token operator">=</span>xygray<span class="token punctuation">(</span>img<span class="token punctuation">)</span>       <span class="token comment">#画出灰度直方图</span>    x_range<span class="token operator">=</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x_range<span class="token punctuation">,</span>xy<span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment">#设置坐标轴的范围</span>    y_maxValue<span class="token operator">=</span>np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>xy<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>y_maxValue<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment">#设置坐标轴的标签</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'gray Level'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"number of pixels"</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">xygray</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#得到高和宽</span>    rows<span class="token punctuation">,</span>cols<span class="token operator">=</span>img<span class="token punctuation">.</span>shape    <span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token comment">#存储灰度直方图</span>    xy<span class="token operator">=</span>np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint64<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>xy<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">for</span> r <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>rows<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>cols<span class="token punctuation">)</span><span class="token punctuation">:</span>            xy<span class="token punctuation">[</span>img<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment">#返回一维ndarry</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>xy<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> xymain<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四：文本词频分析"><a href="#四：文本词频分析" class="headerlink" title="四：文本词频分析"></a>四：文本词频分析</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> jieba <span class="token comment"># jieba中文分词库</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'data/data131368/test.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'UTF-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> novelFile<span class="token punctuation">:</span>    novel <span class="token operator">=</span> novelFile<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># print(novel)</span>stopwords <span class="token operator">=</span> <span class="token punctuation">[</span>line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> line <span class="token keyword">in</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'data/data131368/stop.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'UTF-8'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>stopwords<span class="token punctuation">)</span>novelList <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>jieba<span class="token punctuation">.</span>lcut<span class="token punctuation">(</span>novel<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>novelList<span class="token punctuation">)</span>novelDict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment"># 统计出词频字典</span><span class="token keyword">for</span> word <span class="token keyword">in</span> novelList<span class="token punctuation">:</span>    <span class="token keyword">if</span> word <span class="token keyword">not</span> <span class="token keyword">in</span> stopwords<span class="token punctuation">:</span>            <span class="token comment"># 不统计字数为一的词</span>            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                novelDict<span class="token punctuation">[</span>word<span class="token punctuation">]</span> <span class="token operator">=</span> novelDict<span class="token punctuation">.</span>get<span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token comment"># 对词频进行排序</span>novelListSorted <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>novelDict<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>novelListSorted<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> e<span class="token punctuation">:</span> e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment">#另外的排序方式</span><span class="token comment">#ClassCount = sorted(classCount.items(),key=operator.itemgetter(1),reverse=True)</span><span class="token comment"># 打印前10词频</span>topWordNum <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> topWordTup <span class="token keyword">in</span> novelListSorted<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>topWordTup<span class="token punctuation">)</span><span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltx <span class="token operator">=</span> <span class="token punctuation">[</span>c <span class="token keyword">for</span> c<span class="token punctuation">,</span>v <span class="token keyword">in</span> novelListSorted<span class="token punctuation">]</span>y <span class="token operator">=</span> <span class="token punctuation">[</span>v <span class="token keyword">for</span> c<span class="token punctuation">,</span>v <span class="token keyword">in</span> novelListSorted<span class="token punctuation">]</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span>y<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">from</span> wordcloud <span class="token keyword">import</span> WordCloud<span class="token punctuation">,</span>ImageColorGenerator<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">from</span> imageio <span class="token keyword">import</span> imread<span class="token comment">#读入背景图片</span><span class="token keyword">from</span> main <span class="token keyword">import</span> novelDictbg_pic <span class="token operator">=</span> imread<span class="token punctuation">(</span><span class="token string">'父亲.jpg'</span><span class="token punctuation">)</span><span class="token comment">#生成词云图片</span>wordcloud <span class="token operator">=</span> WordCloud<span class="token punctuation">(</span>mask<span class="token operator">=</span>bg_pic<span class="token punctuation">,</span>background_color<span class="token operator">=</span><span class="token string">'black'</span><span class="token punctuation">,</span>\    scale<span class="token operator">=</span><span class="token number">1.5</span><span class="token punctuation">,</span>font_path<span class="token operator">=</span><span class="token string">r'data\msyh.ttc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>generate<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>novelDict<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>wordcloud<span class="token punctuation">)</span>   <span class="token comment">#显示生成的词云图</span>plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token string">'off'</span><span class="token punctuation">)</span>         <span class="token comment">#关闭坐标轴显示</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#保存图片</span>wordcloud<span class="token punctuation">.</span>to_file<span class="token punctuation">(</span><span class="token string">'父亲2.jpg'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="五：图片爬取"><a href="#五：图片爬取" class="headerlink" title="五：图片爬取"></a>五：图片爬取</h3><h4 id="refer和url不冲突吗"><a href="#refer和url不冲突吗" class="headerlink" title="refer和url不冲突吗"></a>refer和url不冲突吗</h4><pre class="line-numbers language-none"><code class="language-none">在HTTP请求中，Referer（引用页）是指当前请求的来源页面的URL。当你在浏览器中点击链接或提交表单时，浏览器会发送HTTP请求，并在请求头中包含Referer字段，指示该请求是从哪个页面链接过来的。在给定的代码中，`self.headers_image`中的Referer字段用于指定请求的来源页面，即告诉服务器该请求是从百度图片搜索页面链接过来的。这可以用于一些网站的访问控制或统计分析。在下载图片的部分，`f.write(requests.get(url, headers=self.headers_image).content)`中的headers参数被用来传递请求头信息，其中包括Referer字段。这样做是为了模拟浏览器行为，使服务器认为请求是从百度图片搜索页面来的，以提高请求的成功率。虽然URL已经包含了目标图片的地址，但有些网站可能会检查Referer字段以防止直接链接到图片资源。因此，在下载图片时使用正确的Referer可以增加请求的成功率。需要注意的是，不是所有网站都对Referer进行验证，有些网站可能会忽略或不使用Referer字段。因此，根据实际情况，你可以选择在请求中包含或省略Referer字段。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import requestsimport osimport urllibclass GetImage():    def __init__(self,keyword='大雁',paginator=1):        # self.url: 链接头        self.url = 'http://image.baidu.com/search/acjson?'  #百度图片网站        self.headers = {            'User-Agent': 'Mozilla/5.0 (Windows NT\             10.0; Win64) AppleWebKit/537.36\              (KHTML, like Gecko) Chrome/69.0.\            3497.81 Safari/537.36'}        self.headers_image = {            'User-Agent': 'Mozilla/5.0 (Windows\             NT 10.0; WOW64) AppleWebKit/537.36 \             (KHTML, like Gecko) Chrome/69.0.\            3497.81 Safari/537.36',            'Referer': 'http://image.baidu.com/\            search/index?tn=baiduimage&amp;ipn=r&amp;\            ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;\            fm=result&amp;fr=&amp;sf=1&amp;fmq=1557124645631_R&amp;\            pv=&amp;ic=&amp;nc=1&amp;z=&amp;hd=1&amp;latest=0&amp;copyright\            =0&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=\            &amp;face=0&amp;istype=2&amp;ie=utf-8&amp;sid=&amp;word=%\            E8%83%A1%E6%AD%8C'}        self.keyword = keyword      # 定义关键词        self.paginator = paginator  # 定义要爬取的页数    def get_param(self):        # 将中文关键词转换为符合规则的编码        keyword = urllib.parse.quote(self.keyword)        params = []        # 为爬取的每页链接定制参数        for i in range(1, self.paginator + 1):            params.append(                'tn=resultjson_com&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;\                fp=result&amp;queryWord={}&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;o\                e=utf-8&amp;adpicid=&amp;st=-1&amp;z=&amp;ic=&amp;hd=1&amp;latest=0&amp;\                copyright=0&amp;word={}&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height\                =&amp;face=0&amp;istype=2&amp;qc=&amp;nc=1&amp;fr=&amp;expermode=&amp;for\                ce=&amp;cg=star&amp;pn={}&amp;rn=30&amp;gsm=78&amp;1557125391211\                ='.format(keyword, keyword, 30 * i))        return params   # 返回链接参数    def get_urls(self, params):        urls = []        for param in params:            # 拼接每页的链接            urls.append(self.url + param)        return urls   # 返回每页链接    def get_image_url(self, urls):        image_url = []        print(len(urls))        for url in urls:            json_data = requests.get(url, headers=self.headers).json()            print(json_data)            json_data = json_data.get('data')            print(json_data)            for i in json_data:                if i:                    image_url.append(i.get('thumbURL'))        return image_url    def get_image(self, image_url):        """        根据图片url，在本地目录下新建一个以搜索关键字命名的文件夹，然后将每一个图片存入。        :param image_url:        :return:        """        cwd = os.getcwd()        file_name = os.path.join(cwd, self.keyword)        if not os.path.exists(self.keyword):            os.mkdir(file_name)        for index, url in enumerate(image_url, start=1):            print(f"下载的url是{url}")            with open(file_name+'/{}_0.jpg'.format(index), 'wb') as f:                f.write(requests.get(url, headers=self.headers_image).content)            if index != 0 and index % 30 == 0:                print('第{}页下载完成'.format(index/30))    def __call__(self, *args, **kwargs):        params = self.get_param()  # 获取链接参数        urls = self.get_urls(params)        image_url = self.get_image_url(urls)        print(len(image_url))        self.get_image(image_url)if __name__ == '__main__':    spider = GetImage('明星图片', 3)    spider()# spider = GetImage('雕', 3)    # spider()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="六：股票行情爬取与分析"><a href="#六：股票行情爬取与分析" class="headerlink" title="六：股票行情爬取与分析"></a>六：股票行情爬取与分析</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">!pip install fake_useragent!pip install bs4!cp <span class="token operator">/</span>home<span class="token operator">/</span>aistudio<span class="token operator">/</span>simhei<span class="token punctuation">.</span>ttf <span class="token operator">/</span>opt<span class="token operator">/</span>conda<span class="token operator">/</span>envs<span class="token operator">/</span>python35<span class="token operator">-</span>paddle120<span class="token operator">-</span>env<span class="token operator">/</span>lib<span class="token operator">/</span>python3<span class="token punctuation">.</span><span class="token number">7</span><span class="token operator">/</span>site<span class="token operator">-</span>packages<span class="token operator">/</span>matplotlib<span class="token operator">/</span>mpl<span class="token operator">-</span>data<span class="token operator">/</span>fonts<span class="token operator">/</span>ttf<span class="token operator">/</span>!cp  <span class="token operator">/</span>home<span class="token operator">/</span>aistudio<span class="token operator">/</span>simhei<span class="token punctuation">.</span>ttf  <span class="token punctuation">.</span>fonts<span class="token operator">/</span>!rm <span class="token operator">-</span>rf <span class="token punctuation">.</span>cache<span class="token operator">/</span>matplotlib<span class="token comment">#coding=utf-8</span><span class="token triple-quoted-string string">'''Created on 2021年02月20日@author: zhongshan'''</span><span class="token comment">#http://quote.eastmoney.com/center/gridlist.html</span><span class="token comment">#爬取该页面股票信息</span><span class="token keyword">import</span> requests<span class="token keyword">from</span> fake_useragent <span class="token keyword">import</span> UserAgent<span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoup <span class="token keyword">import</span> json<span class="token keyword">import</span> csv <span class="token keyword">def</span> <span class="token function">getHtml</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers<span class="token operator">=</span><span class="token punctuation">{</span>        <span class="token string">'User-Agent'</span><span class="token punctuation">:</span> UserAgent<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>random<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>encoding <span class="token operator">=</span> r<span class="token punctuation">.</span>apparent_encoding    <span class="token keyword">return</span> r<span class="token punctuation">.</span>text<span class="token comment">#num为爬取多少条记录，可手动设置</span>num <span class="token operator">=</span> <span class="token number">20</span><span class="token comment">#该地址为页面实际获取数据的接口地址</span>stockUrl<span class="token operator">=</span><span class="token string">'http://99.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112408733409809437476_1623137764048&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;fid=f3&amp;fs=m:0+t:80&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f22,f11,f62,f128,f136,f115,f152&amp;_=1623137764167:formatted'</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>responseText <span class="token operator">=</span> getHtml<span class="token punctuation">(</span>stockUrl<span class="token punctuation">)</span>jsonText <span class="token operator">=</span> responseText<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>resJson <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>jsonText<span class="token punctuation">)</span>datas <span class="token operator">=</span> resJson<span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"diff"</span><span class="token punctuation">]</span> datalist <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> data <span class="token keyword">in</span> datas<span class="token punctuation">:</span><span class="token comment"># if (str().startswith('6') or str(data["f12"]).startswith('3') or str(data["f12"]).startswith('0')):</span>row <span class="token operator">=</span> <span class="token punctuation">[</span>data<span class="token punctuation">[</span><span class="token string">"f12"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>data<span class="token punctuation">[</span><span class="token string">"f14"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>datalist<span class="token punctuation">.</span>append<span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>datalist<span class="token punctuation">)</span>f <span class="token operator">=</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'stock.csv'</span><span class="token punctuation">,</span><span class="token string">'w+'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span>newline<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>writer <span class="token operator">=</span> csv<span class="token punctuation">.</span>writer<span class="token punctuation">(</span>f<span class="token punctuation">)</span>writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'代码'</span><span class="token punctuation">,</span> <span class="token string">'名称'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> data <span class="token keyword">in</span> datalist<span class="token punctuation">:</span>writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token punctuation">,</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="七：科比职业生涯数据爬取与分析"><a href="#七：科比职业生涯数据爬取与分析" class="headerlink" title="七：科比职业生涯数据爬取与分析"></a>七：科比职业生涯数据爬取与分析</h3><pre class="line-numbers language-none"><code class="language-none"># coding=utf-8'''Created on 2021年02月20日@author: zhongshan'''import requestsfrom bs4 import BeautifulSoupimport csvimport matplotlib.pyplot as pltimport pandas as pd# 设置显示中文plt.rcParams['font.sans-serif'] = ['simhei'] # 指定默认字体# plt.rcParams['font.sans-serif']=['Fangsong'] # 用来显示中文标签plt.rcParams['axes.unicode_minus']=False # 用来显示负号plt.rcParams['figure.dpi'] = 100 # 每英寸点数def getKobeList(code):url = "http://www.stat-nba.com/player/stat_box/195_" + code + ".html"response = requests.get(url)resKobe = response.textreturn resKobe# 获取kobe历史数据def getRow(resKobe, code):soup = BeautifulSoup(resKobe, "html.parser")table = soup.find_all(id='stat_box_avg')# 表头header = []if code == "season":header = ["赛季", "出场", "首发", "时间", "投篮", "命中", "出手", "三分", "命中", "出手", "罚球", "命中",  "出手", "篮板", "前场", "后场", "助攻", "抢断", "盖帽", "失误", "犯规", "得分", "胜", "负"]if code == "playoff":header = ["赛季", "出场", "时间", "投篮", "命中", "出手", "三分", "命中", "出手", "罚球", "命中", "出手",  "篮板", "前场", "后场", "助攻", "抢断", "盖帽", "失误", "犯规", "得分", "胜", "负"]if code == "allstar":header = ["赛季", "首发", "时间", "投篮", "命中", "出手", "三分", "命中", "出手", "罚球", "命中", "出手",  "篮板", "前场", "后场", "助攻", "抢断", "盖帽", "失误", "犯规", "得分"]# 数据rows = [];rows.append(header)for tr in table[0].find_all("tr", class_="sort"):row = []for td in tr.find_all("td"):rank = td.get("rank")if rank != "LAL" and rank != None:row.append(td.get_text())rows.append(row)return rows# 写入csv文件,rows为数据，dir为写入文件路径def writeCsv(rows, dir):with open(dir, 'w', encoding='utf-8-sig', newline='') as f:writer = csv.writer(f)writer.writerows(rows)# 常规赛数据resKobe = getKobeList("season")rows = getRow(resKobe, "season")# print(rows)writeCsv(rows, "season.csv")print("season.csv saved")# 季后赛数据resKobe = getKobeList("playoff")rows = getRow(resKobe, "playoff")# print(rows)writeCsv(rows, "playoff.csv")print("playoff.csv saved")# 全明星数据resKobe = getKobeList("allstar")rows = getRow(resKobe, "allstar")# print(rows)writeCsv(rows, "star.csv")print("star.csv saved")# 篮板、助攻、得分def show_score(game_name='season', item='篮板', plot_name='line'):# game_name: season, playoff, star# item: 篮板，助攻，得分# plot_name: line,barfile_name = game_name + '.csv'data = pd.read_csv(file_name)X = data['赛季'].values.tolist()X.reverse()if item == 'all':Y1 = data['篮板'].values.tolist()Y2 = data['助攻'].values.tolist()Y3 = data['得分'].values.tolist()Y1.reverse()Y2.reverse()Y3.reverse()else:Y = data[item].values.tolist()Y.reverse()if plot_name == 'line':if item == 'all':plt.plot(X, Y1, c='r', linestyle="-.")plt.plot(X, Y2, c='g', linestyle="--")plt.plot(X, Y3, c='b', linestyle="-")legend = ['篮板', '助攻', '得分']else:plt.plot(X, Y, c='g', linestyle="-")legend = [item]elif plot_name == 'bar':# facecolor:表面的颜色;edgecolor:边框的颜色if item == 'all':fig = plt.figure(figsize=(15, 5))ax1 = plt.subplot(131)plt.bar(X, Y1, facecolor='#9999ff', edgecolor='white')plt.legend(['篮板'])plt.title('Kobe职业生涯数据分析：' + game_name)plt.xticks(rotation=60)plt.ylabel('篮板')ax2 = plt.subplot(132)plt.bar(X, Y2, facecolor='#999900', edgecolor='white')plt.legend(['助攻'])plt.title('Kobe职业生涯数据分析：' + game_name)plt.xticks(rotation=60)plt.ylabel('助攻')ax3 = plt.subplot(133)plt.bar(X, Y3, facecolor='#9988ff', edgecolor='white')legend = ['得分']else:plt.bar(X, Y, facecolor='#9900ff', edgecolor='white')legend = [item]else:returnplt.legend(legend)plt.title('Kobe职业生涯数据分析：' + game_name)plt.xticks(rotation=60)plt.xlabel('赛季')if item != 'all':plt.ylabel(item)else:plt.ylabel('得分')plt.savefig('Kobe职业生涯数据分析_{}_{}.png'.format(game_name, item))plt.show()# 篮板、助攻、得分game_name = 'season'for game_name in ['season', 'playoff', 'star']:show_score(game_name=game_name, item='篮板', plot_name='bar')show_score(game_name=game_name, item='助攻', plot_name='bar')show_score(game_name=game_name, item='得分', plot_name='bar')show_score(game_name=game_name, item='篮板', plot_name='line')show_score(game_name=game_name, item='助攻', plot_name='line')show_score(game_name=game_name, item='得分', plot_name='line')show_score(game_name=game_name, item='all', plot_name='bar')show_score(game_name=game_name, item='all', plot_name='line')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="八：基于线性回归实现房价预测"><a href="#八：基于线性回归实现房价预测" class="headerlink" title="八：基于线性回归实现房价预测"></a>八：基于线性回归实现房价预测</h3><p>经典的线性回归模型主要用来预测一些存在着线性关系的数据集。回归模型可以理解为：存在一个点集，用一条曲线去拟合它分布的过程。如果拟合曲线是一条直线，则称为线性回归。如果是一条二次曲线，则被称为二次回归。线性回归是回归模型中最简单的一种。 本教程使用PaddlePaddle建立起一个房价预测模型。</p><p>在线性回归中：</p><p>（1）假设函数是指，用数学的方法描述自变量和因变量之间的关系，它们之间可以是一个线性函数或非线性函数。 在本次线性回顾模型中，我们的假设函数为 Y’= wX+b ，其中，Y’表示模型的预测结果（预测房价），用来和真实的Y区分。模型要学习的参数即：w,b。</p><p>（2）损失函数是指，用数学的方法衡量假设函数预测结果与真实值之间的误差。这个差距越小预测越准确，而算法的任务就是使这个差距越来越小。 建立模型后，我们需要给模型一个优化目标，使得学到的参数能够让预测值Y’尽可能地接近真实值Y。这个实值通常用来反映模型误差的大小。不同问题场景下采用不同的损失函数。 对于线性模型来讲，最常用的损失函数就是均方误差（Mean Squared Error， MSE）。</p><p>（3）优化算法：神经网络的训练就是调整权重（参数）使得损失函数值尽可能得小，在训练过程中，将损失函数值逐渐收敛，得到一组使得神经网络拟合真实模型的权重（参数）。所以，优化算法的最终目标是找到损失函数的最小值。而这个寻找过程就是不断地微调变量w和b的值，一步一步地试出这个最小值。 常见的优化算法有随机梯度下降法（SGD）、Adam算法等等</p><pre class="line-numbers language-none"><code class="language-none">import paddleimport numpy as npimport osimport matplotlib.pyplot as plt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-准备数据"><a href="#1-准备数据" class="headerlink" title="1.准备数据"></a>1.准备数据</h4><p>（1）uci-housing数据集介绍</p><p>数据集共506行,每行14列。前13列用来描述房屋的各种信息，最后一列为该类房屋价格中位数。</p><p>(2)train_reader和test_reader(这个没看到懂)</p><p>paddle.reader.shuffle()表示每次缓存BUF_SIZE个数据项，并进行打乱</p><p>paddle.batch()表示每BATCH_SIZE组成一个batch</p><pre class="line-numbers language-none"><code class="language-none"># BUF_SIZE=500# BATCH_SIZE=20# #用于训练的数据提供器，每次从缓存中随机读取批次大小的数据# train_reader = paddle.batch(#     paddle.reader.shuffle(paddle.dataset.uci_housing.train(), #                           buf_size=BUF_SIZE),                    #     batch_size=BATCH_SIZE)   # #用于测试的数据提供器，每次从缓存中随机读取批次大小的数据# test_reader = paddle.batch(#     paddle.reader.shuffle(paddle.dataset.uci_housing.test(),#                           buf_size=BUF_SIZE),#     batch_size=BATCH_SIZE) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加载数据</p><pre class="line-numbers language-none"><code class="language-none">#设置默认的全局dtype为float64paddle.set_default_dtype("float64")#下载数据print('下载并加载训练数据')train_dataset = paddle.text.datasets.UCIHousing(mode='train')eval_dataset = paddle.text.datasets.UCIHousing(mode='test')print(len(eval_dataset))train_loader = paddle.io.DataLoader(train_dataset, batch_size=32, shuffle=True)eval_loader = paddle.io.DataLoader(eval_dataset, batch_size = 8, shuffle=False)print('加载完成')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-网络配置"><a href="#2-网络配置" class="headerlink" title="2.网络配置"></a>2.网络配置</h4><p>对于线性回归来讲，它就是一个从输入到输出的简单的全连接层。</p><p>对于波士顿房价数据集，假设属性和房价之间的关系可以被属性间的线性组合描述。</p><p><img src="C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20230827091240945.png" alt="image-20230827091240945"></p><pre class="line-numbers language-none"><code class="language-none"># 定义全连接网络class Regressor(paddle.nn.Layer):    def __init__(self):        super(Regressor, self).__init__()        # 定义一层全连接层，输出维度是1，激活函数为None，即不使用激活函数        self.linear = paddle.nn.Linear(13, 1, None)        # 网络的前向计算函数    def forward(self, inputs):        x = self.linear(inputs)        return x                                        Batch=0Batchs=[]all_train_accs=[]def draw_train_acc(Batchs, train_accs):    title="training accs"    plt.title(title, fontsize=24)    plt.xlabel("batch", fontsize=14)    plt.ylabel("acc", fontsize=14)    plt.plot(Batchs, train_accs, color='green', label='training accs')    plt.legend()    plt.grid()    plt.show()all_train_loss=[]def draw_train_loss(Batchs, train_loss):    title="training loss"    plt.title(title, fontsize=24)    plt.xlabel("batch", fontsize=14)    plt.ylabel("loss", fontsize=14)    plt.plot(Batchs, train_loss, color='red', label='training loss')    plt.legend()    plt.grid()    plt.show()                    model=Regressor() # 模型实例化model.train() # 训练模式mse_loss = paddle.nn.MSELoss()opt=paddle.optimizer.SGD(learning_rate=0.0005, parameters=model.parameters())epochs_num=200 #迭代次数for pass_num in range(epochs_num):    for batch_id,data in enumerate(train_loader()):        image = data[0]        label = data[1]        predict=model(image) #数据传入model        # print(predict)        # print(np.argmax(predict,axis=1))        loss=mse_loss(predict,label)        # acc=paddle.metric.accuracy(predict,label.reshape([-1,1]))#计算精度        # acc = np.mean(label==np.argmax(predict,axis=1))                if batch_id!=0 and batch_id%10==0:            Batch = Batch+10            Batchs.append(Batch)            all_train_loss.append(loss.numpy()[0])            # all_train_accs.append(acc.numpy()[0])             print("epoch:{},step:{},train_loss:{}".format(pass_num,batch_id,loss.numpy()[0])  )              loss.backward()               opt.step()        opt.clear_grad()   #opt.clear_grad()来重置梯度paddle.save(model.state_dict(),'Regressor')#保存模型draw_train_loss(Batchs,all_train_loss)#模型评估para_state_dict = paddle.load("Regressor") model = Regressor()model.set_state_dict(para_state_dict) #加载模型参数model.eval() #验证模式losses = []infer_results=[]groud_truths=[]for batch_id,data in enumerate(eval_loader()):#测试集    image=data[0]    label=data[1]     groud_truths.extend(label.numpy())        predict=model(image)     infer_results.extend(predict.numpy())          loss=mse_loss(predict,label)    losses.append(loss.numpy()[0])    avg_loss = np.mean(losses)print("当前模型在验证集上的损失值为:",avg_loss)#绘制真实值和预测值对比图def draw_infer_result(groud_truths,infer_results):    title='Boston'    plt.title(title, fontsize=24)    x = np.arange(1,20)     y = x    plt.plot(x, y)    plt.xlabel('ground truth', fontsize=14)    plt.ylabel('infer result', fontsize=14)    plt.scatter(groud_truths, infer_results,color='green',label='training cost')     plt.grid()    plt.show()draw_infer_result(groud_truths,infer_results)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="九：使用k-means算法实现鸢尾花聚类"><a href="#九：使用k-means算法实现鸢尾花聚类" class="headerlink" title="九：使用k-means算法实现鸢尾花聚类"></a>九：使用k-means算法实现鸢尾花聚类</h3><p>对于给定的样本集，按照样本之间的距离大小，将样本集划分为K个簇，让簇内的点尽量紧密的连在一起，而让簇间的距离尽量的大</p><h4 id="1-利用包完成"><a href="#1-利用包完成" class="headerlink" title="1.利用包完成"></a>1.利用包完成</h4><h5 id="鸢尾花数据集描述"><a href="#鸢尾花数据集描述" class="headerlink" title="鸢尾花数据集描述"></a>鸢尾花数据集描述</h5><p>包含3种类型数据集，共150条数据 ；2、包含4项特征：花萼长度、花萼宽度、花瓣长度、花瓣宽度</p><h5 id="导入相关包"><a href="#导入相关包" class="headerlink" title="导入相关包"></a>导入相关包</h5><pre class="line-numbers language-none"><code class="language-none">import matplotlib.pyplot as pltimport numpy as npfrom sklearn.cluster import KMeans from sklearn import datasets <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="直接从sklearn-datasets中加载数据集"><a href="#直接从sklearn-datasets中加载数据集" class="headerlink" title="直接从sklearn.datasets中加载数据集"></a>直接从sklearn.datasets中加载数据集</h5><pre class="line-numbers language-none"><code class="language-none"># 直接从sklearn中获取数据集iris = datasets.load_iris()X = iris.data[:, :4]    # 表示我们取特征空间中的4个维度print(X.shape)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="绘制二维数据分布图"><a href="#绘制二维数据分布图" class="headerlink" title="绘制二维数据分布图"></a>绘制二维数据分布图</h5><pre class="line-numbers language-none"><code class="language-none"># 取前两个维度（萼片长度、萼片宽度），绘制数据分布图plt.scatter(X[:, 0], X[:, 1], c="red", marker='o', label='see')plt.xlabel('sepal length')plt.ylabel('sepal width')plt.legend(loc=2)plt.show() <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="实例化K-means，定义训练函数"><a href="#实例化K-means，定义训练函数" class="headerlink" title="实例化K-means，定义训练函数"></a>实例化K-means，定义训练函数</h5><pre class="line-numbers language-none"><code class="language-none">def Model(n_clusters):    estimator = KMeans(n_clusters=n_clusters)# 构造聚类器    return estimatordef train(estimator):    estimator.fit(X)  # 聚类        # 初始化实例，并开启训练拟合estimator=Model(3)     train(estimator) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="可视化展示"><a href="#可视化展示" class="headerlink" title="可视化展示"></a>可视化展示</h5><pre class="line-numbers language-none"><code class="language-none">label_pred = estimator.labels_  # 获取聚类标签# 绘制k-means结果x0 = X[label_pred == 0]x1 = X[label_pred == 1]x2 = X[label_pred == 2]plt.scatter(x0[:, 0], x0[:, 1], c="red", marker='o', label='label0')plt.scatter(x1[:, 0], x1[:, 1], c="green", marker='*', label='label1')plt.scatter(x2[:, 0], x2[:, 1], c="blue", marker='+', label='label2')plt.xlabel('sepal length')plt.ylabel('sepal width')plt.legend(loc=2)plt.show() <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="手写完成"><a href="#手写完成" class="headerlink" title="手写完成"></a>手写完成</h4><pre class="line-numbers language-none"><code class="language-none"># 法一：直接手写实现# 欧氏距离计算def distEclud(x,y):    return np.sqrt(np.sum((x-y)**2))  # 计算欧氏距离 # 为给定数据集构建一个包含K个随机质心centroids的集合def randCent(dataSet,k):    m,n = dataSet.shape #m=150,n=4    centroids = np.zeros((k,n)) #4*4    for i in range(k): # 执行四次        index = int(np.random.uniform(0,m)) # 产生0到150的随机数（在数据集中随机挑一个向量做为质心的初值）        centroids[i,:] = dataSet[index,:] #把对应行的四个维度传给质心的集合    return centroids # k均值聚类算法def KMeans(dataSet,k):    m = np.shape(dataSet)[0]  #行数150    # 第一列存每个样本属于哪一簇(四个簇)    # 第二列存每个样本的到簇的中心点的误差    clusterAssment = np.mat(np.zeros((m,2)))# .mat()创建150*2的矩阵    clusterChange = True     # 1.初始化质心centroids    centroids = randCent(dataSet,k)#4*4    while clusterChange:        # 样本所属簇不再更新时停止迭代        clusterChange = False         # 遍历所有的样本（行数150）        for i in range(m):            minDist = 100000.0            minIndex = -1             # 遍历所有的质心            #2.找出最近的质心            for j in range(k):                # 计算该样本到4个质心的欧式距离，找到距离最近的那个质心minIndex                distance = distEclud(centroids[j,:],dataSet[i,:])                if distance &lt; minDist:                    minDist = distance                    minIndex = j            # 3.更新该行样本所属的簇            if clusterAssment[i,0] != minIndex:                clusterChange = True                clusterAssment[i,:] = minIndex,minDist**2        #4.更新质心        for j in range(k):            # np.nonzero(x)返回值不为零的元素的下标，它的返回值是一个长度为x.ndim(x的轴数)的元组            # 元组的每个元素都是一个整数数组，其值为非零元素的下标在对应轴上的值。            # 矩阵名.A 代表将 矩阵转化为array数组类型                        # 这里取矩阵clusterAssment所有行的第一列，转为一个array数组，与j（簇类标签值）比较，返回true or false            # 通过np.nonzero产生一个array，其中是对应簇类所有的点的下标值（x个）            # 再用这些下标值求出dataSet数据集中的对应行，保存为pointsInCluster（x*4）            pointsInCluster = dataSet[np.nonzero(clusterAssment[:,0].A == j)[0]]  # 获取对应簇类所有的点（x*4）            centroids[j,:] = np.mean(pointsInCluster,axis=0)   # 求均值，产生新的质心            # axis=0，那么输出是1行4列，求的是pointsInCluster每一列的平均值，即axis是几，那就表明哪一维度被压缩成1     print("cluster complete")    return centroids,clusterAssmentdef draw(data,center,assment):    length=len(center)    fig=plt.figure    data1=data[np.nonzero(assment[:,0].A == 0)[0]]    data2=data[np.nonzero(assment[:,0].A == 1)[0]]    data3=data[np.nonzero(assment[:,0].A == 2)[0]]    # 选取前两个维度绘制原始数据的散点图    plt.scatter(data1[:,0],data1[:,1],c="red",marker='o',label='label0')    plt.scatter(data2[:,0],data2[:,1],c="green", marker='*', label='label1')    plt.scatter(data3[:,0],data3[:,1],c="blue", marker='+', label='label2')    # 绘制簇的质心点    for i in range(length):        plt.annotate('center',xy=(center[i,0],center[i,1]),xytext=\        (center[i,0]+1,center[i,1]+1),arrowprops=dict(facecolor='yellow'))        #  plt.annotate('center',xy=(center[i,0],center[i,1]),xytext=\        # (center[i,0]+1,center[i,1]+1),arrowprops=dict(facecolor='red'))    plt.show()        # 选取后两个维度绘制原始数据的散点图    plt.scatter(data1[:,2],data1[:,3],c="red",marker='o',label='label0')    plt.scatter(data2[:,2],data2[:,3],c="green", marker='*', label='label1')    plt.scatter(data3[:,2],data3[:,3],c="blue", marker='+', label='label2')    # 绘制簇的质心点    for i in range(length):        plt.annotate('center',xy=(center[i,2],center[i,3]),xytext=\        (center[i,2]+1,center[i,3]+1),arrowprops=dict(facecolor='yellow'))    plt.show()        dataSet = Xk = 3centroids,clusterAssment = KMeans(dataSet,k)draw(dataSet,centroids,clusterAssment)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="十：基于逻辑回归模型实现手写数字识别"><a href="#十：基于逻辑回归模型实现手写数字识别" class="headerlink" title="十：基于逻辑回归模型实现手写数字识别"></a>十：基于逻辑回归模型实现手写数字识别</h3><p>sklearn是Python的一个机器学习的库，它有比较完整的监督学习与非监督学习的模型。本文将使用sklearn库里的分类模型来对手写数字（MNIST）做分类实践。</p><h4 id="1-数据介绍"><a href="#1-数据介绍" class="headerlink" title="1.数据介绍"></a>1.数据介绍</h4><blockquote><p>MNIST 数据集来自美国国家标准与技术研究所, National Institute of Standards and Technology (NIST). 训练集 (training set) 由来自 250 个不同人手写的数字构成, 其中 50% 是高中学生, 50% 来自人口普查局 (the Census Bureau) 的工作人员. 测试集(test set) 也是同样比例的手写数字数据.<br>MNIST 数据集可在 <a href="http://yann.lecun.com/exdb/mnist/">http://yann.lecun.com/exdb/mnist/</a> 获取, 它包含了四个部分:</p></blockquote><ul><li>Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本)</li><li>Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签)</li><li>Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本)</li><li>Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签)</li></ul><h4 id="2-数据读取与存储形式"><a href="#2-数据读取与存储形式" class="headerlink" title="2.数据读取与存储形式"></a>2.数据读取与存储形式</h4><p>将下载好的数据解压带代码目录下即可。 <strong>此处直接挂在数据集</strong>，数据文件时二进制格式的，所以要按字节读取。代码如下：</p><pre class="line-numbers language-none"><code class="language-none">!unzip data/data7869/mnist.zip #解压文件!gzip -dfq mnist/train-labels-idx1-ubyte.gz!gzip -dfq mnist/t10k-labels-idx1-ubyte.gz!gzip -dfq mnist/train-images-idx3-ubyte.gz!gzip -dfq mnist/t10k-images-idx3-ubyte.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import struct,os#struct 模块用于处理二进制数据的解析和打包，而 os 模块提供了与操作系统交互的功能。import numpy as np#array 函数用于创建和操作基本的数组对象。from array import array as pyarrayfrom numpy import append, array, int8, uint8, zeros#append 函数用于在数组末尾添加元素，array 函数用于创建数组对象，int8 和 uint8 是整数类型，分别表示有符号和无符号的 8 位整数，zeros 函数用于创建一个全零的数组。import matplotlib.pyplot as plt%matplotlib inline #这个魔术命令（magic command）是 Jupyter Notebook 或 JupyterLab 的特殊命令，用于在 Notebook 中内联显示 matplotlib 绘图，并在代码块执行后自动显示图形。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">def load_mnist(image_file, label_file, path="data/mnist"):    digits=np.arange(10)    fname_image = os.path.join(path, image_file)    fname_label = os.path.join(path, label_file)    flbl = open(fname_label, 'rb')    magic_nr, size = struct.unpack("&gt;II", flbl.read(8))    lbl = pyarray("b", flbl.read())    flbl.close()    fimg = open(fname_image, 'rb')    magic_nr, size, rows, cols = struct.unpack("&gt;IIII", fimg.read(16))    img = pyarray("B", fimg.read())    fimg.close()    ind = [ k for k in range(size) if lbl[k] in digits ]    N = len(ind)    images = zeros((N, rows*cols), dtype=uint8)    labels = zeros((N, 1), dtype=int8)    for i in range(len(ind)):        images[i] = array(img[ ind[i]*rows*cols : (ind[i]+1)*rows*cols ]).reshape((1, rows*cols))        labels[i] = lbl[ind[i]]    return images, labelstrain_image, train_label = load_mnist("train-images-idx3-ubyte", "train-labels-idx1-ubyte")test_image, test_label = load_mnist("t10k-images-idx3-ubyte", "t10k-labels-idx1-ubyte")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-数据展示"><a href="#3-数据展示" class="headerlink" title="3.数据展示"></a>3.数据展示</h4><p>image和label都是数组，image内的每个元素为一个784维的向量，label内的每个元素为image同下标下元素表示的数字。<br>可以将读取到的灰度图通过matplotlib.pyplot展示出来：</p><pre class="line-numbers language-none"><code class="language-none">import matplotlib.pyplot as pltdef show_image(imgdata,imgtarget,show_column, show_row):    #注意这里的show_column*show_row==len(imgdata)    for index,(im,it) in enumerate(list(zip(imgdata,imgtarget))):        xx = im.reshape(28,28)        plt.subplots_adjust(left=1, bottom=None, right=3, top=2, wspace=None, hspace=None)        plt.subplot(show_row, show_column, index+1)        plt.axis('off')        plt.imshow(xx , cmap='gray',interpolation='nearest')        plt.title('label:%i' % it)# 显示训练集前50数字show_image(train_image[:50], train_label[:50], 10,5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230902171038869.png" alt="image-20230902171038869"></p><h4 id="4-sklearn分类模型"><a href="#4-sklearn分类模型" class="headerlink" title="4.sklearn分类模型"></a>4.sklearn分类模型</h4><p>本文使用的sklearn分类模型有：</p><ul><li>K-Nearest Neighbor Classification</li><li>Naive Bayes</li><li>Decision Tree</li><li>Random Forest</li><li>Logistic Regression</li><li>Support Vector Machine</li></ul><h4 id="5-数据归一化"><a href="#5-数据归一化" class="headerlink" title="5.数据归一化"></a>5.数据归一化</h4><p>此处采用min-max标准化将数据进行归一化操作。 <code>image = [im/255.0 for im in image]</code></p><h4 id="K-Nearest-Neighbor-Classification"><a href="#K-Nearest-Neighbor-Classification" class="headerlink" title="K-Nearest Neighbor Classification"></a>K-Nearest Neighbor Classification</h4><pre class="line-numbers language-none"><code class="language-none">from sklearn.metrics import accuracy_score,classification_reportfrom sklearn.neighbors import KNeighborsClassifierknc = KNeighborsClassifier(n_neighbors=10)knc.fit(train_image,train_label.ravel())predict = knc.predict(test_image)print("accuracy_score: %.4lf" % accuracy_score(predict,test_label))print("Classification report for classifier %s:\n%s\n" % (knc, classification_report(test_label, predict)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Naive-Bayes"><a href="#Naive-Bayes" class="headerlink" title="Naive Bayes"></a>Naive Bayes</h4><pre class="line-numbers language-none"><code class="language-none">from sklearn.naive_bayes import MultinomialNBmnb = MultinomialNB()mnb.fit(train_image,train_label)predict = mnb.predict(test_image)print("accuracy_score: %.4lf" % accuracy_score(predict,test_label))print("Classification report for classifier %s:\n%s\n" % (mnb, classification_report(test_label, predict)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Decision-Tree"><a href="#Decision-Tree" class="headerlink" title="Decision Tree"></a>Decision Tree</h4><pre class="line-numbers language-none"><code class="language-none">from sklearn.tree import DecisionTreeClassifierdtc = DecisionTreeClassifier()dtc.fit(train_image,train_label)predict = dtc.predict(test_image)print("accuracy_score: %.4lf" % accuracy_score(predict,test_label))print("Classification report for classifier %s:\n%s\n" % (dtc, classification_report(test_label, predict)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Random-Forest"><a href="#Random-Forest" class="headerlink" title="Random Forest"></a>Random Forest</h4><pre class="line-numbers language-none"><code class="language-none">from sklearn.ensemble import RandomForestClassifierrfc = RandomForestClassifier()rfc.fit(train_image,train_label)predict = rfc.predict(test_image)print("accuracy_score: %.4lf" % accuracy_score(predict,test_label))print("Classification report for classifier %s:\n%s\n" % (rfc, classification_report(test_label, predict)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h4><pre class="line-numbers language-none"><code class="language-none">from sklearn.linear_model import LogisticRegressionlr = LogisticRegression()lr.fit(train_image,train_label)predict = lr.predict(test_image)print("accuracy_score: %.4lf" % accuracy_score(predict,test_label))print("Classification report for classifier %s:\n%s\n" % (lr, classification_report(test_label, predict)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Support-Vector-Machine"><a href="#Support-Vector-Machine" class="headerlink" title="Support Vector Machine"></a>Support Vector Machine</h4><pre class="line-numbers language-none"><code class="language-none">from sklearn.svm import SVCsvc = SVC()svc.fit(train_image,train_label)predict = svc.predict(test_image)print("accuracy_score: %.4lf" % accuracy_score(predict,test_label))print("Classification report for classifier %s:\n%s\n" % (svc, classification_report(test_label, predict)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230902171601564.png" alt="image-20230902171601564"></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230902172438530.png" alt="image-20230902172438530"></p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红与黑</title>
      <link href="/2023/07/29/hong-yu-hei/"/>
      <url>/2023/07/29/hong-yu-hei/</url>
      
        <content type="html"><![CDATA[<p>“要看一个人是不是真有价值，且在他的欲望前面、在他的事业前面，设下重重障碍，若真本领，自会克服困难或绕过障碍的。”——《红与黑》</p><p>红色是什么？鲜血？激情？抑或是警告？就像我们的祖先看见鲜血后的不安和躁动。黑色是什么？是黑夜？是压抑？抑或是未知？就像我们我们的祖先一次次的在黑夜里的恐惧。于是他们在漆黑的深夜里，用红色的火焰驱赶了恐惧，红色与黑色在此刻彼此分明而又交融。</p><p>19世纪，法国作家司汤达以《红与黑》为名，为世界留下了不朽的著作。一部著作之所以可以不朽，是来源于其可以穿越时空的内核，让当世以及未来的读者在读完之后，仍然可以听见振聋发聩的声音。《红与黑》实至名归。</p><p>《红与黑》讲述了于连，一位木匠的儿子，利用一次次的机会以及心机，一次次的冲击阶级壁垒的故事，成为市长儿子的家庭教师，然后当上侯爵秘书，又凭借个人魅力俘获了贵族玛蒂尔德的芳心，进入了军队，变成了当代所说的“凤凰男”。其中有不懈的努力，有对命运的反抗，有对人性的利用。可以说，于连执迷于世俗的成功，“宁可死上一千次也要飞黄腾达”，</p><p>但是就在阶级的大门似乎以为他开启的时候，连他自己都开始怀疑自己是否是“某位贵族遗落在山区的私生子”的时候。整个社会又再次让他清醒过来，市长夫人的来信让他崩溃在开启大门的那一刻：锒铛入狱，而内心终得解放，某种程度上，他完成了对自己的救赎，在法庭上掀起了本书的最高潮：来自与卑微阶级的他竟然想要反抗命运，企图打破阶级的壁垒，完成阶级的跃迁，那他就是与整个统治阶级为敌。因此他必须死，法国的统治阶级要用他的鲜血来杀一儆百，告诫那些企图扰乱阶级秩序的青年。于连最终选择了几近自杀的方式结束了自己的一生，就像他的跃迁之路一样：无法完成灵魂的目标，肉体就只能毁灭。</p><p>《红与黑》展示了人类的复杂性：一个人既可以是上进的五好青年，同时也可以是兜售灵魂的交易员；一如于连，追求爱情而又利用爱情；可以将《圣经》倒背如流，也能发狠一字不漏的背下拉丁文的《新约》；可以很努力，很上进，很全面的发展，也可以在梦想破灭后，心如死灰的选择死亡。也许某种程度上，没有对错好坏，于连只是用他的一生在追求自己的目标。而每个人的目标又是不一样的，就像市长早早的就对三个儿子的前途做出了规划：大儿子做军人，二儿子做法官，三儿子做传教士，分别进入军队、司法和宗教系统一样。</p><p>时代变迁，地域差异，《红与黑》描写的人性还是让人不忍直视，就像红色与黑色的撞击，给人以非愉悦的力量与涌动，在21世纪的中国，又有多少“于连”在不安的涌动？祝福他们。</p><p>”鄙视“上流社会，然后却挤破脑子去跻身上等社会，到最后才明白珍惜眼前人，这会不会是我的路途</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python神经网络编程</title>
      <link href="/2023/07/29/python-shen-jing-wang-luo-bian-cheng/"/>
      <url>/2023/07/29/python-shen-jing-wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h5 id="sigmod函数"><a href="#sigmod函数" class="headerlink" title="sigmod函数"></a>sigmod函数</h5><p><a href="https://zhuanlan.zhihu.com/p/364620596">深度学习笔记：如何理解激活函数？（附常用激活函数） - 知乎 (zhihu.com)</a></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230729080858381.png" alt="image-20230729080858381"></p><pre class="line-numbers language-none"><code class="language-none">虽然比起现代计算机，生物大脑看起来存储空间少得多，运行速度比较慢，但是生物大脑却可以执行复杂的任务，如飞行、寻找食物、学习语言和逃避天敌。相比于传统的计算机系统，生物大脑对损坏和不完善信号具有难以置信的弹性。由互相连接的神经元组成的生物大脑是人工神经网络的灵感来源。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>反向传播公式：<img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230730105609886.png" alt="image-20230730105609886"></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230730114653386.png" alt="image-20230730114653386"></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230730114706045.png" alt="image-20230730114706045"></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230730114738694.png" alt="image-20230730114738694"></p><h5 id="网络定义"><a href="#网络定义" class="headerlink" title="网络定义"></a>网络定义</h5><pre class="line-numbers language-none"><code class="language-none">class Net(torch.nn.Module):  # 继承torch的module    def __init__(self, n_feature, n_hidden, n_output):        super(Net, self).__init__()  # 继承__init__功能        # 定义每一层用什么样的样式        self.hidden1 = torch.nn.Linear(n_feature, n_hidden)  # 隐藏层线性输出        self.hidden2 = torch.nn.Linear(n_hidden, n_hidden)  # 隐藏层线性输出        self.predict = torch.nn.Linear(n_hidden, n_output)  # 输出层线性输出    def forward(self, x):        # 激励函数（隐藏层的线性值）        x = torch.relu(self.hidden1(x))        x = torch.relu(self.hidden2(x))        x = self.predict(x)  # 输出值        return xnet = Net(2, 5, 3)print(net)#输出的结果Net(  (hidden1): Linear(in_features=2, out_features=5, bias=True)  (hidden2): Linear(in_features=5, out_features=5, bias=True)  (predict): Linear(in_features=5, out_features=3, bias=True))#输出网络的参数paras = list(net.parameters())for num,para in enumerate(paras):    print('number:',num)    print(para)    print('_____________________________')       <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《噪声》</title>
      <link href="/2023/07/27/zao-sheng/"/>
      <url>/2023/07/27/zao-sheng/</url>
      
        <content type="html"><![CDATA[<p>决策的质量决定了我们的人生质量。关于如何提高决策质量的问题，就是决策与心理学研究的范畴，这个领域的集大成者就是著名的经济学家、诺贝尔经济奖得主——丹尼尔-卡尼曼。在科学决策领域有一本神书叫做《思考，快与慢》，就像每一个互联网人，每一个产品经理都会买一本《失控》一样。</p><p>决策误差两方面组成，第一是偏差，第二是噪声。</p><p>决策误差=偏差的平方+噪声的平方</p><p>偏差是比较明显的，而噪声通常是隐身的，所以很多人只会看到偏差这一个影响因素。</p><h5 id="偏差是什么？"><a href="#偏差是什么？" class="headerlink" title="偏差是什么？"></a>偏差是什么？</h5><p>例子：宜家的一块钱甜筒。</p><p>商家利用偏差去影响你，背后设计的原理就是峰终定律，就是利用人的体验不仅是体验的综合，更是过了一段时间在脑海中留下的峰值和终点的体验来决定的，如果峰值和终点是让人愉快的，那么整体的体验让人的感觉就是非常愉快的。比如宜家的一块钱甜筒就是在终点上让你觉得很舒服，而忽略过程中遇到的路线过长等不开心得体验。</p><p>例如：图片偏差效应，见到人的第一印象都是偏差</p><h5 id="噪声长什么模样？"><a href="#噪声长什么模样？" class="headerlink" title="噪声长什么模样？"></a>噪声长什么模样？</h5><p>《噪声》在书中的定义是：判断中不必要存在的变异</p><p>噪声=水平噪声+模式噪声+情景噪声</p><p>用一个面试的例子来说明这三种噪声到底是什么～比如你去一家心仪的面试，会遇到三位面试官。第一位面试官，张三，异常严格，给你打了6分。第二位面试官，李四，也属于严格派，但聊起来突然发现他是你的学长，校友情结让他给你打了8分，原因是李四每次面试校友就会格外好评，这是他的特定倾向。第三位面试官，王五，属于温柔派，给你打了10分。</p><p>那么你最后的平均分就是8分。</p><p>在这里有几个关键点</p><p>1）第一，严格派和温柔派，这两派的稳定性差异，<strong>这就是水平噪声</strong>，稳定且比较明显。严格派的分肯定比温柔派的低，不用想，很明显。</p><p>2）第二，同样是严格派的张三和李四，李四对校友就是特别友好，打分就比非校友的高，这个就是属于他的<strong>稳定模式噪声</strong>，最大的特点就是比较稳定。</p><p>3）第三，王五，王五今天心情特别好，因为昨天刚刚求婚成功，所以心情特别好，看谁都顺眼，所以打了比往常都要高的分数10分而不是9分。而张三昨天看曼联，球队输球了，所以心情不好，所以比往常都要严格，所以打了比以为都要严格的6分而不是7分。这些不稳定的因素造成的误差<strong>就是情景噪声</strong>，最大的特点就是特别是不稳定。</p><p>稳定且明显的，就是水平噪声；稳定且不明显的，就是模式噪声；不稳定且不明显的就是情景噪声，就像女人的情绪，说变就变，情绪、疲劳、天气等等都会导致同一个人在判断同一件事有不同的决定。</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230727105319664.png" alt="image-20230727105319664"></p><h5 id="为什么噪声难以察觉？"><a href="#为什么噪声难以察觉？" class="headerlink" title="为什么噪声难以察觉？"></a>为什么噪声难以察觉？</h5><p>哪里有判断，哪里就会有噪声！但是我们总是习惯性忽略它，主要原因是人类先天的因果思维。</p><h5 id="如何减少噪声？"><a href="#如何减少噪声？" class="headerlink" title="如何减少噪声？"></a>如何减少噪声？</h5><p>中介评估法</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率扩展模型</title>
      <link href="/2023/07/25/gai-lu-kuo-zhan-mo-xing/"/>
      <url>/2023/07/25/gai-lu-kuo-zhan-mo-xing/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1b541197HX/?spm_id_from=333.999.0.0&amp;vd_source=b176201190025ae11ffeced1d766effe">54、Probabilistic Diffusion Model概率扩散模型理论与完整PyTorch代码详细解读_哔哩哔哩_bilibili</a>   B站才是我的大学，🙁</p><p><img src="https://i0.hdslb.com/bfs/new_dyn/a180978fc2337febe001ab17001a6a27373596439.jpg@1048w_!web-dynamic.webp" alt="img"></p><p>Diffusion model是一种新的最先进的生成模型，可以生成多样化的高分辨率图像。在OpenAI、Nvidia和Google成功训练大型模型后，它们已经引起了很多关注。基于扩散模型的示例架构包括GLIDE、DALLE-2、Imagen和完整的开源stable diffusion。</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230726211313770.png" alt="image-20230726211313770"></p><h1 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h1><h5 id="1-Introduction-Denoising-Diffusion-Model"><a href="#1-Introduction-Denoising-Diffusion-Model" class="headerlink" title="1.Introduction(Denoising Diffusion Model)"></a>1.Introduction(Denoising Diffusion Model)</h5><p>Diffusion Models是生成模型，意味着它们用于生成与它们训练的数据类似的数据。从根本上讲，Diffusion Models通过连续添加Gaussian noise来破坏训练数据，然后学习通过反转这个加noising的过程来恢复数据。训练后，我们可以通过将随机抽样的noise通过学习得到的denoising过程来生成数据。</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230726211913551.png" alt="image-20230726211913551"></p><p>GAN和VAE是两种重要的生成模型，在多个应用中都取得了很大的成功和认可。GAN表现出色，但是由于多种挑战（例如mode collapse和vanishing gradients等），其输出缺乏多样性，且很难训练。VAE有最稳固的理论基础，但是在VAE中建模良好的损失函数是一个挑战，这使得它们的输出是次优的。</p><p>Diffusion Modeling的关键概念在于，如果我们能够建立一个学习模型，能够学习由于噪声而导致的信息系统性衰减，那么就应该能够反转这个过程，从噪声中恢复信息。这个概念与VAE相似，它尝试通过首先将数据投影到潜在空间，然后将其恢复到初始状态来优化目标函数。然而，系统的目标不是学习数据分布，而是在Markov链中建模一系列噪声分布，并通过分层方式来解码数据，从而撤消/消除数据中的噪声。<img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230726213728259.png" alt="image-20230726213728259"></p><p>Diffusion model可以被看作是latent variable model。latent variable意味着我们是指一个隐藏的连续特征空间。这样，它们可能看起来类似于variational autoencoders (VAEs)。</p><p>有几种基于扩散的生成模型提出了类似的想法，包括diffusion probabilistic models（Sohl-Dickstein et al.，2015年），noise-conditioned score network（NCSN; Yang＆Ermon，2019年）和denoising diffusion probabilistic models（DDPM; Ho等人，2020年）。</p><p>在实践中，Diffusion model使用了T步的Markov链来建模。这里，Markov链意味着每一步只依赖于前一步，这是一个温和的假设。重要的是，与 flow-based models不同，我们不受限于使用特定类型的神经网络。</p><p>更具体地说，Diffusion Model是一种潜在变量模型，使用固定的Markov链将数据映射到潜在空间。该链逐渐添加噪声到数据中，以获得近似后验q(x1:T | x0)分布，其中x1,….XT是具有相同维度的潜在变量。在下面的图中，我们看到了用于图像数据的这样的Markov链的表现。</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230726214006809.png" alt="image-20230726214006809"></p><h5 id="2-Forward-diffusion-process"><a href="#2-Forward-diffusion-process" class="headerlink" title="2.Forward diffusion process"></a>2.Forward diffusion process</h5><p>更具体地说，DIffusion Model是一种潜在变量模型，使用固定的马尔科夫链将数据映射到潜在空间。改链逐渐添加噪声到数据中，以获得近似后验q（x1：T | x0）分布，其中x1,….XT是具有相同维度的潜在变量。 在下面的图中，我们看到了用于图像数据的这样的 Markov 链的表现。</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728075941387.png" alt="image-20230728075941387"></p><p>我们可以正式定义前向扩散过程为一个马尔科夫链，因此，不像VAE中的编码器，它不需要训练。从初始数据点x0开始，我们在接下来的T步中添加方差为 βt 的高斯噪声到 xt-1中，并获得一组具有分布 q（xt | xt-1） 的噪声样本xt。 在时间 <em>t</em> 的概率密度预测仅取决于时间 <em>t-1</em> 的直接前置物，因此可以计算出条件概率密度，如下所示：</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728080300420.png" alt="image-20230728080300420"></p><p>随着步长变大，数据样本x0逐渐失去其可区分的特征。最终当T趋向正无穷的时候，xt等价于一个各向同性的高斯分布。</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728080947939.png" alt="image-20230728080947939"></p><p>由于我们处于多维场景中，I是身份矩阵，表示每个维度具有相同的标准差β_t。 请注意，q（xt | xt-1）仍然是一个正态分布，由均值μ和方差Σ定义，其中μt = sqrt（1-βt）* xt-1并且Σt = βtI。 Σ始终是一个具有方差的对角矩阵（这里是βt）。</p><p>因此，我们可以以可处理的方式从输入数据 x0 走向封闭形式的 xT。 在数学上，这是后验概率，整个过程的完整分布可以按以下方式计算：</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728081047119.png" alt="image-20230728081047119"></p><p>在这里，机率密度函数的平均值和方差取决于参数 βτ，这是一个超参数，其值可以在整个过程中作为常数，也可以在连续的步骤中逐渐改变。 对于微分参数值分配，可以使用一系列函数来模拟行为（例如 sigmoid、tanh、线性等）。</p><p>以上的推导足以预测连续的状态，然而，如果我们想在任何给定的时间间隔 <em>t</em> 内进行抽样，而不必经过所有的中介步骤，因此允许一个有效的实现，那么我们可以通过替换超参数为 ατ = 1-βτ 来重新构思上述方程，上述的改组如下：</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728081125434.png" alt="image-20230728081125434"></p><p>为了在时间步骤 <em>t</em> 上产生样本，我们可以使用来自热力学的另一个概念 — — 「Langevin dynamics」。 根据随机梯度 Langevin dynamics [2]，我们只能通过在马可夫链更新中密度函数的梯度来采样系统的新状态。 基于时间 <em>t-1</em> 上的上一个点，使用步长 ε，可以计算出在时间 <em>t</em> 上的新数据点的采样方式如下：</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728081204508.png" alt="image-20230728081204508"></p><h5 id="3-Reverse-diffusion-process"><a href="#3-Reverse-diffusion-process" class="headerlink" title="3.Reverse diffusion process"></a>3.Reverse diffusion process</h5><p>当T趋近于无限大时，latent变量xt几乎是一个各向同性高斯分布。 因此，如果我们能够学习到反向分布 q（xt-1 | xt），就可以从均值为0、协方差矩阵为单位矩阵的正态分布中采样 xt，运行反向过程，获得从 q（x0） 中采样的一个样本，生成一个新的数据点从原始数据分布中。</p><p>如果我们可以反转上述过程并从 q（xt-1 | xt） 采样，我们将能够从高斯噪声输入 xT~N（0，I） 中重新创建真实样本。 请注意，如果 βt 足够小，也会是高斯分布。 不幸的是，我们无法轻易地估计 q（xt-1 | xt），因为它需要使用整个数据集，因此我们需要学习一个模型 pθ，以近似这些条件概率，以便运行反向扩散过程。</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728081342436.png" alt="image-20230728081342436"></p><p>最终，图像渐进地转换为纯高斯噪声。训练扩散模型的目标是学习反向过程——即训练 pθ（xt-1 | xt）。通过沿着这个链向后遍历，我们可以生成新的数据。</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728081602675.png" alt="image-20230728081602675"></p><p>逆向过程需要在当前系统状态的基础上估计当前时间步长的概率密度，这意味着在 <em>t=T</em> 时估计 q（xt-1 | xt） ，并从同质性高斯噪声中生成数据样本。 然而，与正向过程不同的是，从当前状态估计先前状态需要知道所有先前的梯度，而我们无法在没有能够预测此类估计的学习模型的情况下获取它们。 因此，我们必须训练一个神经网络模型，该模型根据学习的权重 θ 和时间 <em>t</em> 的当前状态来估计 ρθ（χτ-1|χτ）。 这可以通过以下方式对所有时间步骤应用反向公式（pθ（x0：T），也称为轨迹，进行估计：</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728081737884.png" alt="image-20230728081737884"></p><p>透过将模型加上时间步骤 t 的条件，模型将会学习预测每个时间步骤的高斯参数，而均值函数的参数化是由<em>Ho. et al.</em> [3] 提出的，可以按以下方式计算：</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728081825244.png" alt="image-20230728081825244"></p><h5 id="4-Architecture"><a href="#4-Architecture" class="headerlink" title="4.Architecture"></a>4.Architecture</h5><p>虽然我们简化过的损失函数旨在训练模型 εθ，但我们仍未定义该模型的架构。 而该模型的<em>唯一</em>要求是其输入和输出的维度相同。</p><p>考虑到这一限制，图像Diffusion Model通常使用类似于U-Net的架构实现。</p><p>U-Net 是一个对称的架构，其输入和输出具有相同的空间大小，并使用相应特征维度的编码器和解码器块之间的跳过连接。 通常，输入图像首先进行下采样，然后进行上采样，直到达到其初始大小。</p><p>在 DDPM 的原始实现中，U-Net 由 Wide <a href="https://theaisummer.com/skip-connections/#resnet-skip-connections-via-addition"><strong>ResNet blocks</strong></a><strong>、</strong> <a href="https://theaisummer.com/normalization/#group-normalization-2018"><strong>group normalization</strong></a><strong>以及</strong> <a href="https://theaisummer.com/attention/"><strong>self-attention</strong></a>块组成。</p><p>通过在每个残差块中添加正弦<a href="https://theaisummer.com/positional-embeddings/">position embedding</a>，来指定扩散时间步长 t。</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728082217291.png" alt="image-20230728082217291"></p><p>Reverse Process Decoder and L0</p><p>在反向过程中，路径包含许多在连续条件高斯分布下的转换。 在反向过程结束时，我们试图生成由整数像素值组成的图像。 因此，我们必须设计一种方法，以获取所有像素的每个可能像素值的discrete （log）概率。</p><p>这是通过将反向扩散链中的最后一个转换设置为独立离散解码器来完成的。 为了确定给定图像 x1 的情况下图像 x0 的概率，我们首先将数据维度之间的独立性约束：</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728082317127.png" alt="image-20230728082317127"></p><p>在这里，D 表示数据的维度，上标 i 表示提取一个坐标。 现在的目标是确定对于给定像素，每个整数值的可能性是多少，<em>给定</em>时间 t=1 时稍微有噪声的图像中对应像素的可能值分布：</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728082336067.png" alt="image-20230728082336067"></p><p>在此，t=1 的像素分布是从下面的多元高斯分布中推导出来的，其对角协方差矩阵允许我们将分布分成单变量高斯分布的乘积，每个数据维度对应一个单变量高斯分布：</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728082359840.png" alt="image-20230728082359840"></p><p>我们假设图像由介于 0、1、…、255 的整数组成（与标准 RGB 图像相同），并已线性缩放至 [-1，1]。 然后，我们将实数线分成小的“桶”，对于给定的缩放像素值 <em>x</em>，该范围的桶是 *[x-1/255， x+1/255]*。 给定 x1 中对应像素的单变量高斯分布，像素值 <em>x</em> 的概率是在以 <em>x</em> 为中心的桶中该单变量高斯分布下的面积。</p><p>下面显示了每个桶的面积及其对于平均值为零的高斯分布的概率。 在这种情况下，平均像素值为255/2（半亮度）。 红色曲线表示 <em>t=1</em> 图像中特定像素的分布，而区域则给出了 <em>t=0</em> 图像中相应像素值的概率。</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728082431093.png" alt="image-20230728082431093"></p><p>对于每个像素的初始值 <em>t=0</em>，其 <em>pθ（x0|x1）</em> 的值就是它们的乘积。 这个过程可以用以下方程序简洁地表达：</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728082500049.png" alt="image-20230728082500049"></p><h5 id="5-Training-and-sampling-algorithms"><a href="#5-Training-and-sampling-algorithms" class="headerlink" title="5.Training and sampling algorithms"></a>5.Training and sampling algorithms</h5><p>5.1 <strong>Construction of the Model</strong></p><p>在扩散模型的训练中使用的模型遵循与VAE网络类似的模式，但与其他网络架构相比，它通常更简单和直接。 输入层的输入大小与数据维度相同。 根据网络要求的深度，可以有多个隐藏层。 中间层是具有相应激活函数的线性层。 最后一层的大小再次与原始输入层的大小相同，因此可以重构原始数据。 在<em>Denoising Diffusion Networks</em>中，最后一层由两个独立的输出组成，分别专门用于预测probability density的mean和variance。</p><p><strong>5.2</strong> <strong>Computation of Loss Function</strong></p><p>网络模型的目标是优化以下损失函数：</p><p>Diffusion Model是通过找到最大化训练数据概率的反向Markov转换来进行训练。 实际上，训练相当于最小化负对数似然的变分上限。</p><p><img src="https://miro.medium.com/v2/resize:fit:400/0*AJYW7ZAPgYCKRWLI.png" alt="img"></p><p><em>Sohl-Dickstein et al.</em> [1] 提出了这个损失函数的简化形式，它将损失定义为两个高斯分布之间 KL 散度的线性组合和一组熵的形式。 这简化了计算，并使实现损失函数变得容易。 损失函数如下：</p><p><img src="https://miro.medium.com/v2/resize:fit:749/0*ja1T_ZxkZ34sGUgA.png" alt="img"></p><p><img src="https://miro.medium.com/v2/resize:fit:875/0*peJQkWmQjy0eLKUy.png" alt="img"></p><p><strong>5.3</strong> <strong>Kullback-Leibler (KL) Divergences</strong></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728082755992.png" alt="image-20230728082755992"></p><p>我们希望将Lvlb重写为Kullback-Leibler（KL）散度的形式。 KL散度是一种非对称统计距离度量，用于衡量一个概率分布P与参考分布Q相差多少。 我们有兴趣以KL散度的形式表达Lvlb，因为我们Markov链中的转换分布是高斯分布，而高斯分布之间的KL散度具有封闭形式。</p><p>连续分布的 KL 散度的数学形式是</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728082820373.png" alt="image-20230728082820373"></p><p>下面您可以看到一个变化的分布* P <em>（蓝色）从参考分布</em> Q <em>（红色）的KL散度。 绿色曲线表示上面KL散度定义中的积分函数，曲线下总面积表示任何给定时刻</em>P<em>从</em>Q*的KL散度值，这个值也以数字形式显示。</p><p><img src="https://miro.medium.com/v2/resize:fit:875/1*MQokzgLolb_QE9CRRq48fg.gif" alt="img"></p><p><strong>根据 KL 散度投射 Lvlb</strong></p><p>在LVLB中，除了L0以外的每个KL项都比较两个高斯分布，因此它们可以以“闭合形式”计算。 LT是常数，可以在训练期间被忽略，因为q没有可学习的参数，而xT是Gaussian noise。 Ho等人（2020年）使用从N（x0; μθ（x1，1），Σθ（x1，1））衍生的单独离散解码器模拟L0。</p><p>让我们分别标记变分下限损失中的每个部分：</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230728082954797.png" alt="image-20230728082954797"></p><p>将Lt-1中的前向过程后验条件于x0，可以得到一个可行的形式，这导致所有KL散度都是高斯之间的比较。 这意味着，可以使用闭式表达式而不是蒙特卡罗估计来精确计算散度。</p><p><strong>4.4 Final Objective and Simplification Loss</strong></p><p>实验上，<a href="https://arxiv.org/abs/2006.11239">Ho et al. （2020）</a> 作者发现在给定时间步长的情况下***预测图像的噪声部分可以产生最佳结果**<em>，并且使用忽略权重项的简化目标执行扩散模型的训练效果更好。 在损失函数中，</em>Ho等人*进一步提出了改进，其中均值的参数化使用了前向过程中上一节所述的方式。</p><p><img src="https://miro.medium.com/v2/resize:fit:736/1*eVTStmpvwA_gyOAqRxv2nw.png" alt="img"></p><p><img src="https://miro.medium.com/v2/resize:fit:476/0*dyISpykyl9eL9yI0.png" alt="img"></p><p><img src="https://miro.medium.com/v2/0*FuyoZS2j1e1gWmgk.png" alt="img"></p><p>最终的简单目标如下：</p><p><img src="https://miro.medium.com/v2/resize:fit:279/1*gPWjH4-UsBdadkjwl66UWA.png" alt="img"></p><p>其中，C是不依赖于θ的常数。</p><p>Diffusion Model 的训练和抽样算法可以简洁地呈现在下图中：</p><p><img src="https://miro.medium.com/v2/resize:fit:875/0*JnKC_EEd38d_-nHy.png" alt="img"></p><p>Fig. 4. The training and sampling algorithms in DDPM (Image source: <a href="https://arxiv.org/abs/2006.11239">Ho et al. 2020</a>)</p><p><img src="https://miro.medium.com/v2/resize:fit:796/1*ADwQV3MwoBF9guHkPUviiA.png" alt="img"></p><p><img src="https://miro.medium.com/v2/resize:fit:1191/1*R9H5k395SjcX3U8bdFAV3g.png" alt="img"></p><p><a href="https://github.com/dome272/Diffusion-Models-pytorch">https://github.com/dome272/Diffusion-Models-pytorch</a></p><h5 id="6-Conditioned-Generation"><a href="#6-Conditioned-Generation" class="headerlink" title="6.Conditioned Generation"></a>6.Conditioned Generation</h5><p>扩散模型是有条件的模型，它依赖于先验知识。 在图像生成任务中，prior数据通常是文本、图像或语义地图。 为了获取此条件的潜在表示，使用transformer（例如CLIP）将文本/图像嵌入潜在向量“τ”中。 因此，最终的损失函数不仅取决于原始图像的latent space，也取决于条件的latent embedding， 而这样子以条件化采样过程操纵generated sample，这在这里也称为guided diffusion。</p><p>在数学上，引导是指将先验数据分布p（x）与条件y（即类别标签或图像/文本嵌入）进行条件化，从而得到p（x|y）。</p><p>要将扩散模型pθ转换为条件扩散模型，可以在每个扩散步骤中添加条件信息y。</p><p><img src="https://miro.medium.com/v2/resize:fit:709/1*aTGRSoGMy2duhB-Yf6KrVg.png" alt="img"></p><p>每个时间步骤都看到条件可能是从文本提示获得优秀样本的良好理由。</p><p>通常，引导扩散模型旨在学习 <strong>∇log*pθ*（x*t*∣*y*）</strong>。 因此，使用贝叶斯规则，我们可以写成：</p><p><img src="https://miro.medium.com/v2/resize:fit:875/1*i5KL0Gu0YzOX4m_kE1ZXsg.png" alt="img"></p><p>因为梯度运算符∇xt只涉及xt，所以没有y的梯度。 此外，请记住log（ab） = log（a） + log（b）。</p><p>透过添加guidance scalar项s，我们得到：</p><p><img src="https://miro.medium.com/v2/resize:fit:875/1*4_cR1D194FGkZOrSwDddgQ.png" alt="img"></p><p>使用这种公式，让我们区分classifier和classifier-free的引导。 接下来，我们将介绍两种旨在injecting label信息的方法种类。</p><p><strong>6.1 Classifier guidance</strong></p><p><a href="https://arxiv.org/abs/1503.03585">Sohl-Dickstein et al</a> 和后来的<a href="https://arxiv.org/abs/2105.05233">Dhariwal and Nichol</a> 显示我们可以使用分类器f<em>φ</em>（<em>y</em>∣<em>xt</em>，<em>t</em>）来指导扩散过程在训练中朝着目标类<em>y</em>方向移动。 为了实现这一点，我们可以使用分类器f<em>φ</em>（<em>y</em>∣<em>xt</em> ， <em>t</em> ）对噪音图像x<em>t进行训练，以预测其类别</em>y。 然后，我们可以使用梯度∇log（<em>fφ</em>（<em>y</em>∣x<em>t</em>））来指导扩散过程。 具体来说，我们可以建立一个类条件扩散模型，其均值为μθ（<em>x</em>t<em>∣</em>y），方差为Σθ（<em>x</em>t<em>∣</em>y）。</p><p>由于pθ ~ N（μθ， Σθ），我们可以使用先前章节的guidance formulation来显示，均值受到类y的log<em>fφ</em>（<em>y</em>∣<strong>x</strong><em>t</em>）的梯度干扰，从而产生：</p><p><img src="https://miro.medium.com/v2/resize:fit:676/1*eWImjBubY9Y-VcGopaLhxA.png" alt="img"></p><p>在著名的GLIDE论文中，Nichol等人进一步扩展了这个想法，并使用CLIP嵌入来引导扩散。 CLIP 是由 Saharia 等人提出的，包括一个图像编码器 g 和一个文本编码器 <em>h</em>。 它分别产生图像和文本嵌入 g（x<em>t</em>） 和 h（<em>c</em>），其中 c 是文本标题。</p><p>因此，我们可以使用它们的点积来干扰梯度：</p><p><img src="https://miro.medium.com/v2/resize:fit:631/1*6u-P91e0gSC3kNbIit3VLQ.png" alt="img"></p><p>因此，他们成功地将generation process“引导”向user-defined的文本标题。</p><p><img src="https://miro.medium.com/v2/resize:fit:875/0*hli6HeLADzq5c_LM.png" alt="img"></p><p><em>Algorithm of classifier guided diffusion sampling. Source:</em> <a href="https://arxiv.org/abs/2105.05233"><em>Dhariwal &amp; Nichol 2021</em></a></p><p><strong>6.2 Classifier-Free Guidance</strong></p><p>使用与之前相同的公式，我们可以定义一个classifier-free引导扩散模型：</p><p><img src="https://miro.medium.com/v2/resize:fit:740/1*P1IkSzi86Qm7KXXDFjuPPQ.png" alt="img"></p><p>Ho&amp;Salimans提出了不需要第二个分类器模型即可实现引导的方法。 作者们没有训练单独的分类器，而是训练了一个有条件的扩散模型 εθ（x<em>t</em><em>|y</em>） 和一个无条件的模型 ε<em>θ</em>（x<em>t</em>|0）。 实际上，他们使用完全相同的神经网络。 在训练过程中，他们随机将类别 y 设置为 0，以便模型暴露于有条件和无条件的设置：</p><p><img src="https://miro.medium.com/v2/resize:fit:628/1*VRIR3Cj9-pQyYB3BawGQ1g.png" alt="img"></p><p>注意，这也可以用于“inject”文本嵌入，就像在classifier guidance中展示的那样。</p><p>这个过程虽然有些“奇怪”，但有两个主要优点：</p><ul><li>它只使用单一模型来引导diffusion。</li><li>当在条件上需要使用分类器难以预测的信息（例如text embedding）时，它简化了guidance的过程。</li></ul><h5 id="7-Stable-diffusion-Latent-diffusion-model"><a href="#7-Stable-diffusion-Latent-diffusion-model" class="headerlink" title="7.Stable diffusion: Latent diffusion model"></a>7.Stable diffusion: Latent diffusion model</h5><p>潜变散射模型（Latent diffusion model，LDM; <a href="https://arxiv.org/abs/2112.10752">Rombach et al.</a>）基于一个相对简单的思路：不直接在高维输入上应用扩散过程，而是将输入投影到较小的潜变空间中进行扩散运算。</p><p>更详细地说，<a href="https://arxiv.org/abs/2112.10752">Rombach et al.</a> 提出使用编码器网络将输入编码成潜变表示，即 zt = g（xt）。 这个决策的直觉是通过在较低维空间中处理输入来降低训练扩散模型的计算要求。 之后，应用标准的扩散模型（U-Net）生成新数据，由解码器网络进行上采样。</p><p>从逆向扩散过程的马尔可夫链中生成样本的速度非常慢，因为T可能高达一千或几千步。 一个来自<a href="https://arxiv.org/abs/2010.02502">Song et al. 2020</a> 的数据点：“例如，从DDPM抽取32x32大小的50k图像需要大约20小时，但使用Nvidia 2080 Ti GPU从GAN中进行抽样需要不到一分钟。 ”</p><p>一种简单的方法是运行一个分步抽样计划（<a href="https://arxiv.org/abs/2102.09672">Nichol&amp;Dhariwal，2021</a>），每⌈T / S⌉步采取抽样更新，以将过程从T减少到S步。 生成的新抽样计划为{τ1,…,τS}，其中τ1 &lt;τ2 &lt;⋯&lt;τS∈[1，T]且S &lt;T。</p><p>如果将典型扩散模型（DM）的损失公式化为：</p><p><img src="https://miro.medium.com/v2/resize:fit:504/1*F99Jc9fUZyvdy15j06lziw.png" alt="img"></p><blockquote><p>另一种方法是，根据<a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/#nice">nice property</a>将<em>q_σ</em>（x<em>t−1</em>|x<em>t</em>，x<em>0</em>）改写为以所需标准差σt为参数化的形式。</p></blockquote><p><img src="https://miro.medium.com/v2/resize:fit:875/1*3HKXOX4rvfFFZHQGnkR1JQ.png" alt="img"></p><blockquote><p>回想一下，在<em>q</em>（x<em>t−1</em>|x<em>t</em>，x<em>0</em>）=N（x<em>t−1</em>; μ<del>（x<em>t</em>，x<em>0</em>），β</del><em>t</em>I），因此我们有：</p></blockquote><p><img src="https://miro.medium.com/v2/resize:fit:315/1*f2hFyXTKjBY5y6naXey1UA.png" alt="img"></p><blockquote><p>让 σt² = η ·βt~，这样我们就可以调整 η∈ R+ 作为超参数以控制抽样的随机性。 当η=0时，抽样过程变成了 <em>deterministic</em>。 这样的模型称为 <em>denoising diffusion implicit model</em>（DDIM; Song et al., 2020）。 DDIM 具有相同的边际噪声分布，但是可以将噪声映射回原始数据样本。</p><p>在生成过程中，我们只对S个扩散步骤{τ1,…,τS}进行抽样，推理过程变为：</p></blockquote><p><img src="https://miro.medium.com/v2/resize:fit:875/1*RWlanFLmH9G2IH_ytMxbeQ.png" alt="img"></p><blockquote><p>在实验中，所有模型都是用T = 1000个扩散步骤进行训练的，他们观察到当S很小时，DDIM（η = 0）可以产生最好的质量样本，而小S时DDPM（η = 1）表现更差。 当我们有足够的资源运行完整的反向马尔可夫扩散步骤（S = T = 1000）时，DDPM的表现更好。 使用DDIM，可以训练扩散模型达到任意数量的正向步骤，但只能从生成过程的某些步骤中进行抽样。</p></blockquote><p><img src="https://miro.medium.com/v2/resize:fit:875/0*SMa-soE30agEsedJ.png" alt="img"></p><p>图7. 不同设置下扩散模型的CIFAR10和CelebA数据集上的FID得分，包括DDIM （η=0）和DDPM （σ^）。 （Image source：<a href="https://arxiv.org/abs/2010.02502">Song et al.，2020</a>）</p><blockquote><p>相较于DDPM，DDIM能够：</p><p>在使用少得多的步骤时生成更高质量的样本。</p><p>具有“一致性”特性，因为生成过程是确定性的，这意味着在相同潜变量的条件下产生的多个样本应具有类似的高级特征。</p><p>由于具有一致性，DDIM可以在潜在变量中进行语义上有意义的插值。</p><p><em>潜变散射模型</em> （<strong>LDM</strong>; <a href="https://arxiv.org/abs/2112.10752">Rombach&amp;Blattmann等人，2022</a>） 在潜在空间中运行扩散过程，而不是像素空间，使训练成本更低，推论速度更快。 它的动机来自于观察到图像的大部分位贡献于知觉细节，并且在进行激烈压缩后，语义和概念组成仍然存在。 LDM通过首先使用自编码器削减pixel-level redundancy，然后通过学习到的潜变量在扩散过程上操作/生成语义概念，松散地分解了知觉压缩和语义压缩的生成建模学习。</p></blockquote><p><img src="https://miro.medium.com/v2/resize:fit:875/0*J4d79ezS-j7YLket.png" alt="img"></p><p>Fig. 8. The plot for tradeoff between compression rate and distortion, illustrating two-stage compressions — perceptural and semantic comparession. (Image source: <a href="https://arxiv.org/abs/2112.10752">Rombach &amp; Blattmann, et al. 2022</a>)</p><blockquote><p>知觉压缩过程依赖于自编码器模型。 使用编码器 ε 压缩输入图像 x<em>∈</em> R HxWx³ 到更小的 2D 潜变量 z=ε（x）R h x w x c，其中下采样率 f=H/h=W/w=2m，m∈N。 然后，解码器 D 从潜变量重建图像，即 x~=D（z）。 本文探讨了自编码器训练中的两种正则化方法，以避免潜变量空间中任意高变异性。</p><p>KL-reg： 对学习的潜变量施加小的KL惩罚，以使其接近标准正态分布，类似于<a href="https://lilianweng.github.io/posts/2018-08-12-vae/">VAE</a>。</p><p>VQ-reg： 在解码器中使用矢量量化层，类似于 <a href="https://lilianweng.github.io/posts/2018-08-12-vae/#vq-vae-and-vq-vae-2">VQVAE</a>，但量化层被解码器吸收。</p></blockquote><p>扩散和去噪过程发生在潜变量 z 上。 去噪模型是一个时间条件下的 U-Net，通过交叉关注机制进行扩展，以处理图像生成的灵活调节信息（例如类别标签、语义地图、图像的模糊变体）。 该设计相当于使用交叉关注机制将不同模态的表示融合到模型中。 每种调节信息都与特定领域的编码器 τθ 配对，以将调节输入 y 投影到可以映射到交叉关注组件的中间表示，τθ（y）∈RM×dτ：</p><p><img src="https://miro.medium.com/v2/resize:fit:875/1*3ZXAha3ZDgxpsPzCK88RMA.png" alt="img"></p><p><img src="https://miro.medium.com/v2/resize:fit:875/0*yaAdYmEAvrV302Au.png" alt="img"></p><p>Fig. 9. The architecture of latent diffusion model. (Image source: <a href="https://arxiv.org/abs/2112.1075">Rombach &amp; Blattmann, et al. 2022</a>)</p><h5 id="8-Summary"><a href="#8-Summary" class="headerlink" title="8.Summary"></a>8.Summary</h5><p>在本节中，我们对扩散模型的理论进行了详细的探讨。 从鸟瞰的角度来看，以下是本节中最重要的几点：</p><ol><li>我们的扩散模型被参数化为<strong>Markov chain</strong>，这意味着我们的潜在变量x1,…,xT仅取决于前一个（或后一个）时间步。</li><li>马尔可夫链中的<strong>transition distributions</strong>是<strong>高斯分布</strong>，其中前向过程需要一个方差计划，而反向过程的参数是学习的。</li><li>扩散过程确保了当T足够大时，xT<strong>渐近地分布为一个各向同性的高斯分布</strong>。</li><li>在我们的情况下，<strong>方差计划是固定的</strong>，但也可以进行学习。 对于固定的计划，按照几何进度可能比按线性进度获得更好的结果。 无论哪种情况，方差通常随着时间在系列中增加（即i&lt;j时βi&lt;βj）。</li><li>扩散模型非常灵活，允许使用任何输入和输出维度相同的架构。 许多实现使用类似于<strong>U-Net的</strong>架构。</li><li>训练目标是<strong>最大化训练数据的可能性</strong>。 这表现为调整模型参数以<strong>最小化数据的负对数概率的变分上限</strong>。</li><li>由于我们的马尔可夫假设，几乎所有目标函数中的项都可以被表示为<strong>KL散度</strong>。 由于我们使用的是高斯分布，因此这些值<strong>易于计算</strong>，因此无需进行蒙特卡罗近似。</li><li>最终，使用<strong>简化的训练目标</strong>来训练预测给定潜在变量的噪声组件的函数会产生最好且最稳定的结果。</li><li>在反向扩散过程的最后一步中，使用<strong>离散解码器</strong>获取像素值的log likelihoods。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多维向量的乘积</title>
      <link href="/2023/07/19/duo-wei-xiang-liang-de-cheng-ji/"/>
      <url>/2023/07/19/duo-wei-xiang-liang-de-cheng-ji/</url>
      
        <content type="html"><![CDATA[<p>shape=[2,2,3]的三维矩阵，可以视为2个shape=[2,3]的二维矩阵堆叠在一起！！最后两维才是有数据的矩阵，前面的维度只是矩阵的排列而已！</p><p>所以在矩阵运算的时候，其实最后都可以转成我们常见的二维矩阵运算，遵循的原则是：在多维矩阵相乘中，需最后两维满足shape匹配原则，最后两维才是有数据的矩阵，前面的维度只是矩阵的排列而已！</p><p>比如说是一个输入[64,3,32,32]，第一维度表示batch_size，第二维度表示通道数。</p><pre class="line-numbers language-none"><code class="language-none">a = [[[ 1.  2.  3.]  [ 4.  5.  6.]] [[ 7.  8.  9.]  [10. 11. 12.]]]b = [[[ 1.  2.]  [ 3.  4.]  [ 5.  6.]] [[ 7.  8.]  [ 9. 10.]  [11. 12.]]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230719132230670.png" alt="image-20230719132230670"></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230719132230670.png"></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230719132259087.png" alt="image-20230719132259087"></p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度AI</title>
      <link href="/2023/07/17/bai-du-ai/"/>
      <url>/2023/07/17/bai-du-ai/</url>
      
        <content type="html"><![CDATA[<p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230717090749273.png" alt="image-20230717090749273"></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230722075209939.png" alt="image-20230722075209939"></p><h5 id="json-dumps-函数"><a href="#json-dumps-函数" class="headerlink" title="json.dumps()函数"></a>json.dumps()函数</h5><pre class="line-numbers language-none"><code class="language-none">`json.dumps()`是Python标准库中的一个函数，用于将Python对象序列化为JSON格式的字符串。该函数接受一个Python对象作为输入，返回一个JSON格式的字符串。以下是该函数的基本语法：```json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False)```其中，`obj`参数是要序列化为JSON格式的Python对象。其他参数均为可选参数，具体含义如下：- `skipkeys`：如果为True，则在序列化过程中跳过字典中键不是字符串的项，默认为False。- `ensure_ascii`：如果为True，则将所有非ASCII字符转义为Unicode转义序列，默认为True。- `check_circular`：如果为True，则在序列化过程中检查循环引用，默认为True。- `allow_nan`：如果为True，则允许序列化NaN、Infinity或-Infinity，默认为True。- `cls`：用于自定义JSON编码器的类，默认为None。- `indent`：用于指定缩进级别的空格数，默认为None。- `separators`：用于指定JSON格式字符串中各个元素之间的分隔符，默认为(`,`, `:`)。- `default`：用于指定自定义对象的序列化函数，默认为None。- `sort_keys`：如果为True，则在序列化过程中按照键的字母顺序对字典进行排序，默认为False。`json.dumps()`函数使用时需要注意以下几点：1. 输入的Python对象必须是可序列化的。可序列化的Python对象包括列表、元组、字典、数字、字符串和布尔值等基本数据类型，以及这些基本数据类型的嵌套组合。2. JSON格式的字符串中，键必须是字符串类型，而且必须使用双引号进行包围。3. 如果需要将JSON格式的字符串转换为Python对象，则可以使用`json.loads()`函数。以下是一个使用`json.dumps()`函数将Python对象序列化为JSON格式的字符串的示例：```import jsondata = {'name': 'Alice', 'age': 20, 'gender': 'female'}json_str = json.dumps(data)print(json_str)```在这个示例中，我们将一个字典对象`data`序列化为JSON格式的字符串，然后将结果打印输出。输出结果如下：```{"name": "Alice", "age": 20, "gender": "female"}```可以看到，`json.dumps()`函数将字典对象`data`序列化为了一个JSON格式的字符串。在这个JSON格式的字符串中，键都被转换为了字符串类型，并且使用双引号进行包围。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="json-loads函数"><a href="#json-loads函数" class="headerlink" title="json.loads函数"></a>json.loads函数</h5><pre class="line-numbers language-none"><code class="language-none">`json.loads()`是Python标准库中的一个函数，用于将JSON格式的字符串反序列化为Python对象。该函数接受一个JSON格式的字符串作为输入，返回一个Python对象。以下是该函数的基本语法：```json.loads(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None,           parse_constant=None, object_pairs_hook=None, **kw)```其中，`s`参数是要反序列化为Python对象的JSON格式的字符串。其他参数均为可选参数，具体含义如下：- `cls`：用于自定义JSON解码器的类，默认为None。- `object_hook`：用于自定义JSON解码器中对象的反序列化函数，默认为None。- `parse_float`：用于自定义JSON解码器中浮点数的反序列化函数，默认为None。- `parse_int`：用于自定义JSON解码器中整数的反序列化函数，默认为None。- `parse_constant`：用于自定义JSON解码器中常量（如NaN、Infinity等）的反序列化函数，默认为None。- `object_pairs_hook`：用于自定义JSON解码器中字典的反序列化函数，默认为None。- `kw`：用于传递其他参数的关键字参数。`json.loads()`函数使用时需要注意以下几点：1. 输入的JSON格式字符串必须符合JSON规范。2. 在JSON格式字符串中，键必须是字符串类型，而且必须使用双引号进行包围。3. `json.loads()`函数返回的Python对象类型取决于JSON格式字符串的内容。例如，如果JSON格式字符串表示一个字典，`json.loads()`函数将返回一个Python字典对象；如果JSON格式字符串表示一个列表，`json.loads()`函数将返回一个Python列表对象。以下是一个使用`json.loads()`函数将JSON格式字符串反序列化为Python对象的示例：```import jsonjson_str = '{"name": "Alice", "age": 20, "gender": "female"}'data = json.loads(json_str)print(data)```在这个示例中，我们将一个JSON格式的字符串`json_str`反序列化为Python对象`data`，然后将结果打印输出。输出结果如下：```{'name': 'Alice', 'age': 20, 'gender': 'female'}```可以看到，`json.loads()`函数将JSON格式的字符串`json_str`反序列化为了一个Python字典对象`data`。在这个字典对象中，键都被转换为了字符串类型，并且没有双引号包围。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="dump和dumps-load和loads"><a href="#dump和dumps-load和loads" class="headerlink" title="dump和dumps,load和loads"></a>dump和dumps,load和loads</h5><pre class="line-numbers language-none"><code class="language-none">在Python中，`json`模块提供了一组用于处理JSON格式数据的函数和类。其中，`dumps`、`dump`、`loads`、`load`是最常用的四个函数，它们的主要区别如下：- `json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False)`：将Python对象序列化为JSON格式的字符串，返回一个字符串。`dumps`函数的输出结果是一个字符串，可以直接写入文件或通过网络传输。- `json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False)`：将Python对象序列化为JSON格式的字符串，并将其写入文件对象中。`dump`函数的输出结果是将JSON格式的字符串写入文件对象中，而不是返回一个字符串。- `json.loads(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)`：将JSON格式的字符串反序列化为Python对象，返回一个对象。`loads`函数的输入是一个JSON格式的字符串，输出是一个Python对象。- `json.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)`：从文件对象中读取JSON格式的字符串，并将其反序列化为Python对象。`load`函数的输入是一个文件对象，输出是一个Python对象。总的来说，`dumps`和`dump`两个函数的区别在于输出的结果不同，`loads`和`load`两个函数的区别在于输入的数据来源不同。在使用这些函数的时候需要注意输入参数和输出结果的类型及其格式要求。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="机器学习分类算法实践"><a href="#机器学习分类算法实践" class="headerlink" title="机器学习分类算法实践"></a>机器学习分类算法实践</h5><p>核心算法：决策树，贝叶斯，SVM，逻辑回归</p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230802131217774.png" alt="image-20230802131217774"></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230802141915133.png" alt="image-20230802141915133"></p><h5 id="sum函数"><a href="#sum函数" class="headerlink" title="sum函数"></a>sum函数</h5><pre class="line-numbers language-none"><code class="language-none">这段代码定义了一个`sum`函数，它是一个方法（在类中定义的函数），可以通过类的实例进行调用。让我们解释一下这个函数以及它的参数。```pythondef sum(self, axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True):```这个函数用于计算数组元素沿指定轴(axis)的和。下面是对各个参数的解释：- `axis`: 指定进行求和操作的轴。默认为`None`，表示对整个数组进行求和。如果指定了一个整数值，表示沿着该轴进行求和。例如，`axis=0`表示按列求和，`axis=1`表示按行求和。- `dtype`: 指定返回结果的数据类型。默认为`None`，表示保持原始数组的数据类型。可以指定其他数据类型，如`int`、`float`等。- `out`: 指定用于存储结果的输出数组。默认为`None`，表示创建一个新的数组来存储结果。- `keepdims`: 指定是否保持结果数组的维度。默认为`False`，表示结果数组的维度会被压缩，即去掉长度为1的维度。如果设为`True`，则结果数组会保持和原数组相同的维度。- `initial`: 指定一个初始值，用于在求和之前累加到结果中。默认为0，表示不使用初始值。- `where`: 指定一个条件数组，用于选择参与求和的元素。默认为`True`，表示所有元素都参与求和。条件数组的形状必须与原数组相同。这个函数的具体实现没有提供，因为是从文档字符串（docstring）中恢复的签名信息。函数的实际实现可能在其他地方定义。这个函数与NumPy库中的`numpy.sum`函数具有相同的功能，可以参考`numpy.sum`函数的文档来了解更多细节。要使用这个函数，需要通过类的实例来调用，例如`array_instance.sum()`，其中`array_instance`是一个数组对象的实例。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="np-tile-函数"><a href="#np-tile-函数" class="headerlink" title="np.tile()函数"></a>np.tile()函数</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">`np<span class="token punctuation">.</span>tile`函数是NumPy库中的一个函数，用于将数组沿指定的轴重复。函数的语法如下：```pythonnp<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> reps<span class="token punctuation">)</span>```其中，`arr`是要重复的数组，`reps`是一个表示重复次数的元组。`np<span class="token punctuation">.</span>tile`函数将数组 `arr` 沿指定的轴重复 `reps` 次，生成一个新的数组。重复的方式是将数组按照指定的次数堆叠在一起。下面是一些示例来详细介绍 `np<span class="token punctuation">.</span>tile` 函数的使用：<span class="token operator">**</span>示例 <span class="token number">1</span>：重复一维数组<span class="token operator">**</span>```python<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npa <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>```输出结果：```<span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span>```在这个例子中，一维数组 `<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>` 被重复了 <span class="token number">3</span> 次，生成了一个新的一维数组 `<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>`。<span class="token operator">**</span>示例 <span class="token number">2</span>：重复二维数组<span class="token operator">**</span>```python<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npa <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>```输出结果：```<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">4</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">4</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>```在这个例子中，二维数组 `<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>` 被沿着行和列分别重复了 <span class="token number">2</span> 次和 <span class="token number">3</span> 次，生成了一个新的二维数组。<span class="token operator">**</span>示例 <span class="token number">3</span>：重复多维数组<span class="token operator">**</span>```python<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npa <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>```输出结果：```<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">]</span>  <span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">4</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span> <span class="token number">6</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">]</span>  <span class="token punctuation">[</span><span class="token number">7</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">]</span>  <span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">4</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span> <span class="token number">6</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">]</span>  <span class="token punctuation">[</span><span class="token number">7</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>```在这个例子中，三维数组 `<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>` 被沿着第一个轴重复了 <span class="token number">2</span> 次，沿着第三个轴重复了 <span class="token number">2</span> 次，生成了一个新的三维数组。`np<span class="token punctuation">.</span>tile` 函数可以用于在数组中进行重复操作，扩展数组的维度和大小。这对于构建一些特定形状的数组或者进行数组的扩展和填充非常有用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>aixs=0表示行之间，既是按照列排序；aixs=1表示按照列之间，既是按照行进行排序</p><h5 id="argsort-函数"><a href="#argsort-函数" class="headerlink" title="argsort()函数"></a>argsort()函数</h5><pre class="line-numbers language-none"><code class="language-none">`argsort()` 是 NumPy 库中的一个函数，用于返回数组排序后的索引值。它返回的索引值表示排序后的元素在原数组中的位置。函数的语法如下：```pythonnp.argsort(arr, axis=-1, kind=None, order=None)```参数说明：- `arr`: 要排序的数组。- `axis`（可选）: 沿着指定的轴进行排序，默认为最后一个轴。- `kind`（可选）: 排序算法的种类。可选值包括`'quicksort'`、`'mergesort'`、`'heapsort'`，或者使用`None`表示使用默认的排序算法。- `order`（可选）: 如果数组是结构化数据类型（如结构化数组），则可以指定要排序的字段。`argsort()` 函数返回一个与原数组形状相同的数组，其中的元素是原数组中排序后的索引值。下面是一些示例来说明 `argsort()` 函数的使用：**示例 1：一维数组排序索引**```pythonimport numpy as npa = np.array([3, 1, 2])indices = np.argsort(a)print(indices)```输出结果：```[1 2 0]```在这个例子中，一维数组 `[3, 1, 2]` 被排序后的索引值是 `[1, 2, 0]`。也就是说，索引为 1 的元素是最小的，索引为 2 的元素是第二小的，索引为 0 的元素是最大的。**示例 2：二维数组按列排序索引**```pythonimport numpy as npa = np.array([[3, 1, 2], [4, 2, 1]])indices = np.argsort(a, axis=0)print(indices)```输出结果：```[[0 0 1] [1 1 0]]```在这个例子中，二维数组 `[[3, 1, 2], [4, 2, 1]]` 按列进行排序后的索引值是 `[[0, 0, 1], [1, 1, 0]]`。也就是说，第一列中索引为 0 的元素最小，索引为 1 的元素次小；第二列中索引为 0 的元素最小，索引为 1 的元素次小；第三列中索引为 1 的元素最小，索引为 0 的元素次小。`argsort()` 函数对于排序和获取排序索引非常有用，可以方便地进行数组的排序操作，并通过索引值获取排序后的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort()函数"></a>sort()函数</h5><pre class="line-numbers language-none"><code class="language-none">sortedClassCount = sorted(classCount.items(),key=operator.itemgetter(1),reverse=True)这段代码是使用Python的内置函数`sorted`对字典`classCount`按值进行排序的示例。它将字典的键值对按照值从大到小的顺序进行排序，并将结果保存在`sortedClassCount`中。让我们逐步解释代码中的每个部分：1. `classCount.items()`: 这部分将字典`classCount`转换为一个包含键值对的元组列表。每个元组由字典中的键和对应的值组成。1. `key=operator.itemgetter(1)`: 这部分指定了用于排序的关键字。在这里，`operator.itemgetter(1)`表示按照元组的第二个元素（也就是值）进行排序。1. `reverse=True`: 这部分指定了排序的顺序。当设置为`True`时，元组按照降序排列；当设置为`False`时，元组按照升序排列。在这个例子中，设置为`True`表示按照值从大到小的顺序进行排序。1. `sorted(classCount.items(), key=operator.itemgetter(1), reverse=True)`: 这是最终的排序操作。`sorted`函数接受一个可迭代对象作为输入，并返回一个新的已排序的列表。在这里，它接受了字典`classCount.items()`作为输入，并根据指定的排序关键字和顺序对元组进行排序。最后，排序的结果被赋值给变量`sortedClassCount`，它是一个已排序的包含键值对的列表。元素按照值从大到小排列，可以按照需要进一步处理和使用这个列表。这种使用`sorted`函数的方式对于对字典按值排序是一种常见的方法，它提供了一种简单而有效的方式来获取排序后的结果。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="collections-Counter-k-labels-most-common-1"><a href="#collections-Counter-k-labels-most-common-1" class="headerlink" title="collections.Counter(k_labels).most_common(1)"></a>collections.Counter(k_labels).most_common(1)</h5><pre class="line-numbers language-none"><code class="language-none">`collections.Counter(k_labels).most_common(1)` 是一个用于统计列表 `k_labels` 中元素出现频率的操作。这段代码的执行过程如下：1. `collections.Counter(k_labels)` 创建了一个 `Counter` 对象，该对象用于统计 `k_labels` 列表中每个元素的出现次数。1. `most_common(1)` 是 `Counter` 对象的方法，它返回出现频率最高的 1 个元素及其计数。返回的结果是一个列表，其中包含一个元组，元组的第一个元素是出现频率最高的元素，第二个元素是该元素的计数。举个例子，假设 `k_labels` 是一个包含分类标签的列表：```pythonk_labels = ['A', 'B', 'C', 'A', 'A', 'B']```使用 `collections.Counter(k_labels).most_common(1)` 将返回出现频率最高的元素及其计数：```python[('A', 3)]```结果表示在 `k_labels` 列表中，元素 `'A'` 出现了 3 次，而它是出现频率最高的元素。你可以根据具体的需求进行适当的修改和使用，例如获取出现频率最高的多个元素，或者根据出现频率进行排序等。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="针对有BOM的UTF-8文本，应该去掉BOM，否则后面会引发错误。arrayOLines-0-x3D-arrayOLines-0-lstrip-‘-ufeff’"><a href="#针对有BOM的UTF-8文本，应该去掉BOM，否则后面会引发错误。arrayOLines-0-x3D-arrayOLines-0-lstrip-‘-ufeff’" class="headerlink" title="#针对有BOM的UTF-8文本，应该去掉BOM，否则后面会引发错误。arrayOLines[0]=arrayOLines[0].lstrip(‘\ufeff’)"></a>#针对有BOM的UTF-8文本，应该去掉BOM，否则后面会引发错误。arrayOLines[0]=arrayOLines[0].lstrip(‘\ufeff’)</h5><pre class="line-numbers language-none"><code class="language-none">`arrayOLines[0]=arrayOLines[0].lstrip('\ufeff')` 这行代码的作用是去掉字符串 `arrayOLines[0]` 开头的 BOM（Byte Order Mark）字符。BOM 是一种特殊的字符，用于标识文本文件的字节顺序和编码方式。在某些 UTF-8 编码的文本文件中，会在文件开头插入一个 BOM 字符，以指示文件是以 UTF-8 编码保存的。然而，有些程序或库在处理文本时可能不会正确处理 BOM 字符，会将其当作普通字符处理，导致后续的操作出错。为了避免这种问题，可以使用 `lstrip()` 方法去掉字符串开头的 BOM 字符。具体来说，`lstrip('\ufeff')` 的作用是从字符串的左侧开始移除所有的 `\ufeff` 字符。这里的 `\ufeff` 是 BOM 字符的 Unicode 编码表示。通过将 `arrayOLines[0]` 的开头的 BOM 字符去除后，可以确保后续的操作不会受到 BOM 字符的干扰，避免因 BOM 导致的错误。BOM（Byte Order Mark）字符是一种特殊的字符，用于标识文本文件的字节顺序和编码方式。它通常出现在以 Unicode 编码保存的文本文件的开头。BOM 字符的作用是向读取文件的程序或库提供关于文件编码和字节顺序的信息。它可以帮助程序正确解析和处理文本文件，尤其是当文件使用不同的 Unicode 编码（如 UTF-8、UTF-16）保存时。在 UTF-8 编码的文本文件中，BOM 字符的表示是 `\ufeff`。它通常以字节序列 `EF BB BF` 的形式出现在文件的开头，用于指示文件是以 UTF-8 编码保存的。需要注意的是，并非所有的 UTF-8 编码的文本文件都包含 BOM 字符。BOM 字符在 UTF-8 编码中是可选的，而且有些程序或库可能不支持处理 BOM 字符。因此，在处理文本文件时，特别是在不确定是否存在 BOM 字符的情况下，可能需要进行适当的处理，如去除 BOM 字符或进行编码转换。总结：BOM 字符是用于标识文本文件字节顺序和编码方式的特殊字符，通常出现在以 Unicode 编码保存的文本文件的开头。在 UTF-8 编码的文本文件中，BOM 字符的表示是 `\ufeff`。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="lstrip-函数"><a href="#lstrip-函数" class="headerlink" title="lstrip()函数"></a>lstrip()函数</h5><pre class="line-numbers language-none"><code class="language-none">`lstrip()` 是 Python 字符串对象的一个方法，用于从字符串的左侧（开头）删除指定的字符或字符集合。这个方法的名称 "lstrip" 是 "left strip" 的缩写，表示从左侧剥离或删除字符。语法：```pythonstring.lstrip([characters])```参数说明：- `characters`（可选）：指定要删除的字符或字符集合，默认为删除字符串开头的空白字符（空格、制表符等）。`lstrip()` 方法会返回一个新的字符串，其中删除了开头的指定字符或字符集合。原始字符串本身不会被修改。示例用法：```pythonstring = "   Hello, World!   "new_string = string.lstrip()  # 默认删除开头的空白字符print(new_string)  # 输出："Hello, World!   "new_string = string.lstrip("H ")  # 删除开头的字符 "H" 和空格print(new_string)  # 输出："ello, World!   "```在示例中，`lstrip()` 方法分别用于删除字符串开头的空白字符和指定的字符。可以根据具体的需求选择要删除的字符或字符集合，或者省略参数以删除默认的空白字符。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="returnMat-index-x3D-listFromLine-0-3-这个是什么意思"><a href="#returnMat-index-x3D-listFromLine-0-3-这个是什么意思" class="headerlink" title="returnMat[index,:] = listFromLine[0:3]这个是什么意思"></a>returnMat[index,:] = listFromLine[0:3]这个是什么意思</h5><pre class="line-numbers language-none"><code class="language-none">这行代码是将一个列表 (`listFromLine`) 的前三个元素赋值给一个二维数组 (`returnMat`) 的指定行 (`index`)。假设 `returnMat` 是一个二维 NumPy 数组，具有多行和三列的形状。`index` 是一个整数，表示要赋值的目标行的索引。代码解析:`listFromLine[0:3]` 表示从 `listFromLine` 列表中获取索引 0 到索引 2 的元素，即前三个元素。`returnMat[index, :]` 表示将指定行 (`index`) 的所有列都选中，形成一个切片。将 `listFromLine` 的前三个元素赋值给 `returnMat` 的指定行，可以通过以下代码实现：```pythonreturnMat[index, :] = listFromLine[0:3]```这将把 `listFromLine` 的前三个元素分别赋值给 `returnMat` 的指定行的每一列。注意，前提是 `returnMat` 必须具有足够的行数和列数来存储赋值操作的结果。例如，如果 `index` 是 2，`returnMat` 是一个形状为 (3, 3) 的数组，`listFromLine` 是包含至少三个元素的列表，那么上述代码将把 `listFromLine` 的前三个元素赋值给 `returnMat` 的第三行。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="plt-step"><a href="#plt-step" class="headerlink" title="plt.step()"></a>plt.step()</h5><pre class="line-numbers language-none"><code class="language-none">`plt.setp()`是Matplotlib中的一个函数，用于设置一个或多个对象的属性。在你提供的代码中，`axs0_title_text`是一个标题文本对象，它位于`axs[0, 0]`子图中。`plt.setp(axs0_title_text, size=9, weight='bold', color='red')`的作用是设置该标题文本的字体大小为9，字体粗细为粗体（bold），字体颜色为红色。通过这种方式，你可以使用`plt.setp()`函数对Matplotlib对象的属性进行批量设置，从而快速自定义图形的外观和样式。请注意，`axs0_title_text`对象需要是可设置属性的对象，例如标题文本对象、坐标轴对象等。如果将`plt.setp()`函数应用于不支持的对象类型，可能会导致错误。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="为什么我不加数据归一化，错误率能高16"><a href="#为什么我不加数据归一化，错误率能高16" class="headerlink" title="为什么我不加数据归一化，错误率能高16%"></a>为什么我不加数据归一化，错误率能高16%</h5><pre class="line-numbers language-none"><code class="language-none">数据归一化在机器学习中是一种常用的预处理技术，它有助于提高模型的性能和收敛速度。如果你没有对数据进行归一化，可能会导致以下几个问题：1. 不同特征的尺度不同：如果不同特征的取值范围差异很大，某些特征可能会对模型的学习产生更大的影响，而其他特征的影响则相对较小。这可能导致模型在训练过程中偏向于重要特征，而忽略了其他特征的贡献，从而影响了模型的性能。1. 算法对尺度敏感：某些机器学习算法对特征的尺度非常敏感，例如欧氏距离计算、支持向量机等。如果特征没有进行归一化，这些算法可能无法正确地衡量特征之间的相似性或权重。通过归一化，可以确保各个特征在相同的尺度上进行比较，避免尺度带来的偏差。1. 收敛速度慢：在一些优化算法中，例如梯度下降法，特征的尺度差异可能导致收敛速度变慢。如果某些特征的值范围较大，梯度下降算法需要更多的迭代才能达到最优解。通过归一化，可以加快优化算法的收敛速度。因此，数据归一化可以帮助消除特征之间的尺度差异，提高模型的性能和稳定性。在某些情况下，数据归一化可以显著降低错误率，并帮助模型更好地利用数据特征。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="cv2-imread-函数介绍"><a href="#cv2-imread-函数介绍" class="headerlink" title="cv2.imread()函数介绍"></a>cv2.imread()函数介绍</h5><pre class="line-numbers language-none"><code class="language-none">`cv2.imread`是OpenCV库中的一个函数，用于从磁盘上的图像文件中读取图像数据，并将其加载为NumPy数组。函数的基本语法如下：```pythoncv2.imread(filename, flags)```其中，`filename`是要读取的图像文件的路径，可以是绝对路径或相对路径。`flags`是一个可选参数，用于指定图像的读取方式。常用的`flags`取值如下：- `cv2.IMREAD_COLOR`：默认值，读取彩色图像，忽略图像的透明度（如果有）。- `cv2.IMREAD_GRAYSCALE`：以灰度模式读取图像。- `cv2.IMREAD_UNCHANGED`：读取图像，并包括图像的所有通道，包括透明度（如果有）。`cv2.imread`函数会返回一个包含图像数据的NumPy数组。对于彩色图像，返回的数组的形状为 `(高度, 宽度, 通道数)`，通道数为3，分别表示红色、绿色和蓝色通道。对于灰度图像，返回的数组的形状为 `(高度, 宽度)`，只有一个通道，表示灰度值。以下是一个示例：```pythonimport cv2# 读取彩色图像image_color = cv2.imread('image.jpg', cv2.IMREAD_COLOR)# 读取灰度图像image_gray = cv2.imread('image.jpg', cv2.IMREAD_GRAYSCALE)```在使用`cv2.imread`函数时，需要确保指定的图像文件路径是正确的，并且程序对该路径具有读取权限。如果路径错误或文件不存在，函数将返回空值（`None`）。因此，在使用返回值之前，建议进行错误检查。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="jieba-lcut"><a href="#jieba-lcut" class="headerlink" title="jieba.lcut()"></a>jieba.lcut()</h5><pre class="line-numbers language-none"><code class="language-none">`jieba.lcut()`是`jieba`中文分词库中的一个函数，用于对中文文本进行分词操作。该函数采用了基于统计的分词方法以及一些其他的规则和技巧来实现中文分词。下面是`jieba.lcut()`函数的分词过程简要描述：1. 加载内置的词典：`jieba.lcut()`函数在执行之前会先加载内置的中文词典。这些词典包含了常见的词汇和词语，用于基本的分词操作。1. 构建有向无环图（DAG）：根据输入的文本，`jieba.lcut()`函数会根据词典中的词语构建一个有向无环图（DAG）。DAG中的节点表示文本中的字符，边表示可能的词语。1. 应用动态规划算法：基于构建的DAG，`jieba.lcut()`函数使用动态规划算法来计算最大概率路径，以确定最可能的分词结果。在计算最大概率路径时，考虑了词语的频率、词语长度、上下文信息等因素。1. 返回分词结果：根据计算得到的最大概率路径，`jieba.lcut()`函数将文本切分成词语，并返回一个包含分词结果的列表。需要注意的是，`jieba.lcut()`函数默认使用精确模式进行分词，即尽可能多地切分出词语。此外，`jieba`库还提供了其他分词函数，如`jieba.cut()`和`jieba.lcut()`，可以根据需要选择不同的分词模式。总的来说，`jieba.lcut()`函数通过利用统计算法、动态规划和内置词典等技术，实现了对中文文本的分词操作，将文本切分成有意义的词语，并返回分词结果的列表。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的数据结构</title>
      <link href="/2023/07/15/java-zhong-de-shu-ju-jie-gou/"/>
      <url>/2023/07/15/java-zhong-de-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><ul><li>List，Set，Map都是接口，前两个继承Collection接口，Map为独立的接口。</li><li>Set下面有HashSet,LinkedHashSet,TreeSet</li><li>List下面有ArrayList,Vector,LinkedList</li><li>Map下面有Hashtable,LinkedHashMap,HashMap,TreeMap</li><li>Collection接口下面还有个Queue接口，有PriorityQueue类</li></ul><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230715155010903.png" alt="image-20230715155010903"></p><ul><li>LinkedList既可以实现Queue接口,也可以实现List接口.只不过呢, LinkedList实现了Queue接口。Queue接口窄化了对LinkedList的方法的访问权限（即在方法中的参数类型如果是Queue时，就完全只能访问Queue接口所定义的方法 了，而不能直接访问 LinkedList的非Queue的方法），以使得只有恰当的方法才可以使用。</li></ul><h5 id="List有序，可重复"><a href="#List有序，可重复" class="headerlink" title="List有序，可重复"></a>List有序，可重复</h5><p>ArrayList优点：底层数据结构是数组，查询快，增删慢。缺点线程不安全，效率高。</p><p>Vector优点：底层是数组，查询快，增删慢。缺点线程安全，效率低。</p><p>LinkedList优点：底层是链表，查询慢，增删快。缺点线程不安全，效率高。</p><h5 id="Set无序，唯一"><a href="#Set无序，唯一" class="headerlink" title="Set无序，唯一"></a>Set无序，唯一</h5><p>HashSet:底层数据结构是哈希表(无序，唯一)。如何保证元素唯一性？依赖两个方法：hashCode()和equals()。主要用来排序。</p><p>LinkedHashSet:底层数据结构是链表和哈希表。(FIFO插入有序，唯一)由链表保证元素有序，由哈希表保证元素唯一。主要用来保证FIFO有序的集合。</p><p>TreeSet:底层数据结构是红黑树。(唯一，有序）1.如何保证元素排序：自然排序，比较器排序。2.如何保证元素唯一性：根据比较的返回值是否是0来决定。通用的存储数据的集合。</p><pre class="line-numbers language-none"><code class="language-none">唯一吗?是：Set排序吗?是：TreeSet或LinkedHashSet否：HashSet如果你知道是Set，但是不知道是哪个Set，就用HashSet。否：List要安全吗?是：Vector否：ArrayList或者LinkedList查询多：ArrayList增删多：LinkedList如果你知道是List，但是不知道是哪个List，就用ArrayList。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h5><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230715161752563.png" alt="image-20230715161752563"></p><p>Map接口实现了三个重要的类，分别是HashMap、TreeMap和HashTable</p><ul><li>TreeMap是有序的，HashMap和HashTable是无序的。</li><li>Hashtable的方法是同步的，HashMap的方法不是同步的，这是两者最主要的区别。</li></ul><p>这就意味着：</p><ul><li><p>hashtable是线程安全的，HashMap不是线程安全的。</p></li><li><p>HashMap效率较高，HashTable效率较低。</p><p>如果对同步性或与遗留代码的兼容性没有任何要求，建议使用HashMap。 查看Hashtable的源代码就可以发现，除构造函数外，Hashtable的所有 public 方法声明中都有 synchronized关键字，而HashMap的源码中则没有。</p></li><li><p>Hashtable不允许null值，HashMap允许null值（key和value都允许）</p></li><li><p>父类不同：Hashtable的父类是Dictionary，HashMap的父类是AbstractMap</p></li></ul><h5 id="TreeSet的排序"><a href="#TreeSet的排序" class="headerlink" title="TreeSet的排序"></a>TreeSet的排序</h5><pre class="line-numbers language-none"><code class="language-none">1.基本数据类型可以直接排序2.引用数据类型可以使用自然排序和比较器排序2.1自然排序：例如Student类中实现Comparable接口，重写Comparable接口中的Compareto方法public class Student implements Comparable&lt;Student&gt;{private String name;private int age;public int compareTo(Student s){int num=this.name.length()-s.name.length();int num1=num==0?this.name.compareTo(s.name):num;int num2=num1==0?this.age-s.age:num1;return num2;}}2.2比较器排序：单独创建一个比较类，这里以MyComparator为例，并且要让他继承Comparator接口；重写Comparator接口中的Compare接口。public class MyComparator implements Comparator&lt;Student&gt;{public int compare(Student s1,Student s2){int num=s1.getName().length()-s2.getName().length();int num1=num==0?s1.getName().compareTo(s2.getName()):num;int num2=num1==0?s1.getAge()-s2.getAge():num2;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode</title>
      <link href="/2023/07/15/leetcode/"/>
      <url>/2023/07/15/leetcode/</url>
      
        <content type="html"><![CDATA[<h5 id="leetcode1362-最接近的因数"><a href="#leetcode1362-最接近的因数" class="headerlink" title="leetcode1362.最接近的因数"></a>leetcode1362.最接近的因数</h5><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230715104042344.png" alt="image-20230715104042344"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">closestDivisors</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> divisor<span class="token operator">=</span>num<span class="token operator">==</span><span class="token number">1</span><span class="token operator">?</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span>num<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>divisor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>divisor<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            i<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>divisor<span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">closestDivisor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>        divisor <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> num <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">else</span> num <span class="token operator">+</span> <span class="token number">2</span>        i<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>divisor<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> divisor <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>    i <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span>divisor<span class="token operator">/</span>i<span class="token punctuation">]</span><span class="token comment">#上一个好一点</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">closestDivisors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment">#------------------中心开花----------------</span>        <span class="token keyword">def</span> <span class="token function">calc</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>num <span class="token operator">**</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> num <span class="token operator">%</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> num <span class="token operator">//</span> x<span class="token punctuation">]</span>        res1 <span class="token operator">=</span> calc<span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        res2 <span class="token operator">=</span> calc<span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res1 <span class="token keyword">if</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>res1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>res1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>res2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>res2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">else</span> res2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "fmt"    "math")func closestDivisors(num int) []int {    divisor := num + 1    if num == 1 {        divisor = num + 1    } else {        divisor = num + 2    }    i := int(math.Sqrt(float64(divisor)))    for divisor%i &gt; 1 {        i--    }    return []int{i, divisor / i}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h5><pre class="line-numbers language-none"><code class="language-none">二叉搜索树（Binary Search Tree，BST）是一种基于二叉树的数据结构。它具有以下性质：1. 对于任意一个节点，它的左子树中的所有节点的值都小于该节点的值。2. 对于任意一个节点，它的右子树中的所有节点的值都大于该节点的值。3. 左右子树也分别为二叉搜索树。因此，二叉搜索树中的节点按照从小到大的顺序排列。它支持插入、删除和查找操作，它们的时间复杂度都是 O(log n)。在一些特殊情况下，二叉搜索树的高度可能会退化为链表，这时候操作的时间复杂度会退化为 O(n)。二叉搜索树可以用来实现一些高效的算法，如二叉搜索、二叉排序树、AVL树、红黑树等。它也被广泛应用于数据库、搜索引擎、文件系统等领域。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="leetcode108"><a href="#leetcode108" class="headerlink" title="leetcode108"></a>leetcode108</h5><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230715142725906.png" alt="image-20230715142725906"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">sortedArrayToVST</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>nums<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token operator">&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token class-name">TreeNode</span> root<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left<span class="token operator">=</span><span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right<span class="token operator">=</span><span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Definition for a binary tree node.</span><span class="token comment"># class TreeNode:</span><span class="token comment">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment">#         self.val = val</span><span class="token comment">#         self.left = left</span><span class="token comment">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">:</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span>TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left<span class="token operator">&gt;</span>right<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">None</span>           mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>helper<span class="token punctuation">(</span>left<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>helper<span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">return</span> helper<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/** * Definition for a binary tree node. * type TreeNode struct { *     Val int *     Left *TreeNode *     Right *TreeNode * } */</span><span class="token keyword">func</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">helper</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>left <span class="token builtin">int</span><span class="token punctuation">,</span>right <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode<span class="token punctuation">{</span>    <span class="token keyword">if</span> left<span class="token operator">&gt;</span>right<span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    mid<span class="token operator">:=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>    root<span class="token operator">:=</span><span class="token operator">&amp;</span>TreeNode<span class="token punctuation">{</span>Val<span class="token punctuation">:</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">}</span>    root<span class="token punctuation">.</span>Left<span class="token operator">=</span><span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    root<span class="token punctuation">.</span>Right<span class="token operator">=</span><span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span>    <span class="token keyword">return</span> root<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="leetcode1382"><a href="#leetcode1382" class="headerlink" title="leetcode1382"></a>leetcode1382</h5><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230715151610608.png" alt="image-20230715151610608"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> inorderSeq<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">balanceBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">getInorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>inorderSeq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getInorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> tree<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">getInorder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        inorderSeq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">getInorder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token class-name">TreeNode</span> root<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>inorderSeq<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">&lt;=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span><span class="token function">build</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;=</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span><span class="token function">build</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Definition for a binary tree node.</span><span class="token comment"># class TreeNode:</span><span class="token comment">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment">#         self.val = val</span><span class="token comment">#         self.left = left</span><span class="token comment">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>root<span class="token punctuation">,</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">==</span><span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>inOrder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>nums<span class="token punctuation">)</span>        nums<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>inOrder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>nums<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">process</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> left<span class="token operator">&gt;</span>right<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>        root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>process<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>process<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> root    <span class="token keyword">def</span> <span class="token function">balanceBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>        nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>inOrder<span class="token punctuation">(</span>root<span class="token punctuation">,</span>nums<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>process<span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/** * Definition for a binary tree node. * type TreeNode struct { *     Val int *     Left *TreeNode *     Right *TreeNode * } */</span><span class="token keyword">func</span> <span class="token function">balanceBST</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>    nums<span class="token operator">:=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">var</span> inorder <span class="token keyword">func</span><span class="token punctuation">(</span>node <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span>    inorder <span class="token operator">=</span><span class="token keyword">func</span><span class="token punctuation">(</span>node <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> node<span class="token operator">==</span><span class="token boolean">nil</span><span class="token punctuation">{</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>        nums<span class="token operator">=</span><span class="token function">append</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>node<span class="token punctuation">.</span>Val<span class="token punctuation">)</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>    <span class="token keyword">var</span> buildTree <span class="token keyword">func</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode    buildTree<span class="token operator">=</span><span class="token keyword">func</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode<span class="token punctuation">{</span>        mid<span class="token operator">:=</span><span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token number">1</span>        node<span class="token operator">:=</span><span class="token operator">&amp;</span>TreeNode<span class="token punctuation">{</span>Val<span class="token punctuation">:</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">}</span>        <span class="token keyword">if</span> l<span class="token operator">&lt;=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">{</span>            node<span class="token punctuation">.</span>Left<span class="token operator">=</span><span class="token function">buildTree</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> r<span class="token operator">&gt;=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">{</span>            node<span class="token punctuation">.</span>Right<span class="token operator">=</span><span class="token function">buildTree</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> node    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">#<span class="token constant">AVL</span>旋转平衡二叉树旋转的情况一共有<span class="token number">4</span>种情况：新加入节点为 node<span class="token punctuation">.</span>left 的左孩子， <span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span> 。直接对node节点右旋。新加入节点为 node<span class="token punctuation">.</span>left 的右孩子， <span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span> 。这时候要先对node<span class="token punctuation">.</span>left左旋，调整为<span class="token number">1</span>的情况，再进行右旋。新加入节点为 node<span class="token punctuation">.</span>right 的右孩子， <span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span> 。直接对node节点左旋。新加入节点为 node<span class="token punctuation">.</span>right 的左孩子， <span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span> 。这时候要先对node<span class="token punctuation">.</span>right右旋，调整为<span class="token number">3</span>的情况，再进行左旋。<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">balanceBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> nodeHeight<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TreeNode</span> newRoot<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TreeNode</span> node<span class="token operator">=</span>root<span class="token punctuation">;</span>        <span class="token comment">//先序遍历,利用栈很巧妙</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>node<span class="token operator">!=</span><span class="token keyword">null</span><span class="token operator">||</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                newRoot<span class="token operator">=</span><span class="token function">insert</span><span class="token punctuation">(</span>newRoot<span class="token punctuation">,</span>node<span class="token punctuation">.</span>val<span class="token punctuation">,</span>nodeHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                node<span class="token operator">=</span>node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                node<span class="token operator">=</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                node<span class="token operator">=</span>node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> newRoot<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">,</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> nodeHeight<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            root<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            nodeHeight<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">TreeNode</span> node<span class="token operator">=</span>root<span class="token punctuation">;</span>        <span class="token keyword">int</span> cmp<span class="token operator">=</span>val<span class="token operator">-</span>node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cmp<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//左子树插入</span>            node<span class="token punctuation">.</span>left<span class="token operator">=</span><span class="token function">insert</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>val<span class="token punctuation">,</span>nodeHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nodeHeight<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-</span>nodeHeight<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>val<span class="token operator">&gt;</span>node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>                    node<span class="token punctuation">.</span>left<span class="token operator">=</span><span class="token function">rotateLeft</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>nodeHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                node<span class="token operator">=</span><span class="token function">rotateLeft</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>nodeHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cmp<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            node<span class="token punctuation">.</span>right<span class="token operator">=</span><span class="token function">insert</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>val<span class="token punctuation">,</span>nodeHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nodeHeight<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-</span>nodeHeight<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>val<span class="token operator">&lt;</span>node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>                node<span class="token punctuation">.</span>right<span class="token operator">=</span><span class="token function">rotateRight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span><span class="token class-name">NodeHeight</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            node<span class="token operator">=</span><span class="token function">rotateLeft</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>nodeHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> height<span class="token operator">=</span><span class="token function">getCurNodeNewHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>nodeHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>    nodeHeight<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> nodeHeight<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">TreeNode</span> right<span class="token operator">=</span>node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>right<span class="token operator">=</span>right<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    right<span class="token punctuation">.</span>left<span class="token operator">=</span>node<span class="token punctuation">;</span>    <span class="token keyword">int</span> newNodeHeight<span class="token operator">=</span><span class="token function">getCurNodeNewHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>nodeHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>    nodeHeight<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>newNodeHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> newRightHeight<span class="token operator">=</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>newNodeHeight<span class="token punctuation">,</span>nodeHeight<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>right<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    nodeHeight<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span>newRightHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> right<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> nodeHeight<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// ---指针调整</span>        <span class="token class-name">TreeNode</span> left <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        left<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token comment">// ---高度更新</span>        <span class="token comment">// 先更新node节点的高度，这个时候node是right节点的左孩子</span>        <span class="token keyword">int</span> newNodeHeight <span class="token operator">=</span> <span class="token function">getCurNodeNewHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>nodeHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新node节点高度</span>        nodeHeight<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>newNodeHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// newNodeHeight是现在left节点右子树高度，原理一样，取现在right左右子树最大高度+1</span>        <span class="token keyword">int</span> newLeftHeight <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>newNodeHeight<span class="token punctuation">,</span>nodeHeight<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 更新原left节点高度</span>        nodeHeight<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>newLeftHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 获取当前节点的新高度     * @param node node     * @param nodeHeight node高度缓存     * @return 当前node的新高度     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getCurNodeNewHeight</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> nodeHeight<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// node节点的高度，为现在node左右子树最大高度+1</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nodeHeight<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nodeHeight<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>左旋转<img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230716112659587.png" alt="image-20230716112659587"></p><p>右旋转<img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230716112722681.png" alt="image-20230716112722681"></p><p>双旋转<img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230716112751501.png" alt="image-20230716112751501"></p><h5 id="码蹄集：永恒之2"><a href="#码蹄集：永恒之2" class="headerlink" title="码蹄集：永恒之2"></a>码蹄集：永恒之2</h5><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230803082630385.png" alt="image-20230803082630385"></p><p>分析如下：<img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230805160057816.png" alt="image-20230805160057816"></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import java.util.Scanner;class mati2181 {    public static void main(String[] args) {        long n,ans = 0;        final long mod=99999989;        Scanner input = new Scanner(System.in);        // code here        n=input.nextInt();        String s=input.next();        input.close();        long[] p=new long[15];        long[] a=new long[15];        p[0]=1;        for(int i=1;i&lt;=n;i++) {            p[i] = p[i - 1] * 16;        }        for (int i=0;i&lt;n;i++) {            if (s.charAt(i) &gt;= '0' &amp;&amp; s.charAt(i) &lt;= '9') {                a[i] = s.charAt(i) - '0';            } else {                a[i] = s.charAt(i) - 'A' + 10;            }        }        for(int i=0;i&lt;n;i++){            long pre=0;long suf=0;            for(int j=0;j&lt;=i-1;j++){                pre=pre*16+a[j];            }            for(int j=i+1;j&lt;n;j++){                suf=suf*16+a[j];            }            if(a[i]&gt;2){                ans=(ans+(pre+1)*p[(int)(n-i-1)]%mod)%mod;            }            else if(a[i]&lt;2){                ans=(ans+pre*p[(int)(n-i-1)]%mod)%mod;            }            else {                ans=(ans+suf+1+pre*p[(int)(n-i-1)]%mod)%mod;            }        }        System.out.println(ans);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">n <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>s <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>p <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">15</span>a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">15</span>ans <span class="token operator">=</span> <span class="token number">0</span>mod <span class="token operator">=</span> <span class="token number">99999989</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    pre<span class="token punctuation">,</span> suf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>        pre <span class="token operator">=</span> pre <span class="token operator">*</span> <span class="token number">16</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        suf <span class="token operator">=</span> suf <span class="token operator">*</span> <span class="token number">16</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    <span class="token keyword">if</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">:</span>        ans <span class="token operator">=</span> <span class="token punctuation">(</span>ans <span class="token operator">+</span> <span class="token punctuation">(</span>pre <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod    <span class="token keyword">elif</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>        ans <span class="token operator">=</span> <span class="token punctuation">(</span>ans <span class="token operator">+</span> pre <span class="token operator">*</span> p<span class="token punctuation">[</span>n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod    <span class="token keyword">else</span><span class="token punctuation">:</span>        ans <span class="token operator">=</span> <span class="token punctuation">(</span>ans <span class="token operator">+</span> suf <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> pre <span class="token operator">*</span> p<span class="token punctuation">[</span>n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token keyword">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> n <span class="token builtin">int</span>fmt<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token keyword">var</span> s <span class="token builtin">string</span>fmt<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span>p <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span>a <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span>ans <span class="token operator">:=</span> <span class="token number">0</span>mod <span class="token operator">:=</span> <span class="token number">99999989</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'9'</span> <span class="token punctuation">{</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'A'</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>pre<span class="token punctuation">,</span> suf <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>pre <span class="token operator">=</span> pre<span class="token operator">*</span><span class="token number">16</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">for</span> j <span class="token operator">:=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>suf <span class="token operator">=</span> suf<span class="token operator">*</span><span class="token number">16</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">if</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token punctuation">{</span>ans <span class="token operator">=</span> <span class="token punctuation">(</span>ans <span class="token operator">+</span> <span class="token punctuation">(</span>pre<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>p<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token punctuation">{</span>ans <span class="token operator">=</span> <span class="token punctuation">(</span>ans <span class="token operator">+</span> pre<span class="token operator">*</span>p<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>ans <span class="token operator">=</span> <span class="token punctuation">(</span>ans <span class="token operator">+</span> suf <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> pre<span class="token operator">*</span>p<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">}</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="码蹄集：人脑计算机"><a href="#码蹄集：人脑计算机" class="headerlink" title="码蹄集：人脑计算机"></a>码蹄集：人脑计算机</h5><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230805160648349.png" alt="image-20230805160648349"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Scanner</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// code here</span>        <span class="token keyword">int</span> n<span class="token operator">=</span>input<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>input<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">+</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        input<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Stack</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token operator">--</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> st <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                n <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int t, n;stack&lt;int&gt; st;int main() {cin &gt;&gt; t;t--;while (t--){cin &gt;&gt; n;while (n){st.push(n % 2);n = n / 2;}while (!st.empty()){cout &lt;&lt; st.top();st.pop();}cout &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">t <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t <span class="token operator">-=</span> <span class="token number">1</span><span class="token keyword">while</span> t <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    st <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">while</span> n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>        st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> n <span class="token operator">//</span> <span class="token number">2</span>    <span class="token keyword">while</span> st<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    t <span class="token operator">-=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> t <span class="token builtin">int</span>fmt<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">)</span>t<span class="token operator">--</span><span class="token keyword">for</span> t <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token keyword">var</span> n <span class="token builtin">int</span>fmt<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span>st <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">for</span> n <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>st <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> n<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span>n <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>st<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>st <span class="token operator">=</span> st<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>t<span class="token operator">--</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="码蹄集：字符串构造"><a href="#码蹄集：字符串构造" class="headerlink" title="码蹄集：字符串构造"></a>码蹄集：字符串构造</h5><p><img src="C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20230805165422526.png" alt="image-20230805165422526"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 7;int n, k, pi[N];char s[N];void prefix_function(char* s, int len) {for (int i = 1; i &lt; len; i++) {int j = pi[i - 1];while (j&gt;0&amp;&amp;s[i]!=s[j]){j = pi[j - 1];}if (s[i] == s[j]) {j++;}pi[i] = j;}}int main() {cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;prefix_function(s, n);for (int i = 1; i &lt;= k; i++) {for (int j = 0; j &lt; n - pi[n - 1]; j++) {cout &lt;&lt; s[j];}}for (int i = n - pi[n - 1]; i &lt; n; i++) {cout &lt;&lt; s[i];}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="需要学习KMP算法"><a href="#需要学习KMP算法" class="headerlink" title="需要学习KMP算法"></a>需要学习KMP算法</h5><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230810093328016.png" alt="image-20230810093328016"></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230810093827593.png" alt="image-20230810093827593"></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230810093847781.png" alt="image-20230810093847781"></p><h5 id="码蹄集2077：密码"><a href="#码蹄集2077：密码" class="headerlink" title="码蹄集2077：密码"></a>码蹄集2077：密码</h5><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230810131531236.png" alt="image-20230810131531236"></p><pre class="line-numbers language-none"><code class="language-none">def main():#code heres=input()next=build_next(s)max=find_max_repeated(next)if max==0:print("Just a legend")returnfor i in range(len(next)):if(next[i]==max):max_index=ibreakstr = ""for i in range(max_index-max+1,max_index+1):str+=s[i]print(str)def build_next(patt):next = [0]prefix_len = 0i =1while(i&lt;len(patt)):if(patt[prefix_len]==patt[i]):prefix_len+=1next.append(prefix_len)i+=1else:if prefix_len==0:next.append(0)i+=1else:prefix_len=next[prefix_len-1]return nextdef find_max_repeated(arr):counts = [0] * 1000max_num = 0for num in arr:counts[num] += 1for i in range(len(counts)):if(counts[i])&gt;1 and i&gt;max_num:max_num=ireturn max_numif __name__ == '__main__':main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="码蹄集：单条件和"><a href="#码蹄集：单条件和" class="headerlink" title="码蹄集：单条件和"></a>码蹄集：单条件和</h5><p><img src="C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20230817215843540.png" alt="image-20230817215843540"></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits/stdc++.h&gt; using namespace std;int n;unsigned int ans,a;int main( ){       cin&gt;&gt;n;    scanf("%u",&amp;ans);    for(int i=2;i&lt;=n;i++){        scanf("%u",&amp;a);        ans=~ans|a;    }    cout&lt;&lt;ans;    return 0;}C++n = int(input())ans = int(input()) &amp; 0xffffffff  # 将 ans 转换为无符号数for i in range(2, n + 1):    a = int(input()) &amp; 0xffffffff  # 将 a 转换为无符号数    ans = ~ans | aprint(ans)pythonpackage mainimport "fmt"func main() {    var n int    fmt.Scan(&amp;n)    var ans uint32    fmt.Scan(&amp;ans)    var a uint32    for i := 2; i &lt;= n; i++ {        fmt.Scan(&amp;a)        ans = ^ans | a    }    fmt.Println(ans)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="码蹄集：查找未出现的二进制"><a href="#码蹄集：查找未出现的二进制" class="headerlink" title="码蹄集：查找未出现的二进制"></a>码蹄集：查找未出现的二进制</h5><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230825111600537.png" alt="image-20230825111600537"></p><pre class="line-numbers language-none"><code class="language-none">str=input().split()str2=[]for i in range(pow(2,len(str[0]))):str2.append(format(i,"0%db"%len(str)))print(str2)result=[x for x in str2 if x not in str]print(result[0])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="码蹄集：对称三进制"><a href="#码蹄集：对称三进制" class="headerlink" title="码蹄集：对称三进制"></a>码蹄集：对称三进制</h5><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230825113907248.png" alt="image-20230825113907248"></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230825113915928.png" alt="image-20230825113915928"></p><pre class="line-numbers language-none"><code class="language-none">'''@File    :   ternary.py    @Contact :   zhangzhilong2022@gmail.com@Modify Time      @Author    @Version    @Desciption------------      -------    --------    -----------2023/8/25 11:28   huahai2022      1.0         None'''def ternary2d(str):str_len=len(str)count=0for i in range(str_len):if str[i]=="-":count+=-1*3**(str_len-1-i)if str[i]=="0":passif str[i]=="1":count+=1*3**(str_len-1-i)return countn = int(input())for i in range(n):s=input()print(ternary2d(s))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="码蹄集：三进制转化为十进制"><a href="#码蹄集：三进制转化为十进制" class="headerlink" title="码蹄集：三进制转化为十进制"></a>码蹄集：三进制转化为十进制</h5><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230825121046878.png" alt="image-20230825121046878"></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230825121100944.png" alt="image-20230825121100944"></p><pre class="line-numbers language-none"><code class="language-none">'''@File    :   d2ternary.py    @Contact :   zhangzhilong2022@gmail.com@Modify Time      @Author    @Version    @Desciption------------      -------    --------    -----------2023/8/25 11:45   huahai2022      1.0         None'''def d2ternary(str):ternary=""num=int(str)if num==0:return 0if num&gt;0:while num&gt;0:remainder=num%3if remainder==0:ternary='0'+ternarynum=num//3elif remainder==1:ternary='1'+ternarynum=num//3else:ternary='-'+ternarynum=num//3+1if num&lt;0:num=abs(num)while num&gt;0:remainder=num%3if remainder==0:ternary='0'+ternarynum=num//3elif remainder==1:ternary='1'+ternarynum=num//3else:ternary='-'+ternarynum=num//3+1ternary_list = list(ternary)for i in range(len(ternary)):if ternary[i]=='1':ternary_list[i]="-"elif ternary[i]=="-":ternary_list[i]="1"ternary="".join(ternary_list)return ternaryn=int(input())for i in range(n):s=input()print(d2ternary(s))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="码蹄集：进制的综合"><a href="#码蹄集：进制的综合" class="headerlink" title="码蹄集：进制的综合"></a>码蹄集：进制的综合</h5><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230825154233293.png" alt="image-20230825154233293"></p><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230825154322766.png" alt="image-20230825154322766"></p><pre class="line-numbers language-none"><code class="language-none">'''@File    :   excel.py@Contact :   zhangzhilong2022@gmail.com@Modify Time      @Author    @Version    @Desciption------------      -------    --------    -----------2023/8/25 12:17   huahai2022      1.0         None'''import redef num2letter(num):letter=""while num&gt;0:a=num%26if a==0:letter='Z'+letternum=num//26-1else:letter=chr(a+64)+letternum=num//26return letterdef letter2num(letter):length=len(letter)num=0for i in range(length):num+=(ord(letter[i])-64)*26**(length-i-1)return numdef A2B(s):pattern="\\d+"matchs=re.findall(pattern,s)num2=int(matchs[1])return num2letter(num2)+matchs[0]#R 12 C 3转化为C12def B2A(s):pattern=r"([A-Z]+)(\d+)"match=re.match(pattern,s)letter=match.group(1)num=match.group(2)letters="R"+num+"C"+str(letter2num(letter))return lettersn= int(input())str_list=[]for i in range(n):s=input()str_list.append(s)for i in range(n):if re.match("R[0-9]*C[0-9]*",str_list[i]) is not None:print(A2B(str_list[i]))else:print(B2A(str_list[i]))b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="码蹄集：Good-Num的数量"><a href="#码蹄集：Good-Num的数量" class="headerlink" title="码蹄集：Good Num的数量"></a>码蹄集：Good Num的数量</h5><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230830122553474.png" alt="image-20230830122553474"></p><pre class="line-numbers language-none"><code class="language-none">#思路：快速求幂的方法def fast_power(base, exponent):    result = 1    while exponent &gt; 0:        if exponent % 2 == 1:            result *= base%(10**9+7)        base *= base%(10**9+7)        exponent //= 2    return resultdef main():    #code here    k=int(input())    mid1=k//2       #表示奇数    if k%2==0:        mid2=mid1    else:        mid2=mid1+1 #表示偶数    print(fast_power(4,mid1)*fast_power(5,mid2)%(10**9+7))if __name__ == '__main__':    main();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="码蹄集：幂和"><a href="#码蹄集：幂和" class="headerlink" title="码蹄集：幂和"></a>码蹄集：幂和</h5><p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230830124348680.png" alt="image-20230830124348680"></p><pre class="line-numbers language-none"><code class="language-none">#和上面一题的思路一致def fast_power(base,exp):    res=1    while exp&gt;0:        if exp%2==1:            res*=base%(998244353)        base*=base%(998244353)        exp=exp//2    return res%998244353def main():    #code here    n=int(input())    count=0    for i in range(1,n+1):        count+=fast_power(i,i)%(998244353)    print(count%998244353)if __name__ == '__main__':    main();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="码蹄集：个数统计"><a href="#码蹄集：个数统计" class="headerlink" title="码蹄集：个数统计"></a>码蹄集：个数统计</h5><p><img src="C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20230830132826446.png" alt="image-20230830132826446"></p><pre class="line-numbers language-none"><code class="language-none">def main():    line=input()    n=int(line.split(" ")[0])    a=line.split(" ")[1]    count=1    count2=0    for i in range(1,n+1):        count=count*i    for i in str(count):        if i==a:            count2+=1    print(count2)if __name__ == '__main__':    main();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="码蹄集：个数统计2"><a href="#码蹄集：个数统计2" class="headerlink" title="码蹄集：个数统计2"></a>码蹄集：个数统计2</h5><p><img src="C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20230830132859709.png" alt="image-20230830132859709"></p><pre class="line-numbers language-none"><code class="language-none">#编写代码要规范def main():    #code here    line=input()    n=int(line.split(" ")[0])    b=line.split(" ")[1]    len_b=len(b)    count=1    for i in range(1,n+1):        count*=i    count2=0    count_str=str(count)    for i in range(len(count_str)-len_b+1):        if count_str[i:i+len_b]==b:            count2+=1    print(count2)if __name__ == '__main__':    main();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="码蹄集：快速幂"><a href="#码蹄集：快速幂" class="headerlink" title="码蹄集：快速幂"></a>码蹄集：快速幂</h5><p><img src="C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20230830135848517.png" alt="image-20230830135848517"></p><pre class="line-numbers language-none"><code class="language-none">def main():    #code here    line=input()    a,b,c=line.split(" ")    a=int(a)    b=int(b)    c=int(c)    count=1    while b&gt;0:        if b%2==1:            count*=a%c        a=a*a%c        b=b//2    print(count%c)if __name__ == '__main__':    main();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLM实现本地知识库问答项目中的一些笔记</title>
      <link href="/2023/07/10/llm-shi-xian-ben-di-zhi-shi-ku-wen-da-xiang-mu-zhong-de-yi-xie-bi-ji/"/>
      <url>/2023/07/10/llm-shi-xian-ben-di-zhi-shi-ku-wen-da-xiang-mu-zhong-de-yi-xie-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://dradon.oss-cn-hangzhou.aliyuncs.com/img/image-20230620085336168.png" alt="image-20230620085336168"></p><h5 id="AutoModel-from-pretrained"><a href="#AutoModel-from-pretrained" class="headerlink" title="AutoModel.from_pretrained()"></a>AutoModel.from_pretrained()</h5><pre class="line-numbers language-text" data-language="text"><code class="language-text">AuroModel.from_pretrained()是Hugging Face Transformers库中用于加载预训练模型的方法。它可以从本地文件、Hugging Face Hub、URL等多种来源加载预训练模型，并返回一个模型对象，用于后续的预测和训练。具体来说，AutoModel.from_pretrained()方法的参数如下：- `checkpoint`：必需参数，表示要加载的模型的名称、路径或URL。- `config`：可选参数，表示要使用的模型配置。如果未指定，会根据模型名称自动选择一个默认的配置文件。- `torch_dtype`：可选参数，表示要使用的PyTorch张量数据类型。默认为`torch.float32`，也可以设置为`torch.float16`或`torch.bfloat16`。- `trust_remote_code`：可选参数，表示是否信任从远程源加载的代码（如Hugging Face Hub）。默认为`False`，也可以设置为`True`。- `cache_dir`：可选参数，表示要使用的缓存目录。如果未指定，会使用默认的缓存目录（`~/.cache/huggingface/transformers`）。- `force_download`：可选参数，表示是否强制重新下载模型。默认为`False`，也可以设置为`True`。- `resume_download`：可选参数，表示是否从上次下载的位置恢复下载。默认为`False`，也可以设置为`True`。- `proxies`：可选参数，表示要使用的代理设置。默认为`None`，也可以设置为代理URL字符串或代理字典。- `local_files_only`：可选参数，表示是否只从本地文件加载模型。默认为`False`，也可以设置为`True`。在这段代码中，`LoaderClass.from_pretrained()`方法的第一个参数是`checkpoint`，表示要加载的模型的名称、路径或URL。第二个参数是`config`，表示要使用的模型配置，这里使用了已经加载好的`self.model_config`。第三个参数`torch_dtype`表示要使用的PyTorch张量数据类型，这里根据`self.bf16`的值选择了`torch.bfloat16`或`torch.float16`。第四个参数`trust_remote_code`表示是否信任从远程源（如Hugging Face Hub）加载的代码，这里设置为`True`。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="torch-dfloat16和torch-float16"><a href="#torch-dfloat16和torch-float16" class="headerlink" title="torch.dfloat16和torch.float16"></a>torch.dfloat16和torch.float16</h5><pre class="line-numbers language-text" data-language="text"><code class="language-text">`torch.bfloat16`和`torch.float16`是PyTorch张量的两种不同数据类型，它们在存储精度和内存占用方面有所不同。具体来说，`torch.bfloat16`是一种16位浮点数数据类型，它可以存储更大的数值范围，但精度相对较低。这种数据类型通常用于深度神经网络的训练和推理中，可以加速运算并减少内存占用。但是，由于精度较低，可能会对模型的准确性产生一定的影响。在使用`torch.bfloat16`时，需要注意数值范围的限制，以避免数值溢出或下溢的问题。而`torch.float16`是另一种16位浮点数数据类型，它可以存储较小的数值范围，但精度相对较高。这种数据类型通常用于计算机视觉、自然语言处理等任务中，可以提高模型的准确性。但是，由于存储精度较高，内存占用和计算复杂度也相应较高。因此，选择使用哪种数据类型取决于具体的任务需求和硬件限制。在使用`torch.bfloat16`时，需要注意数值范围的限制，以避免数值溢出或下溢的问题；在使用`torch.float16`时，则需要注意内存占用和计算复杂度的问题。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="from-accelerate-import-dispatch-model的解释"><a href="#from-accelerate-import-dispatch-model的解释" class="headerlink" title="from accelerate import dispatch_model的解释"></a>from accelerate import dispatch_model的解释</h5><pre class="line-numbers language-none"><code class="language-none">`dispatch_model`是`accelerate`库中的一个函数，用于根据当前硬件环境和设置自动选择加速器，以加速模型的训练和推理。具体来说，`dispatch_model`函数会根据以下几个因素自动选择加速器：1. 硬件环境：加速器的选择会根据计算机的GPU类型、数量和性能等因素进行优化。2. PyTorch版本：加速器的选择会根据使用的PyTorch版本进行优化，以最大程度地提高性能。3. 加速器类型：根据用户设置的加速器类型（例如混合精度训练、分布式训练等），选择最佳的加速器实现。使用`dispatch_model`函数可以简化模型训练和推理的代码编写，并提高模型的训练和推理效率。具体来说，你可以将模型对象传递给`dispatch_model`函数，该函数会自动选择最佳的加速器，并返回一个已经使用加速器的模型对象。例如，下面是一个使用`dispatch_model`函数进行模型训练的示例：```from accelerate import dispatch_model# 加载预训练模型model = LoaderClass.from_pretrained(checkpoint)# 自动选择加速器model, optimizer, train_loader, valid_loader = dispatch_model(model, optimizer, train_loader, valid_loader)# 训练模型for epoch in range(num_epochs):    for batch in train_loader:        ...```在这个示例中，`dispatch_model`函数会自动选择最佳的加速器，并将加速器应用到模型、优化器和数据加载器中，从而提高模型的训练效率。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="float"><a href="#float" class="headerlink" title=".float()"></a>.float()</h5><pre class="line-numbers language-none"><code class="language-none">在PyTorch中，`.float()`是`Tensor`类的一个方法，用于将`Tensor`对象转换为浮点数类型。在模型中使用`.float()`通常用于将输入数据的数据类型转换为浮点数类型，以便于模型能够正确处理数据。这是因为在PyTorch中，模型的输入和参数通常是浮点数类型，如果输入数据的数据类型与模型期望的数据类型不一致，可能会导致模型无法正确处理数据。下面是一个示例，展示了在模型中使用`.float()`方法将输入数据转换为浮点数类型：```pythonimport torch.nn as nn# 定义一个模型class MyModel(nn.Module):    def __init__(self):        super(MyModel, self).__init__()        self.conv1 = nn.Conv2d(3, 16, kernel_size=3)        self.fc1 = nn.Linear(16 * 6 * 6, 10)    def forward(self, x):        x = self.conv1(x)        x = x.view(-1, 16 * 6 * 6)        x = self.fc1(x)        return x# 实例化模型并将其移动到GPU上model = MyModel().cuda()# 定义一个输入数据input_data = torch.randn(1, 3, 32, 32)# 将输入数据转换为浮点数类型并将其移动到GPU上input_data = input_data.float().cuda()# 使用模型进行推理outputs = model(input_data)```在这个示例中，我们首先定义了一个`MyModel`模型，并将其移动到GPU上。然后，我们定义了一个输入数据`input_data`，并使用`.float()`方法将其转换为浮点数类型，并将其移动到GPU上。最后，我们使用模型对输入数据进行推理，并得到输出结果。通过将输入数据转换为浮点数类型，我们可以确保模型能够正确处理数据，并避免出现数据类型不匹配的错误。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="load-in-8bit的作用"><a href="#load-in-8bit的作用" class="headerlink" title="load_in_8bit的作用"></a>load_in_8bit的作用</h5><pre class="line-numbers language-none"><code class="language-none">load_in_8bit`是一个布尔类型的变量，通常用于控制数据加载时的精度。具体来说，如果`load_in_8bit`为True，则数据将以8位整数的形式加载，否则将以32位浮点数的形式加载。在机器学习中，为了提高模型训练和推理的效率，通常会采用低精度的数据表示方式，例如8位整数。这种方式可以减少数据的存储和传输开销，同时也可以加速计算过程。但是，低精度的数据表示方式可能会对模型的性能和精度产生一定的影响，因此需要根据具体的情况进行选择。在具体的实现中，`load_in_8bit`通常会作为一个参数传递给数据加载器或模型的构造函数，用于控制数据的加载精度。例如，在PyTorch中，可以通过设置`torch.utils.data.DataLoader`类的`dtype`参数来控制数据的加载精度。而在TensorFlow中，可以通过设置数据加载器的`dtype`参数或模型的`dtype`属性来控制数据的加载精度。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="模型对应的tokenizer"><a href="#模型对应的tokenizer" class="headerlink" title="模型对应的tokenizer"></a>模型对应的tokenizer</h5><pre class="line-numbers language-none"><code class="language-none">在自然语言处理任务中，文本数据需要被转换为数字才能被模型处理。这个转换过程被称为"tokenization"，它将原始文本分成一系列"token"，并将每个token映射到一个唯一的整数ID。模型接收这些整数ID作为输入，并使用它们来计算输出。在Hugging Face Transformers库中，每个模型都有一个对应的tokenizer，用于将输入文本转换为模型需要的格式。tokenizer将输入文本分成token，并将每个token映射到一个整数ID。tokenizer还可以执行其他的预处理步骤，例如截断、填充等等。if type(model) is transformers.LlamaForCausalLM:tokenizer = LlamaTokenizer.from_pretrained(checkpoint, clean_up_tokenization_spaces=True)回答你的问题，这段代码检查模型是否是`LlamaForCausalLM`类的实例。如果是，就使用`LlamaTokenizer`类的`from_pretrained`方法加载相应的tokenizer。这个tokenizer将输入文本分成token，并将每个token映射到一个整数ID，以便模型可以处理。在这个代码中，tokenizer的作用是将输入文本转换为模型需要的格式，以便模型可以计算输出。需要注意的是，不同的模型可能需要不同的tokenizer。如果使用错误的tokenizer，可能会导致模型无法正确处理输入数据。因此，在使用模型之前，需要确保使用正确的tokenizer对输入数据进行预处理。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="cls-x3D-get-class-from-dynamic-module-class-reference-x3D-”fnlp-x2F-moss-moon-003-sft–modeling-moss-MossForCausalLM”，-pretrained-model-name-or-path-x3D-checkpoint-什么意思"><a href="#cls-x3D-get-class-from-dynamic-module-class-reference-x3D-”fnlp-x2F-moss-moon-003-sft–modeling-moss-MossForCausalLM”，-pretrained-model-name-or-path-x3D-checkpoint-什么意思" class="headerlink" title="cls = get_class_from_dynamic_module(class_reference=”fnlp/moss-moon-003-sft–modeling_moss.MossForCausalLM”， pretrained_model_name_or_path=checkpoint)什么意思"></a>cls = get_class_from_dynamic_module(class_reference=”fnlp/moss-moon-003-sft–modeling_moss.MossForCausalLM”， pretrained_model_name_or_path=checkpoint)什么意思</h5><pre class="line-numbers language-none"><code class="language-none">这段代码的作用是从动态模块中获取一个类对象。具体来说，该函数接受两个参数：- `class_reference`：类的引用。在这个例子中，引用是 `fnlp/moss-moon-003-sft--modeling_moss.MossForCausalLM`，这意味着该函数将尝试从 `fnlp/moss-moon-003-sft--modeling_moss` 动态模块中获取一个名为 `MossForCausalLM` 的类。- `pretrained_model_name_or_path`：预训练模型的名称或路径。该参数用于实例化 `MossForCausalLM` 类的对象。该函数的实现可能类似于以下代码：```pythondef get_class_from_dynamic_module(class_reference,pretrained_model_name_or_path):    # 从类引用中获取模块名称和类名称    module_name, class_name = class_reference.rsplit(".", 1)    # 动态导入模块    module = importlib.import_module(module_name)    # 从模块中获取类对象    cls = getattr(module, class_name)    # 实例化对象并返回    return cls.from_pretrained(pretrained_model_name_or_path)```这个函数首先将类引用分解成模块名称和类名称。然后，它动态地导入模块，并从模块中获取类对象。最后，它使用给定的预训练模型名称或路径实例化类对象，并返回该对象。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="分析代码with-init-empty-weights"><a href="#分析代码with-init-empty-weights" class="headerlink" title="分析代码with init_empty_weights():"></a>分析代码with init_empty_weights():</h5><pre><code>model = LoaderClass.from_config(self.model_config,trust_remote_code = True)model.tie_weights()</code></pre><pre class="line-numbers language-none"><code class="language-none">这段代码的作用是使用一个空的权重初始化模型，然后将模型的权重绑定到模型中的所有共享层。这个操作通常用于加载已经训练好的模型的配置，但是不想使用它的权重。在这种情况下，我们可以使用一个空的权重初始化模型，然后将模型的权重绑定到模型中的共享层。这样做的好处是，可以在不使用已有模型的权重的情况下，使用已有模型的配置来构建一个新的模型。在这段代码中，`LoaderClass`是一个用于加载模型的类，`from_config`方法用于根据给定的配置创建一个新的模型对象，`trust_remote_code`参数设置为`True`表示信任远程代码，可以用于从远程加载模型。`tie_weights`方法用于将模型中的共享层绑定到一起，以便它们可以共享相同的权重，这样可以减少模型参数的数量，提高模型的训练效率。`with`语句是Python中的一个上下文管理器，用于管理资源的申请和释放。在这段代码中，`with init_empty_weights():`语句使用了一个自定义的上下文管理器`init_empty_weights()`，这个上下文管理器在进入上下文时执行一些操作，然后在退出上下文时再执行一些操作。在这里，`init_empty_weights()`上下文管理器的作用是用一个空的权重初始化模型，当退出上下文时，模型将被保存在`model`变量中。使用`with`语句的好处是，在退出上下文时，Python会自动调用上下文管理器的`__exit__()`方法，释放资源并执行一些清理操作。这样可以避免在代码中显式地调用资源释放和清理操作，从而使代码更加简洁和可读。同时，使用`with`语句还可以确保资源的正确释放，无论代码中是否出现了异常或错误，都可以保证资源被正确释放。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="在python中，模块和包的区别是什么"><a href="#在python中，模块和包的区别是什么" class="headerlink" title="在python中，模块和包的区别是什么"></a>在python中，模块和包的区别是什么</h5><pre class="line-numbers language-none"><code class="language-none">在Python中，模块和包都是组织代码的方式，但它们的作用和使用方式略有不同。模块是Python中的一个概念，它是一个包含Python代码的文件，通常以`.py`为扩展名。模块可以包含定义变量、函数、类和语句的代码，可以被其他模块或程序导入和使用。在Python中，可以使用`import`语句导入一个模块，并使用模块中定义的变量、函数和类等。包是Python中另一个概念，它是一个包含多个模块的目录。包通常包含一个特殊的`__init__.py`文件，用于指定包的初始化代码和导入的模块列表。在Python中，可以使用`import`语句导入一个包，也可以使用`from ... import`语句导入一个包中的模块、变量、函数和类等。因此，模块和包的区别在于：1. 模块是一个文件，包含Python代码；包是一个目录，包含多个模块和一个`__init__.py`文件。2. 模块通常包含一些特定的功能，可以被其他模块或程序导入和使用；包通常包含多个相关的模块，用于组织和管理代码。3. 在Python中，可以使用`import`语句导入一个模块或包，但是导入包时需要指定具体的模块或子包名称。需要注意的是，模块和包是Python中非常重要的概念，可以帮助我们更好地组织和管理代码。在实际编程中，应该根据需要合理地使用模块和包，以提高代码的可读性、可维护性和可重用性。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="logging文件日志"><a href="#logging文件日志" class="headerlink" title="logging文件日志"></a>logging文件日志</h5><pre class="line-numbers language-none"><code class="language-none">在 Python 中，可以使用 `logging` 模块来输出日志。该模块提供了一种灵活且可定制的方式来记录日志信息，并可以控制日志的输出级别、格式和目标等。下面是一个简单的示例，演示如何使用 `logging` 模块输出日志：```pythonimport logging# 配置日志信息logging.basicConfig(filename='example.log', level=logging.DEBUG, format='%(asctime)s %(levelname)s %(message)s')# 输出日志信息logging.debug('This is a debug message')logging.info('This is an info message')logging.warning('This is a warning message')logging.error('This is an error message')logging.critical('This is a critical message')```在上面的示例中，我们首先使用 `basicConfig()` 方法配置了日志信息，指定了日志文件的名称为 `example.log`，日志级别为 `DEBUG`，日志格式为 `%(asctime)s %(levelname)s %(message)s`。然后，我们使用 `logging` 模块的不同方法输出不同级别的日志信息。输出的日志信息将被写入到指定的日志文件中，并且根据配置的日志级别，只有等于或高于该级别的日志信息才会被输出。例如，在上面的示例中，由于指定的日志级别为 `DEBUG`，因此所有级别的日志信息都会被输出到日志文件中。当然，您还可以根据需要进一步配置日志信息，如指定日志文件的最大大小、备份数量等，以及将日志信息输出到标准输出、邮件等目标。更多关于 `logging` 模块的详细信息可以参考官方文档：https://docs.python.org/3/library/logging.html。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="向量库生成中FAISS类探究"><a href="#向量库生成中FAISS类探究" class="headerlink" title="向量库生成中FAISS类探究"></a>向量库生成中FAISS类探究</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">    <span class="token comment">#FAISS向量的初始化</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>        embedding_function<span class="token punctuation">:</span> Callable<span class="token punctuation">,</span>  <span class="token comment">#一个可以调用的对象(函数或者方法)，用于将文本转化为向量</span>        index<span class="token punctuation">:</span> Any<span class="token punctuation">,</span>       <span class="token comment">#向量索引库，用于存储向量和实现检索功能</span>        docstore<span class="token punctuation">:</span> Docstore<span class="token punctuation">,</span>   <span class="token comment">#文本存储库，用于存储原始文本和文本的元数据信息</span>        index_to_docstore_id<span class="token punctuation">:</span> Dict<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token comment">#一个字典，用于将向量索引库的ID映射到文本存储库中的ID</span>        relevance_score_fn<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>             Callable<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">]</span>        <span class="token punctuation">]</span> <span class="token operator">=</span> _default_relevance_score_fn<span class="token punctuation">,</span>    <span class="token comment">#一个可调用对象(函数或者方法)，用于计算检索结果的相关性得分(可选参数，默认为内置的相关性得分函数)</span>        normalize_L2<span class="token punctuation">:</span> <span class="token builtin">bool</span> <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">,</span>      <span class="token comment">#是否对向量进行L2归一化</span>    <span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Initialize with necessary components."""</span>        self<span class="token punctuation">.</span>embedding_function <span class="token operator">=</span> embedding_function        self<span class="token punctuation">.</span>index <span class="token operator">=</span> index        self<span class="token punctuation">.</span>docstore <span class="token operator">=</span> docstore        self<span class="token punctuation">.</span>index_to_docstore_id <span class="token operator">=</span> index_to_docstore_id        self<span class="token punctuation">.</span>relevance_score_fn <span class="token operator">=</span> relevance_score_fn        self<span class="token punctuation">.</span>_normalize_L2 <span class="token operator">=</span> normalize_L2        <span class="token comment">###index如何指定和定义</span>IndexFlatL2：基于 L2 距离度量的 Flat 索引，适用于小规模的向量检索和精确检索。IndexIVFFlat：基于倒排索引（Inverted File）的 Flat 索引，适用于大规模的向量检索和近似检索。IndexIVFPQ：基于倒排索引和 Product Quantization 的索引，适用于大规模的向量检索和高效的近似检索。eg<span class="token punctuation">:</span><span class="token keyword">import</span> faissd <span class="token operator">=</span> <span class="token number">128</span>  <span class="token comment"># 向量维度</span>index <span class="token operator">=</span> faiss<span class="token punctuation">.</span>IndexFlatL2<span class="token punctuation">(</span>d<span class="token punctuation">)</span>    在上面的代码中，我们首先定义了向量的维度 d，然后使用 faiss<span class="token punctuation">.</span>IndexFlatL2 类创建了一个基于 L2 距离度量的 Flat 索引，并将其赋值给变量 index。这个索引对象可以用来存储向量和进行精确的向量检索。<span class="token comment">###</span><span class="token comment">###方法</span><span class="token keyword">def</span> <span class="token function">add_texts</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>        texts<span class="token punctuation">:</span> Iterable<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        metadatas<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">dict</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        ids<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        <span class="token operator">**</span>kwargs<span class="token punctuation">:</span> Any<span class="token punctuation">,</span>    <span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    向索引中添加文本数据。    :param texts: 一个包含多个文本的可迭代对象，每个元素表示一个文本。    :param metadatas: 一个可选的列表，表示每个文本的元数据。每个元素是一个字典，包含文本的其它属性信息。    :param ids: 一个可选的列表，表示每个文本的 ID。如果不提供，则默认为 0, 1, 2, ...    :param kwargs: 其它可选参数，用于控制文本处理和特征提取的过程。    :return: 一个包含每个文本的 ID 的列表。    """</span>    生成向量的方式：embeddings <span class="token operator">=</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>embedding_function<span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token keyword">for</span> text <span class="token keyword">in</span> texts<span class="token punctuation">]</span>   <span class="token comment">#预训练的模型，用的Transformer</span>    vector <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>embeddings<span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>                <span class="token comment">###</span><span class="token keyword">def</span> <span class="token function">add_embeddings</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>        text_embeddings<span class="token punctuation">:</span> Iterable<span class="token punctuation">[</span>Tuple<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> List<span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        metadatas<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">dict</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        ids<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        <span class="token operator">**</span>kwargs<span class="token punctuation">:</span> Any<span class="token punctuation">,</span>    <span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    向索引中添加文本特征向量数据。    :param text_embeddings: 一个包含多个文本特征向量的可迭代对象，每个元素是一个元组 (text, embedding)，表示一个文本和其对应的特征向量。    :param metadatas: 一个可选的列表，表示每个文本的元数据。每个元素是一个字典，包含文本的其它属性信息。    :param ids: 一个可选的列表，表示每个文本的 ID。如果不提供，则默认为 0, 1, 2, ...    :param kwargs: 其它可选参数，用于控制特征处理和特征提取的过程。    :return: 一个包含每个文本的 ID 的列表。    """</span>                    <span class="token comment">###</span><span class="token keyword">def</span> <span class="token function">similarity_search_with_score_by_vector</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>        embedding<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        k<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>        <span class="token builtin">filter</span><span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>Dict<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> Any<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        fetch_k<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span>        <span class="token operator">**</span>kwargs<span class="token punctuation">:</span> Any<span class="token punctuation">,</span>    <span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>Tuple<span class="token punctuation">[</span>Document<span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    根据输入的特征向量进行相似度检索，并返回文本列表及其与输入向量的相似度得分。    :param embedding: 一个包含文本特征向量的列表，表示输入的特征向量。    :param k: 一个整数，表示需要检索的最近邻近似度数量。    :param filter: 一个可选的字典，表示需要过滤的条件。字典的键表示过滤条件，值表示过滤条件对应的值。    :param fetch_k: 一个整数，表示需要从索引中获取的文本数量。    :param kwargs: 其它可选参数，用于控制特征处理和特征提取的过程。    :return: 一个包含元组的列表，每个元组表示一个检索到的文本及其与输入向量的相似度得分。    """</span><span class="token operator">**</span><span class="token operator">*</span>注意<span class="token operator">**</span><span class="token operator">*</span>`k` 和 `fetch_k` 参数并不直接冲突，因为它们控制的是不同的内容。`k` 参数控制的是需要检索的最近邻近似度数量，而 `fetch_k` 参数控制的是需要从索引中获取的文本数量。在进行相似度检索时，首先会从索引中获取 `fetch_k` 个文本，然后从这些文本中选择与输入向量相似度最高的 `k` 个文本。例如，如果 `k<span class="token operator">=</span><span class="token number">4</span>`，`fetch_k<span class="token operator">=</span><span class="token number">20</span>`，则表示需要从索引中获取与输入向量相似度最高的 <span class="token number">20</span> 个文本，然后再从这 <span class="token number">20</span> 个文本中选择与输入向量相似度最高的 <span class="token number">4</span> 个文本。实际上，`fetch_k` 的取值可以比 `k` 大，这样可以保证在选择与输入向量相似度最高的 `k` 个文本时，有更多的文本可供选择，从而提高检索的准确性。但是，设置过大的 `fetch_k` 值可能会影响检索效率和内存消耗，需要根据具体情况进行调整。这个方法是对上面similarity_search_with_score_by_vector的封装。<span class="token keyword">def</span> <span class="token function">similarity_search_with_score</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>        query<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span>        k<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>        <span class="token builtin">filter</span><span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>Dict<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> Any<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        fetch_k<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span>        <span class="token operator">**</span>kwargs<span class="token punctuation">:</span> Any<span class="token punctuation">,</span>    <span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>Tuple<span class="token punctuation">[</span>Document<span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    根据输入的文本进行相似度检索，并返回文本列表及其与输入文本的相似度得分。    :param query: 一个字符串，表示输入的文本。    :param k: 一个整数，表示需要检索的最近邻近似度数量。    :param filter: 一个可选的字典，表示需要过滤的条件。字典的键表示过滤条件，值表示过滤条件对应的值。    :param fetch_k: 一个整数，表示需要从索引中获取的文本数量。    :param kwargs: 其它可选参数，用于控制特征处理和特征提取的过程。    :return: 一个包含元组的列表，每个元组表示一个检索到的文本及其与输入文本的相似度得分。    """</span><span class="token builtin">filter</span> 参数是一个可选的字典，表示需要过滤的条件。字典的键表示过滤条件，值表示过滤条件对应的值。例如，可以使用 <span class="token builtin">filter</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'category'</span><span class="token punctuation">:</span> <span class="token string">'sports'</span><span class="token punctuation">}</span> 来过滤类别为 <span class="token string">'sports'</span> 的文本。<span class="token comment">#查询得分</span><span class="token keyword">for</span> doc<span class="token punctuation">,</span> score <span class="token keyword">in</span> results<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>doc<span class="token punctuation">.</span>text<span class="token punctuation">,</span> score<span class="token punctuation">)</span>                <span class="token comment">###</span><span class="token keyword">def</span> <span class="token function">similarity_search_by_vector</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>        embedding<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        k<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>        <span class="token builtin">filter</span><span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>Dict<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> Any<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        fetch_k<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span>        <span class="token operator">**</span>kwargs<span class="token punctuation">:</span> Any<span class="token punctuation">,</span>    <span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>Document<span class="token punctuation">]</span><span class="token punctuation">:</span>    embedding：一个浮点数列表，表示查询向量的嵌入（embedding）。k：一个整数，表示要返回的最相似文档的数量。默认为 <span class="token number">4</span>。<span class="token builtin">filter</span>：一个字典，表示要过滤的文档属性。该字典的键值对表示要过滤的属性和其对应的值。默认   为 <span class="token boolean">None</span>，表示不进行过滤。fetch_k：一个整数，表示要从倒排索引中检索的文档数量。默认为 <span class="token number">20</span>。<span class="token operator">**</span>kwargs：一个可变关键字参数，表示其他参数        这个方法的实现依据similarity_search_with_score方法，不过只取出了前面部分<span class="token keyword">def</span> <span class="token function">similarity_search</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>        query<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span>        k<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>        <span class="token builtin">filter</span><span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>Dict<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> Any<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        fetch_k<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span>        <span class="token operator">**</span>kwargs<span class="token punctuation">:</span> Any<span class="token punctuation">,</span>    <span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>Document<span class="token punctuation">]</span><span class="token punctuation">:</span>    query：一个字符串，表示查询的文本。k：一个整数，表示要返回的最相似文档的数量。默认为 <span class="token number">4</span>。<span class="token builtin">filter</span>：一个字典，表示要过滤的文档属性。该字典的键值对表示要过滤的属性和其对应的值。默认为 <span class="token boolean">None</span>，表示不进行过滤。fetch_k：一个整数，表示要从倒排索引中检索的文档数量。默认为 <span class="token number">20</span>。<span class="token operator">**</span>kwargs：一个可变关键字参数，表示其他参数。        <span class="token comment">###</span><span class="token keyword">def</span> <span class="token function">max_marginal_relevance_search_by_vector</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>        embedding<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        k<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>        fetch_k<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span>        lambda_mult<span class="token punctuation">:</span> <span class="token builtin">float</span> <span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">,</span>        <span class="token builtin">filter</span><span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>Dict<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> Any<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>        <span class="token operator">**</span>kwargs<span class="token punctuation">:</span> Any<span class="token punctuation">,</span>    <span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>Document<span class="token punctuation">]</span><span class="token punctuation">:</span>    embedding：一个浮点数列表，表示查询向量的嵌入（embedding）。k：一个整数，表示要返回的最相似文档的数量。默认为 <span class="token number">4</span>。fetch_k：一个整数，表示要从倒排索引中检索的文档数量。默认为 <span class="token number">20</span>。lambda_mult：一个浮点数，表示查询向量和文档向量之间的权重。默认为 <span class="token number">0.5</span>。<span class="token builtin">filter</span>：一个字典，表示要过滤的文档属性。该字典的键值对表示要过滤的属性和其对应的值。默认为 <span class="token boolean">None</span>，表示不进行过滤。<span class="token operator">**</span>kwargs：一个可变关键字参数，表示其他参数。             <span class="token operator">**</span><span class="token operator">*</span>该函数的算法        当我们需要在一个文档集合中进行相似度搜索时，我们可以使用倒排索引等技术来快速定位与查询文本或向量最相似的文档。然而，仅仅根据相似度来排序文档列表并不一定能得到最好的结果。例如，在一个新闻搜索引擎中，如果用户查询 <span class="token string">"巴西足球"</span>，我们可能会得到很多相关的新闻文章，但这些文章之间可能会有很多重复的内容和观点，这样就不能满足用户的需求。为了解决这个问题，我们可以使用最大边际相关性 <span class="token punctuation">(</span>MMR<span class="token punctuation">)</span> 算法来对文档列表进行排序和筛选。MMR 算法通过将查询向量和已经选择的文档向量之间的相似度进行权衡，选择与查询向量最相关且彼此之间不太相似的文档。这样，我们可以得到一组有代表性、多样性和相关性的文档列表，从而更好地满足用户的需求。具体来说，在实现 `max_marginal_relevance_search_by_vector` 函数时，我们可以按照以下步骤进行：<span class="token number">1.</span> 使用倒排索引查找与查询向量最相似的文档，并将它们按相似度从高到低排列。<span class="token number">2.</span> 初始化一个文档列表 `selected_docs`，其中包含与查询向量最相似的前 `k` 个文档。<span class="token number">3.</span> 对于剩余的文档，计算它们与查询向量的相似度和它们与已选择文档的相似度，并计算它们的 MMR 值。MMR 值可以通过以下公式计算：   ````   MMR<span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">=</span> λ × sim<span class="token punctuation">(</span>d<span class="token punctuation">,</span> q<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> λ<span class="token punctuation">)</span> × <span class="token builtin">max</span><span class="token punctuation">(</span>sim<span class="token punctuation">(</span>d<span class="token punctuation">,</span> d<span class="token string">') for d'</span> <span class="token keyword">in</span> selected_docs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>其中，`d` 表示当前文档，`q` 表示查询向量，`λ` 表示查询向量和文档向量之间的权重，`sim(d, q)` 表示文档 `d` 和查询向量 `q` 之间的相似度，`sim(d, d')` 表示文档 `d` 和已选择文档 `d'` 之间的相似度。</code></pre><p>   公式的意义是，选择与查询向量最相关的文档，并减少与已选择文档之间的相似度，从而得到与查询向量最相关且彼此之间不太相似的文档。<br>4. 将剩余文档按照 MMR 值从高到低排序，并选择前 <code>k</code> 个文档加入 <code>selected_docs</code> 中。<br>5. 返回 <code>selected_docs</code>。</p><p>需要注意的是，MMR 算法的性能和效果受到参数 <code>λ</code> 的影响。当 <code>λ</code> 的值较小时，算法更加注重文档之间的多样性，而当 <code>λ</code> 的值较大时，算法更加注重文档与查询的相似度。在实践中，可以根据具体的应用场景和用户需求来调整 <code>λ</code> 的值。</p><p>def max_marginal_relevance_search(<br>        self,<br>        query: str,<br>        k: int = 4,<br>        fetch_k: int = 20,<br>        lambda_mult: float = 0.5,<br>        filter: Optional[Dict[str, Any]] = None,<br>        **kwargs: Any,<br>    ) -&gt; List[Document]:</p><p>参数：</p><ul><li><code>query</code>：一个字符串，表示查询文本。</li><li><code>k</code>：一个整数，表示要返回的最相似文档的数量。默认为 4。</li><li><code>fetch_k</code>：一个整数，表示要从倒排索引中检索的文档数量。默认为 20。</li><li><code>lambda_mult</code>：一个浮点数，表示查询向量和文档向量之间的权重。默认为 0.5。</li><li><code>filter</code>：一个字典，表示要过滤的文档属性。该字典的键值对表示要过滤的属性和其对应的值。默认为 <code>None</code>，表示不进行过滤。</li><li><code>**kwargs</code>：一个可变关键字参数，表示其他参数。</li></ul><p>返回值：</p><ul><li>一个 <code>List[Document]</code> 类型的列表，表示与查询文本最相关的文档列表。该列表中的每个元素都是一个 <code>Document</code> 对象，包含与查询文本最相关的文档的信息，例如文本、得分、ID 等。</li></ul><p>具体来说，该函数的作用与 <code>max_marginal_relevance_search_by_vector</code> 函数类似，不同之处在于它接受一个查询文本而不是查询向量作为输入，并将查询文本转换为向量后调用 <code>max_marginal_relevance_search_by_vector</code> 函数来实现相似度搜索和检索。在函数内部，可以使用语言模型或词嵌入模型将查询文本转换为向量，然后将向量传递给 <code>max_marginal_relevance_search_by_vector</code> 函数进行后续处理。该函数通常用于在文档集合中进行相似度搜索和检索。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>def merge_from(self, target: FAISS) -&gt; None:</p><p>这是一个方法名为 merge_from 的函数，它定义在一个名为 FAISS 的对象中。这个函数的作用是将另一个 FAISS 对象合并进当前对象。</p><p>具体来说，当我们需要将两个 FAISS 对象合并成一个时，可以使用 merge_from 方法。该方法的参数 target 是一个 FAISS 对象，表示要合并进当前对象的目标对象。合并后，目标对象的文档将被添加到当前对象的文档存储器 (docstore) 中，并且目标对象的索引 (index) 将被合并到当前对象的索引中。<br>###</p><pre><code>                                                                           def __from(  cls,  texts: List[str],  embeddings: List[List[float]],  embedding: Embeddings,  metadatas: Optional[List[dict]] = None,  ids: Optional[List[str]] = None,  normalize_L2: bool = False,  **kwargs: Any,</code></pre><p>  ) -&gt; FAISS:<br>                                                                                 这是一个类方法，用于从文本和嵌入列表中构建一个 <code>FAISS</code> 对象。该函数的参数如下：</p><ul><li><code>cls</code>：类本身。</li><li><code>texts</code>：一个字符串列表，包含待索引的文本。</li><li><code>embeddings</code>：一个浮点数列表的列表，表示每个文本对应的嵌入向量。</li><li><code>embedding</code>：一个 <code>Embeddings</code> 对象，表示用于生成嵌入向量的嵌入器。</li><li><code>metadatas</code>：一个字典列表，包含每个文档的元数据。默认为 <code>None</code>。</li><li><code>ids</code>：一个字符串列表，表示每个文档的唯一标识符。默认为 <code>None</code>。</li><li><code>normalize_L2</code>：一个布尔值，表示是否对嵌入向量进行L2范数归一化。默认为 <code>False</code>。</li><li><code>**kwargs</code>：一个可变关键字参数，表示其他参数。</li></ul><p>返回值：一个 <code>FAISS</code> 对象，表示构建的索引。</p><p>该方法的作用是将文本列表和嵌入列表转换为 <code>FAISS</code> 对象，以进行相似度搜索和检索。在函数内部，可以使用 <code>embedding</code> 对象将文本转换为嵌入向量，然后将嵌入向量传递给 <code>FAISS</code> 对象进行索引和搜索。</p><p>具体而言，该函数首先创建一个 <code>FAISS</code> 对象，并将嵌入向量添加到索引中。如果指定了元数据和文档 ID，则将它们与嵌入向量一起添加到索引中。为了快速搜索，该方法会对嵌入向量进行 L2 范数归一化，这可以提高搜索效率和准确性。</p><p>最后，该方法返回创建的 <code>FAISS</code> 对象。你可以使用该对象执行相似度搜索和检索，并获取与查询文本最相关的文档列表。<br>                                                                               ###<br>def from_texts(<br>        cls,<br>        texts: List[str],<br>        embedding: Embeddings,<br>        metadatas: Optional[List[dict]] = None,<br>        ids: Optional[List[str]] = None,<br>        **kwargs: Any,<br>    ) -&gt; FAISS:<br>                                                                                  使用上一个方法的__from进行实现<br>                                                                               这是一个类方法，用于从文本列表中构建一个 <code>FAISS</code> 对象。该函数的参数如下：</p><ul><li><code>cls</code>：类本身。</li><li><code>texts</code>：一个字符串列表，包含待索引的文本。</li><li><code>embedding</code>：一个 <code>Embeddings</code> 对象，表示用于生成嵌入向量的嵌入器。</li><li><code>metadatas</code>：一个字典列表，包含每个文档的元数据。默认为 <code>None</code>。</li><li><code>ids</code>：一个字符串列表，表示每个文档的唯一标识符。默认为 <code>None</code>。</li><li><code>**kwargs</code>：一个可变关键字参数，表示其他参数。</li></ul><p>返回值：一个 <code>FAISS</code> 对象，表示构建的索引。</p><p>该方法的作用是将文本列表转换为 <code>FAISS</code> 对象，以进行相似度搜索和检索。在函数内部，可以使用 <code>embedding</code> 对象将文本转换为嵌入向量，然后将嵌入向量传递给 <code>FAISS</code> 对象进行索引和搜索。</p><p>具体而言，该函数首先使用 <code>embedding</code> 对象将文本列表转换为嵌入向量列表。然后，创建一个 <code>FAISS</code> 对象，并将嵌入向量添加到索引中。如果指定了元数据和文档 ID，则将它们与嵌入向量一起添加到索引中。为了快速搜索，该方法会对嵌入向量进行 L2 范数归一化，这可以提高搜索效率和准确性。</p><p>最后，该方法返回创建的 <code>FAISS</code> 对象。你可以使用该对象执行相似度搜索和检索，并获取与查询文本最相关的文档列表。</p><pre><code>                                                                           ###</code></pre><p>def from_embeddings(<br>        cls,<br>        text_embeddings: List[Tuple[str, List[float]]],<br>        embedding: Embeddings,<br>        metadatas: Optional[List[dict]] = None,<br>        ids: Optional[List[str]] = None,<br>        **kwargs: Any,<br>    ) -&gt; FAISS:                                                               这是一个类方法，用于从文本嵌入元组列表中构建一个 <code>FAISS</code> 对象。该函数的参数如下：</p><ul><li><code>cls</code>：类本身。</li><li><code>text_embeddings</code>：一个元组列表，包含每个文本的唯一标识符和对应的嵌入向量。</li><li><code>embedding</code>：一个 <code>Embeddings</code> 对象，表示用于生成嵌入向量的嵌入器。</li><li><code>metadatas</code>：一个字典列表，包含每个文档的元数据。默认为 <code>None</code>。</li><li><code>ids</code>：一个字符串列表，表示每个文档的唯一标识符。默认为 <code>None</code>。</li><li><code>**kwargs</code>：一个可变关键字参数，表示其他参数。</li></ul><p>返回值：一个 <code>FAISS</code> 对象，表示构建的索引。</p><p>该方法的作用是将文本嵌入元组列表转换为 <code>FAISS</code> 对象，以进行相似度搜索和检索。在函数内部，可以使用 <code>embedding</code> 对象将嵌入向量添加到 <code>FAISS</code> 对象的索引中。</p><p>具体而言，该函数首先创建一个 <code>FAISS</code> 对象，并将嵌入向量添加到索引中。如果指定了元数据和文档 ID，则将它们与嵌入向量一起添加到索引中。为了快速搜索，该方法会对嵌入向量进行 L2 范数归一化，这可以提高搜索效率和准确性。</p><p>最后，该方法返回创建的 <code>FAISS</code> 对象。你可以使用该对象执行相似度搜索和检索，并获取与查询文本最相关的文档列表。</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><pre><code>                                                                           def save_local(self, folder_path: str, index_name: str = "index") -&gt; None:</code></pre><p>这是一个实例方法，用于将 <code>FAISS</code> 对象保存到本地文件夹。该函数的参数如下：</p><ul><li><code>folder_path</code>：一个字符串，表示本地文件夹的路径，用于保存索引文件。</li><li><code>index_name</code>：一个字符串，表示索引文件的名称。默认为 <code>"index"</code>。</li></ul><p>该方法的作用是将 <code>FAISS</code> 对象保存到本地文件夹中，以便在以后的时间内进行加载和使用。在函数内部，该方法使用 <code>faiss.write_index</code> 函数将索引对象写入文件，并保存到指定的文件夹中。</p><p>具体而言，该方法首先检查文件夹是否存在，如果不存在，则创建一个新的文件夹。然后，使用 <code>faiss.write_index</code> 函数将索引对象写入文件，并将文件保存到指定的文件夹中。保存的索引文件可以在以后的时间内使用 <code>load_local</code> 方法加载。</p><p>最后，该方法返回 <code>None</code>。<br>                                                                               ###<br>def load_local(<br>        cls, folder_path: str, embeddings: Embeddings, index_name: str = “index”<br>    ) -&gt; FAISS:<br>                                                                               这是一个类方法，用于从本地文件夹中加载 <code>FAISS</code> 索引对象。该函数的参数如下：</p><ul><li><code>cls</code>：类本身。</li><li><code>folder_path</code>：一个字符串，表示本地文件夹的路径，用于加载索引文件。</li><li><code>embeddings</code>：一个 <code>Embeddings</code> 对象，表示用于生成嵌入向量的嵌入器。</li><li><code>index_name</code>：一个字符串，表示索引文件的名称。默认为 <code>"index"</code>。</li></ul><p>返回值：一个 <code>FAISS</code> 对象，表示已加载的索引。</p><p>该方法的作用是从本地文件夹中加载 <code>FAISS</code> 索引对象，并返回该对象以供使用。在函数内部，该方法使用 <code>faiss.read_index</code> 函数从文件中读取索引对象，并使用 <code>embeddings</code> 对象生成嵌入向量。然后，将嵌入向量添加到索引中，并返回创建的 <code>FAISS</code> 索引对象。</p><p>具体而言，该方法首先使用 <code>faiss.read_index</code> 函数从指定的文件夹中读取索引对象。然后，使用 <code>embeddings</code> 对象将存储在索引中的嵌入向量重新生成，并将它们添加到索引对象中。最后，该方法返回创建的 <code>FAISS</code> 对象，以供进行文本检索和相似度搜索。</p><p>需要注意的是，加载的索引对象必须与嵌入器对象 <code>embeddings</code> 兼容，即索引对象和嵌入器对象必须使用相同的嵌入策略和参数。否则，在进行文本检索和相似度搜索时可能会导致不准确的结果。</p><h3 id="def-similarity-search-with-relevance-scores"><a href="#def-similarity-search-with-relevance-scores" class="headerlink" title="def _similarity_search_with_relevance_scores("></a>def _similarity_search_with_relevance_scores(</h3><pre><code>    self,    query: str,    k: int = 4,    filter: Optional[Dict[str, Any]] = None,    fetch_k: int = 20,    **kwargs: Any,) -&gt; List[Tuple[Document, float]]:                                                                           </code></pre><p>这是一个私有方法，用于执行带有相关度得分的相似度搜索。该函数的参数如下：</p><ul><li><code>query</code>：一个字符串，表示查询文本。</li><li><code>k</code>：一个整数，表示每个查询的返回文档数。默认为 <code>4</code>。</li><li><code>filter</code>：一个字典，表示用于过滤搜索结果的过滤器。默认为 <code>None</code>。</li><li><code>fetch_k</code>：一个整数，表示在过滤之后要返回的文档数。默认为 <code>20</code>。</li><li><code>**kwargs</code>：一个可变关键字参数，表示其他参数。</li></ul><p>返回值：一个元组列表，表示查询文本与每个返回文档的相关度得分。</p><p>该方法的作用是执行带有相关度得分的相似度搜索，并返回与查询文本最相关的文档列表。在函数内部，该方法使用 <code>faiss.StandardGpuResources</code> 创建 GPU 资源，并使用 <code>embeddings</code> 对象将查询文本转换为嵌入向量。然后，使用 <code>faiss.Index.search</code> 函数执行相似度搜索，并根据相似度得分对搜索结果进行排序。最后，该方法返回查询文本与每个返回文档的相关度得分，并将它们封装为元组列表。</p><p>具体而言，该方法首先使用 <code>faiss.StandardGpuResources</code> 创建 GPU 资源，并使用 <code>embeddings</code> 对象将查询文本转换为嵌入向量。然后，使用 <code>faiss.Index.search</code> 函数执行相似度搜索，并获取与查询文本最相关的文档列表。在获取文档列表后，该方法对返回文档进行排序，并计算每个文档的相关度得分。如果指定了过滤器，则使用过滤器从搜索结果中过滤文档。最后，该方法将查询文本与每个返回文档的相关度得分封装为元组，并返回元组列表。</p><p>需要注意的是，该方法使用 GPU 资源执行相似度搜索，因此需要确保计算机上安装了支持 GPU 计算的 <code>faiss</code> 库，并且 GPU 资源可用。<br>   </p><pre class="line-numbers language-none"><code class="language-none">##### index定义是Any对象，我不知道它下一步调用的是哪个`````cores, indices = self.index.search(vector, k)` 是 `faiss` 库中 `Index` 类的一个方法，用于在索引中查找与给定向量最相似的 k 个向量。它返回两个数组：`cores` 和 `indices`。其中，`cores` 表示每个查询向量的相似度得分（即余弦相似度），`indices` 表示与每个查询向量最相似的 k 个向量的索引号。请确保您已经正确导入 `faiss` 库，并在代码中创建了 `Index` 对象并将其存储在 `self.index` 变量中。如果您的代码中仍然找不到 `search` 方法，请检查您的代码是否正确导入 `faiss` 库，并创建了正确的 `Index` 对象。`Any` 是 Python 中的一个类型注解，它表示可以是任何类型的对象。因此，当您定义一个类型为 `Any` 的变量时，它可以引用任何类型的对象，包括自定义类型、内置类型、模块、函数等等。在您的代码中，`index` 变量的类型为 `Any`，这意味着它可以引用任何类型的对象。如果您不确定它引用的是哪种类型的对象，可以尝试使用 `type` 函数来查看它的类型，例如：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>print(type(index))<p></p><pre class="line-numbers language-none"><code class="language-none">这将输出 `index` 变量的类型。一旦您知道了 `index` 变量所引用的对象的类型，就可以查找该对象的文档或源代码，以了解它支持哪些方法和属性。如果该对象是 `faiss` 库中的 `Index` 类的实例，那么它应该支持 `search` 方法，用于在索引中查找与给定向量最相似的向量。````##### scores, indices = self.index.search(vector, k)#scores 表示每个查询向量的相似度得分（即余弦相似度），indices 表示与每个查询向量最相似的 k 个向量的索引号。for j,i in enumerate(indices[0]):这个地方为什么用indices[0]，他有什么含义````在 `faiss` 中，`search` 方法可以同时查询多个向量，并返回每个查询向量与数据库中其他向量的相似度得分和索引号。如果查询向量的数量为 `n`，则 `search` 方法返回的 `scores` 和 `indices` 是两个具有 `shape = (n, k)` 的数组，其中 `k` 表示每个查询向量返回的最相似向量的数量。例如，在以下代码中：```pythonscores, indices = self.index.search(queries, k)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 <code>queries</code> 是一个 <code>m</code> 行 <code>d</code> 列的二维数组，表示 <code>m</code> 个查询向量，每个向量有 <code>d</code> 个维度，则 <code>scores</code> 和 <code>indices</code> 的 <code>shape</code> 分别为 <code>(m, k)</code> 和 <code>(m, k)</code>。</p><p>在该算法中，每次只查询一个向量，因此 <code>scores</code> 和 <code>indices</code> 都是一个一维数组，其中 <code>scores[0]</code> 表示查询向量与 k 个最相似向量的相似度得分，<code>indices[0]</code> 表示 k 个最相似向量在索引中的编号。</p><p>因此，在循环中只用到了 <code>indices[0]</code>，表示第一个查询向量的 k 个最相似向量在索引中的编号。至于 <code>indices[1]</code> 表示什么，由于本算法每次只查询一个向量，因此 <code>indices[1]</code> 没有实际意义，可以忽略。</p><p>暂时的理解</p><pre class="line-numbers language-none"><code class="language-none">LLM streaming reponse       STREAMING = True       这个加不加有什么区别```这个代码片段定义了一个名为 `STREAMING` 的变量，它的值为 `True`。这个变量的作用是控制是否启用流式响应（streaming response）。如果将 `STREAMING` 设置为 `False`，则表示禁用流式响应，这意味着服务端在处理完整个请求后才会向客户端发送响应。在这种情况下，客户端需要等待服务端处理完整个请求后才能开始处理响应，这可能会导致客户端等待时间过长，尤其是在处理大型请求或响应时。如果将 `STREAMING` 设置为 `True`，则表示启用流式响应，服务端会在处理请求期间不断向客户端发送响应。这种方式可以有效减少客户端等待的时间，同时也可以逐步返回响应结果，使得客户端可以更早地开始处理响应。但是，启用流式响应也会增加服务端的负担，因为服务端需要在处理请求时不断生成响应数据并发送给客户端。因此，是否启用流式响应取决于具体的应用场景和需求。如果请求和响应较小，可以禁用流式响应以简化实现；如果请求和响应较大，可以考虑启用流式响应以提高性能和用户体验。```##### @lru_cache(CACHED_VS_NUM)什么意思是```python@lru_cache(CACHED_VS_NUM)def load_vector_store(vs_path, embeddings):    return MyFAISS.load_local(vs_path, embeddings)`@lru_cache(CACHED_VS_NUM)` 是 Python 中的一个装饰器语法，它可以用来缓存函数的结果，以避免重复计算，提高程序的执行效率。`@lru_cache` 是 Python 标准库 `functools` 中提供的一个装饰器，它可以用来实现一个“最近最少使用”（Least Recently Used，LRU）的缓存机制。LRU 缓存会在缓存满时删除最近最少使用的缓存项，以保持缓存的最新和最常用状态。`CACHED_VS_NUM` 是一个参数，它用来指定缓存的最大容量，即缓存可以存储的最多的函数调用结果数量。当缓存已满时，新的函数调用会导致最近最少使用的缓存项被删除，以腾出空间给新的缓存项。因此，`@lru_cache(CACHED_VS_NUM)` 的意思就是使用 LRU 缓存机制来缓存函数的结果，并指定缓存的最大容量为 `CACHED_VS_NUM`。``````python如何减少模型的响应速度呢！response = {"query": query,            "result": resp,            "source_documents": related_docs_with_score}#这个是response的响应print(response["source_documents"])metadata={'source': 'pdf/计算机网络.pdf', 'score': 0})]{'query': '2', 'result': '','source_documents': [Document(page_content='AS 100 ', metadata={'source': 'pdf/计算机网络.pdf', 'score': 0})]}```##### if search_type == "similarity":      return self.similarity_search(query, **kwargs)   elif search_type == "mmr":        return self.max_marginal_relevance_search(query, **kwargs)这两个搜索哪个更好一点```这个问题的答案取决于具体的应用场景和需求。`similarity_search` 函数和 `max_marginal_relevance_search` 函数都是用于搜索最相似的向量，但是它们的实现方式略有不同，因此在不同的场景下可能会有不同的表现。`similarity_search` 函数使用余弦相似度来计算向量之间的相似度得分，并返回与查询向量最相似的前 k 个向量。这种方法简单直接，适用于大多数的基本搜索需求。如果您只需要找到与查询向量最相似的向量，那么 `similarity_search` 函数可能更适合您的需求。相比之下，`max_marginal_relevance_search` 函数使用最大边际相关性算法（MMR）来计算向量之间的相似度得分，并尝试最大化返回的向量之间的差异性。这种方法可以帮助您找到与查询向量不仅相似，而且尽可能不同的向量，从而提高搜索结果的多样性。如果您需要返回一组不仅相似而且多样化的向量，那么 `max_marginal_relevance_search` 函数可能更适合您的需求。需要注意的是，使用 `max_marginal_relevance_search` 函数可能会增加计算的复杂度和时间，因为它需要计算向量之间的相似度得分，并进行多次迭代以优化搜索结果。因此，在使用 `max_marginal_relevance_search` 函数时，需要权衡计算的复杂度和搜索结果的质量。```##### 如何查看一个模型有哪些层次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要查看一个模型的层次结构，可以使用PyTorch中的<code>named_parameters()</code>方法。这个方法可以返回一个生成器对象，用于迭代模型的所有参数及其对应的名称。通过遍历这个生成器对象，我们可以逐层查看模型的结构，找到每个层的名称以及相应的参数。</p><p>以下是一个查看模型层次结构的示例代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> transformers <span class="token keyword">import</span> AutoModel<span class="token comment"># 加载一个预训练的模型</span>model <span class="token operator">=</span> AutoModel<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span><span class="token string">'bert-base-cased'</span><span class="token punctuation">)</span><span class="token comment"># 遍历模型的所有参数及其对应的名称</span><span class="token keyword">for</span> name<span class="token punctuation">,</span> param <span class="token keyword">in</span> model<span class="token punctuation">.</span>named_parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 打印参数的名称和形状</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token string"> - </span><span class="token interpolation"><span class="token punctuation">{</span>param<span class="token punctuation">.</span>shape<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们首先使用<code>AutoModel.from_pretrained()</code>方法加载了一个预训练的BERT模型。然后，我们使用<code>named_parameters()</code>方法遍历了这个模型的所有参数及其对应的名称，并打印了每个参数的名称和形状。通过观察这些输出，我们可以了解这个模型的层次结构，并查找每个层的名称以及相应的参数。</p><pre><code>##### 回调函数<pre class="line-numbers language-none"><code class="language-none">def change_chunk_conent(mode, label_conent, history):    conent = ""    if "chunk_conent" in label_conent:        conent = "搜索结果上下文关联"    elif "one_content_segmentation" in label_conent:  # 这里没用上，可以先留着        conent = "内容分段入库"    if mode:        return gr.update(visible=True), history + [[None, f"【已开启{conent}】"]]    else:        return gr.update(visible=False), history + [[None, f"【已关闭{conent}】"]]                chunk_conent.change(fn=change_chunk_conent,                                        inputs=[chunk_conent, gr.Textbox(value="chunk_conent", visible=False), chatbot],                                        outputs=[chunk_sizes, chatbot])                                                                                `change_chunk_conent` 函数是一个回调函数，用于响应 `chunk_content` 复选框的状态变化，并更新相关的组件状态。在 Gradio 库中，回调函数通常使用 `change()` 方法进行注册，以便在用户交互时自动调用。在这里，`chunk_conent.change(fn=change_chunk_conent, inputs=[chunk_conent, gr.Textbox(value="chunk_conent", visible=False), chatbot], outputs=[chunk_sizes, chatbot])` 方法注册了 `change_chunk_conent` 函数，并指定了该函数的输入和输出组件。具体来说，`inputs` 参数包括了 `chunk_conent` 复选框、一个隐藏的文本框（用于记录当前的 `chunk_content` 状态）和一个名为 `chatbot` 的聊天机器人组件，`outputs` 参数包括了一个名为 `chunk_sizes` 的下拉框和同样的 `chatbot` 聊天机器人组件。这些输入和输出组件都是在 `gr.Interface()` 中创建并添加到布局中的。当用户在 Web 界面中勾选或取消 `chunk_content` 复选框时，Gradio 库会自动调用 `change_chunk_conent` 函数，并传递当前 `chunk_content` 复选框的状态、隐藏的文本框的值和聊天机器人的历史记录等参数。`change_chunk_conent` 函数根据输入参数的值进行相应的处理，然后返回一个 `gr.update()` 对象，用于更新 `chunk_sizes` 和 `chatbot` 组件的显示状态和内容。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>##### 代码解释<pre class="line-numbers language-none"><code class="language-none">for file in files:    filename = os.path.split(file.name)[-1]    shutil.move(file.name, os.path.join(KB_ROOT_PATH, vs_id, "content", filename))    filelist.append(os.path.join(KB_ROOT_PATH, vs_id, "content", filename))            这段代码的作用是将一个文件列表中的文件从原来的位置移动到指定的目标目录，并将移动后的文件路径添加到一个文件路径列表中。具体来说，这段代码使用了Python标准库中的`os.path.split()`函数和`shutil.move()`函数。`os.path.split(file.name)`函数将文件路径`file.name`分割成两个部分：目录路径和文件名。`[-1]`索引表示返回分割后的结果中的文件名部分。然后，`shutil.move()`函数将文件从原来的位置移动到指定的目标目录。移动后的文件名不变，因此移动后的文件路径可以通过将目标目录路径和文件名拼接而得到。最后，`filelist.append()`函数将移动后的文件路径添加到一个文件路径列表中。总的来说，这段代码的作用是将一个文件列表中的文件移动到指定的目标目录，并将移动后的文件路径添加到一个文件路径列表中，以备后续使用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">经过多次实验，结合速度，质量的考虑，文本查找量为1，文件扩展长度为150.{'query': '11', 'prompt': '已知信息：通过远射打进唯一进球， 尽管慢动作显示是打在瑞典队后卫腿上弹射入网， 但从过程到结果， 均显示了相同内容——“瑞典队的防守并非无懈可击”。 \u3000\u3000商瑞华让科研教练曹晓东等人对这场比赛进行精心剪辑， 尤其是瑞典队失球以及美国队形成有威胁射门的片段， 更是被放大进行动作分解，\n根据上述已知信息，简洁且专业地回答用户地问题。如果问题不清晰或无法从已知信息中得到答案，请回复"根据已知信息无法回答该问题，请提供足够的本地知识库信息"，切勿在答案中胡编乱造，切勿回答已知信息以外的问题，问题不明确的时，请回答问题不明确，答案请使用中文。问题是：11', 'result': '根据已知信息，可以得出以下结论：\n\n1. 进球是通过远射打进的，尽管慢动作显示是打在瑞典队后卫腿上弹射入网，但过程显示瑞典队的防守并非无懈可击。\n2. 这场比赛的精心剪辑包括对瑞典队失球以及美国队形成有威胁射门的片段进行动作分解。\n3. 商瑞华让科研教练曹晓东等人对这场比赛进行精心剪辑，以确保比赛结果符合预期，尤其是瑞典队的防守并非无懈可击。\n\n因此，可以得出结论：这场比赛的剪辑体现了商瑞华让科研教练曹晓东', 'source_documents': [Document(page_content='通过远射打进唯一进球， 尽管慢动作显示是打在瑞典队后卫腿上弹射入网， 但从过程到结果， 均显示了相同内容——“瑞典队的防守并非无懈可击”。 \u3000\u3000商瑞华让科研教练曹晓东等人对这场比赛进行精心剪辑， 尤其是瑞典队失球以及美国队形成有威胁射门的片段， 更是被放大进行动作分解，', metadata={'source': '1.txt', 'score': 983}, _lc_kwargs={'page_content': '通过远射打进唯一进球，', 'metadata': {'source': '1.txt', 'score': 983}})]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> chatgpt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/07/05/top-down-lun-wen-fen-xi/"/>
      <url>/2023/07/05/top-down-lun-wen-fen-xi/</url>
      
        <content type="html"><![CDATA[<h5 id="MIXUP技术对模型的影响"><a href="#MIXUP技术对模型的影响" class="headerlink" title="MIXUP技术对模型的影响"></a>MIXUP技术对模型的影响</h5><pre class="line-numbers language-none"><code class="language-none">if mixup_active:        mixup_fn = Mixup(            mixup_alpha=args.mixup, cutmix_alpha=args.cutmix, cutmix_minmax=args.cutmix_minmax,            prob=args.mixup_prob, switch_prob=args.mixup_switch_prob, mode=args.mixup_mode,            label_smoothing=args.smoothing, num_classes=args.nb_classes)                        这段代码创建了一个名为"mixup_fn"的Mixup对象，如果"mixup_active"变量为True，则使用Mixup方法对输入数据进行数据增强，这是一种在训练期间增强模型鲁棒性的技术。具体来说，Mixup方法使用随机的线性组合将两个不同的输入样本混合在一起，从而生成一个新的样本。这个过程可以用以下公式表示：new_x = lam * x_i + (1 - lam) * x_jnew_y = lam * y_i + (1 - lam) * y_j其中，x_i和y_i是第一个输入样本的特征和标签，x_j和y_j是第二个输入样本的特征和标签，lam是一个介于[0, 1]之间的随机数，用于控制两个输入样本的混合程度。Mixup方法可以帮助模型学习到更鲁棒的特征表示，并可以降低过拟合的风险。在这段代码中，Mixup对象的参数由一系列命令行参数(args)控制，包括"mixup_alpha"、"cutmix_alpha"、"cutmix_minmax"、"prob"、"switch_prob"、"mode"、"label_smoothing"和"num_classes"。这些参数用于指定Mixup方法的具体实现方式，例如混合比例、剪切比例、标签平滑、混合模式等等。这个Mixup对象可以作为数据增强的一部分，用于对训练数据进行处理，从而提高模型的性能和鲁棒性。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="全连接层的作用是什么，数据维度会变化吗"><a href="#全连接层的作用是什么，数据维度会变化吗" class="headerlink" title="全连接层的作用是什么，数据维度会变化吗"></a>全连接层的作用是什么，数据维度会变化吗</h5><pre class="line-numbers language-none"><code class="language-none">全连接层是神经网络中常用的一种层，也称为线性层或密集连接层（Dense Layer）。其作用是将输入的特征向量进行线性变换，并添加偏置项，从而生成新的特征向量。具体来说，全连接层的输入为一个向量或矩阵，其中向量对应于单个样本的特征向量，矩阵对应于多个样本的特征向量。全连接层的输出也是一个向量或矩阵，其维度由全连接层中的神经元数量决定。在全连接层中，每个神经元与输入向量中的每个元素都有连接，因此可以捕捉输入向量中的所有特征信息，并生成新的特征表示。在神经网络中，全连接层通常用于将低级特征转换为高级特征，增强模型的表达能力和分类性能。例如，在图像分类任务中，全连接层可以将卷积层中提取的空间特征和通道特征进行组合，生成更具有判别力的特征表示，从而提高模型的分类准确率。在全连接层中，数据的维度通常会发生变化。具体来说，如果全连接层的输入是一个大小为(batch_size, input_dim)的矩阵，其中batch_size表示批次大小，input_dim表示输入特征向量的维度，而全连接层包含n个神经元，那么全连接层的输出将是一个大小为(batch_size, n)的矩阵，其中批次大小batch_size不变，而输出维度变为n。因此，全连接层的作用不仅是生成新的特征表示，同时也涉及到数据的维度变换。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线性层代码分析"><a href="#线性层代码分析" class="headerlink" title="线性层代码分析"></a>线性层代码分析</h5><pre class="line-numbers language-none"><code class="language-none">class Decode_Block(nn.Module):    def __init__(self, inplanes):        super().__init__()        self.linear = nn.Linear(inplanes, inplanes, bias=False)        self.linear2 = nn.Linear(inplanes, inplanes, bias=False)    def forward(self, x):        x = self.linear(x)        out = self.linear2(x)        return x, out经过这个层，数据的维度会怎么变化经过Decode_Block模块的前向传播过程，输入张量x的维度不会发生变化。具体来说，输入张量x的维度为(inplanes,)，其中inplanes表示输入特征的维度，也是线性层的输入维度。在模块中，x首先通过self.linear线性层进行变换，其输出维度仍为(inplanes,)，表示对输入特征进行了线性变换。然后，x再次通过self.linear2线性层进行变换，其输出维度仍为(inplanes,)，表示对上一层的输出进行了另一次线性变换。总之，Decode_Block模块的作用是对输入特征进行两次线性变换，输出两个张量x和out，其维度均为(inplanes,)。在具体的Transformer decoder中，Decode_Block模块通常被多次堆叠在一起，以构成完整的解码器层。整个解码器层会接收来自编码器的特征向量作为输入，输出解码后的特征向量，其维度与输入特征向量相同。作用是什么Decode_Block模块是Transformer中decoder部分的基本模块之一，其作用是对编码器输出的特征向量进行解码，即将编码器的输出特征向量转换为目标序列或目标特征向量。具体来说，Decode_Block模块通过两个线性层对输入特征向量进行两次非线性变换，增强了特征向量的表达能力，使其更容易被模型所理解和利用。其中，第一个线性层可以看作是自注意力层，用于计算输入特征向量中不同位置之间的相似度，从而捕捉输入特征向量之间的关系。第二个线性层则可以看作是前馈神经网络，用于进一步映射输入特征向量的表示，从而更好地适应特定任务。在Transformer decoder中，通常会将多个Decode_Block模块堆叠在一起，以构成完整的解码器层。整个解码器层会接收来自编码器的特征向量作为输入，输出解码后的特征向量，其维度与输入特征向量相同，用于进行下游任务，如机器翻译、文本生成等。总之，Decode_Block模块是Transformer decoder的基本模块之一，其作用是对编码器输出的特征向量进行解码，增强特征向量的表达能力，从而更好地适应特定任务。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="TRANSFORMER代码分析"><a href="#TRANSFORMER代码分析" class="headerlink" title="TRANSFORMER代码分析"></a>TRANSFORMER代码分析</h5><pre class="line-numbers language-none"><code class="language-none">def __init__(            self, dim, num_heads, mlp_ratio=4., qkv_bias=False, drop=0., attn_drop=0., init_values=None,            drop_path=0., act_layer=nn.GELU, norm_layer=nn.LayerNorm):        super().__init__()        self.norm1 = norm_layer(dim)        self.attn = Attention(dim, num_heads=num_heads, qkv_bias=qkv_bias, attn_drop=attn_drop, proj_drop=drop)        self.ls1 = LayerScale(dim, init_values=init_values) if init_values else nn.Identity()        # NOTE: drop path for stochastic depth, we shall see if this is better than dropout here        self.drop_path1 = DropPath(drop_path) if drop_path &gt; 0. else nn.Identity()        self.norm2 = norm_layer(dim)        self.mlp = Mlp(in_features=dim, hidden_features=int(dim * mlp_ratio), act_layer=act_layer, drop=drop)        self.ls2 = LayerScale(dim, init_values=init_values) if init_values else nn.Identity()        self.drop_path2 = DropPath(drop_path) if drop_path &gt; 0. else nn.Identity()它都有那些层，作用是什么这段代码中的类定义了一个基本的Transformer模块，其包括了多头注意力机制和前馈神经网络。具体来说，该模块包含以下几个层：- norm1: LayerNorm层，用于对输入特征向量进行归一化处理。- attn: Attention层，用于计算输入特征向量中不同位置之间的相似度，从而捕捉输入特征向量之间的关系。- ls1: LayerScale层，用于对Attention层的输出进行缩放，以避免梯度消失或爆炸。- drop_path1: DropPath层，用于实现随机深度剪枝，以提高模型的泛化能力。- norm2: LayerNorm层，用于对Attention层的输出进行归一化处理。- mlp: Mlp层，用于进一步映射Attention层的输出，从而更好地适应特定任务。- ls2: LayerScale层，用于对Mlp层的输出进行缩放，以避免梯度消失或爆炸。- drop_path2: DropPath层，用于实现随机深度剪枝，以提高模型的泛化能力。总之，这个Transformer模块包含了多个层，其中包括了自注意力层和前馈神经网络层，用于对输入特征向量进行表示学习和特征提取。这些层可以被堆叠在一起，以构成完整的Transformer编码器或解码器，用于处理序列数据、图像数据等任务。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="cos-sim-x3D-F-normalize-x-dim-x3D-1-F-normalize-self-prompt-None-…-None-dim-x3D-1-B-N-1"><a href="#cos-sim-x3D-F-normalize-x-dim-x3D-1-F-normalize-self-prompt-None-…-None-dim-x3D-1-B-N-1" class="headerlink" title="cos_sim = F.normalize(x, dim=-1) @ F.normalize(self.prompt[None, …, None], dim=1)  # B, N, 1"></a>cos_sim = F.normalize(x, dim=-1) @ F.normalize(self.prompt[None, …, None], dim=1)  # B, N, 1</h5><pre class="line-numbers language-none"><code class="language-none">这行代码的作用是计算输入张量 `x` 和模型参数 `self.prompt` 之间的余弦相似度。具体来说，它对输入张量 `x` 进行了 L2 归一化操作，然后将其与模型参数 `self.prompt` 进行 L2 归一化后的转置矩阵相乘，得到一个 B×N×1 的输出张量，其中 B 是输入张量的批次大小，N 是输入张量中每个向量的维度。在这里，`F.normalize(x, dim=-1)` 的作用是对输入张量 `x` 在最后一个维度上进行 L2 归一化，即对每个向量进行 L2 归一化，使得每个向量的 L2 范数为 1。这个操作可以使得输入张量中的向量更容易进行相似度计算，因为 L2 归一化后的向量在欧几里得空间中都位于单位球面上，距离可以转化为余弦相似度，更易于计算和比较。然后，`F.normalize(self.prompt[None, ..., None], dim=1)` 的作用是对模型参数 `self.prompt` 进行 L2 归一化，并将其扩展为一个 B×1×D 的张量，其中 D 是模型参数 `self.prompt` 的维度。这个操作可以使得模型参数 `self.prompt` 可以和每个输入向量进行相似度计算。最后，`@` 运算符表示矩阵乘法，它将 L2 归一化后的输入张量和转置后的 L2 归一化的模型参数进行矩阵乘法运算，得到一个 B×N×1 的张量，其中每个元素表示输入张量中的一个向量与模型参数之间的余弦相似度。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>人间观察</title>
      <link href="/2023/06/30/ren-jian-guan-cha/"/>
      <url>/2023/06/30/ren-jian-guan-cha/</url>
      
        <content type="html"><![CDATA[<h4 id="序"><a href="#序" class="headerlink" title="序"></a>序</h4><p>从前有一个小王子，<br>长得俊美又机灵。<br>他喜欢玩闹，不爱读书，<br>常常惹得皇帝生气。</p><p>皇帝是天上的玉帝，<br>统治着天宫和天地。<br>他看不惯小王子的行为，<br>决定将他贬到凡间。</p><p>小王子来到人间，<br>看到了许多新奇的事物。<br>他欣喜地玩耍，<br>忘记了回天上。</p><p>可是，人间的生活并不容易，<br>小王子开始感到孤独和困惑。<br>他开始思念天宫的美好，<br>希望能够回到天上。</p><p>于是，他开始努力读书学习，<br>认真思考人生的意义。<br>最终，他得到了玉帝的原谅，<br>回到了天宫，成为一名勤奋的仙子。</p><p>贪玩不务正业的人，<br>终究难以得到真正的幸福。<br>只有通过勤奋和努力，<br>才能获得成功和快乐。</p><h5 id="把每一天都当作最后一天，没有”明天”，永远没有"><a href="#把每一天都当作最后一天，没有”明天”，永远没有" class="headerlink" title="把每一天都当作最后一天，没有”明天”，永远没有"></a>把每一天都当作最后一天，没有”明天”，永远没有</h5><h5 id="6月30日，人间观察第7063日"><a href="#6月30日，人间观察第7063日" class="headerlink" title="6月30日，人间观察第7063日"></a>6月30日，人间观察第7063日</h5><pre class="line-numbers language-none"><code class="language-none">小王子凡胎肉体，虽无往日神力，然天资聪慧，风流倜傥，定做人间第一流。武汉大学计算机学院大楼  晴天今天主要做了智能客服的模型和知识数据库的创建阶段，大部分时间在计算机学院大楼度过。今天早上又起晚了，主要原因还是因为昨天晚上玩王者玩到两点。待会晚上晚一点要去跑步，然后开组会，进行下一项目的调研工作。目前科研存在的问题还是代码水平不足，不能依赖实验室里的大佬，自力更生，做大做强。今天晚上要在11点睡觉，睡前不要喝太多水。然后今天晚上继续做智能客服的项目。明天是2023年下半年第一天了，请拿出十足的勇气毅力，不枉此生！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="7月1日，人间观察7064天"><a href="#7月1日，人间观察7064天" class="headerlink" title="7月1日，人间观察7064天"></a>7月1日，人间观察7064天</h5><pre class="line-numbers language-none"><code class="language-none">武汉大学信息学部国软C4  晴天闷热今天依然是在完成智能客服机器人的项目，但是在做项目的时候不够专心，工作不够认真，导致进度有些慢，主要在计算机学院大楼度过。主要是想要完成MOSS模型的创建和知识向量库的添加文件，删除和创建以及模型参数的设置，暂时未实现MOSS模型创建以及模型的参数设置。昨天晚上睡晚了，因为奖励（裂开了）。今天晚上没有跑步，明天一定要去健身房，加3km。今天晚上一定要11点睡觉，然后明天把目前的代码调试到没有bug，实现结合浏览器上网功能，并且开始看那个注意力机制。我想把我的项目做成前后端今天是2023年7月1日建党节，现在不年轻还何时年轻<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="7月2日，人间观察7065天"><a href="#7月2日，人间观察7065天" class="headerlink" title="7月2日，人间观察7065天"></a>7月2日，人间观察7065天</h5><pre class="line-numbers language-none"><code class="language-none">武汉大学文理学部总图书馆A2区 晴天闷热今天实训放假一天，今天主要对智能客服机器人做了调试，但是十分不认真。项目进度缓慢，调试了一些部分，发现查找设置查找数量为1，模型相应速度相对更快，句子填充长度为150，速度相对较快。效果还有待研究，今天晚上去了健身房，自己是真的菜。晚上看了疯狂原始人，活着不容易，优雅自由地活着需要极大的勇气。11点左右，突发想奖励，还好极力克制，11点左右就寝。明天要完成智能客服机器人的交流模式，以及前端对话模型，剩下几天要做调试工作。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="7月3日，人间观察7066天"><a href="#7月3日，人间观察7066天" class="headerlink" title="7月3日，人间观察7066天"></a>7月3日，人间观察7066天</h5><pre class="line-numbers language-none"><code class="language-none">武汉大学计算机学院大楼 晴天很热今天在做智能客服机器人的前端，进展不是很顺利，有些缓慢，总的来说是有些概念性的内容不了解。中午吃的手抓饼和可乐。晚上去踢球了，一个老黑把我嘴撞出血了，但问题不大，还是挺开心的，但是球技明显下降。体力肺活量明显跟不上，晚上是十一点睡觉的，但是喝水过多，睡眠质量不是很好。这两天要休息好，项目最关键的阶段了。踢完球回到寝室刷了2个小时手机。养好精力，体力，好好工作，加油！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="7月4日，人间观察7067天"><a href="#7月4日，人间观察7067天" class="headerlink" title="7月4日，人间观察7067天"></a>7月4日，人间观察7067天</h5><pre class="line-numbers language-none"><code class="language-none">武汉大学国软C4 晴天很热今天在做智能客服机器人的前端部分，目标不是很明确，导致做错。明天要加把劲，还要搞xm给的任务。。今天晚上奖励了自己，很后悔，青春不是在床上扭扭捏捏，而是要在自己擅长的领域发光发热！记住，把每一天都当作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="7月5日，人间观察7068天"><a href="#7月5日，人间观察7068天" class="headerlink" title="7月5日，人间观察7068天"></a>7月5日，人间观察7068天</h5><pre class="line-numbers language-none"><code class="language-none">武汉大学计算机学院大楼 天气很热今天依然在做项目，但是还是工作不认真，不知道为什么，老是喜欢在最后阶段松懈，想一想，假如你两年前的6月8日没有摆烂，中午没有刷手机，理综考试没有发呆，英语考试没有分神，你现在会在哪里？没有如果，人生很难，但请努力。晚上的时候在教室里刷了一段时间手机，然后来了xm的任务😵<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="7月6日，人间观察7069天"><a href="#7月6日，人间观察7069天" class="headerlink" title="7月6日，人间观察7069天"></a>7月6日，人间观察7069天</h5><pre class="line-numbers language-none"><code class="language-none">武汉大学计算机学院大楼 天气很热今天是项目完工最后一天，今天上午完成了top down源码的分析，不是很难，能感受到自己的代码能力在提升。下午的时候跑通了一个柠檬的模型，在服务器上实现了微调，中午刷了木鱼的编辑部的故事。总的来说今天没有摆烂。明天项目验收，今天晚上要最后一次修改代码，完成项目无论如何，今天晚上必去健身房！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="7月7日-7月14，人间虚度"><a href="#7月7日-7月14，人间虚度" class="headerlink" title="7月7日~7月14，人间虚度"></a>7月7日~7月14，人间虚度</h5><h5 id="7月15日，人间观察7070天"><a href="#7月15日，人间观察7070天" class="headerlink" title="7月15日，人间观察7070天"></a>7月15日，人间观察7070天</h5><pre class="line-numbers language-none"><code class="language-none">今天开始做算法题，动一下脑子<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="7月16日，人间观察7071天"><a href="#7月16日，人间观察7071天" class="headerlink" title="7月16日，人间观察7071天"></a>7月16日，人间观察7071天</h5><pre class="line-numbers language-none"><code class="language-none">今天晚上去踢球了，平时浪费时间有点多。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="7月17日，人间观察7072天"><a href="#7月17日，人间观察7072天" class="headerlink" title="7月17日，人间观察7072天"></a>7月17日，人间观察7072天</h5><pre class="line-numbers language-none"><code class="language-none">今天完全是一副不在状态的样子，浪费了很多时间！！<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="7月21，人间观察7076天"><a href="#7月21，人间观察7076天" class="headerlink" title="7月21，人间观察7076天"></a>7月21，人间观察7076天</h5><pre class="line-numbers language-none"><code class="language-none">今天要完成top_down论文的改进，leetcode刷题，继续学习人工智能<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="7月24日，人间观察7079天"><a href="#7月24日，人间观察7079天" class="headerlink" title="7月24日，人间观察7079天"></a>7月24日，人间观察7079天</h5><pre class="line-numbers language-none"><code class="language-none">突然意识到自己已经忘记写很多天的日记了，最近要尽快完成计算机网络课程设计和操作系统课程设计！！！追求得到之日即其终止之时，寻觅的过程亦即失去的过程。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="7月26日，人间观察7081天"><a href="#7月26日，人间观察7081天" class="headerlink" title="7月26日，人间观察7081天"></a>7月26日，人间观察7081天</h5><pre class="line-numbers language-none"><code class="language-none">河南上蔡张龙午村今天打了一天的王者，有点疲惫，看到了别人真的十分优秀，自己的两年有些混了，很伤心。永远不要做对自己有害的事情！！一切都会好的一切都会好起来的！！！定个计划，晚上11点之前睡觉，早上6点起床，坚持一个月！！！7点半开始工作，中午午休半小时！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="7月27日，人间观察7083天"><a href="#7月27日，人间观察7083天" class="headerlink" title="7月27日，人间观察7083天"></a>7月27日，人间观察7083天</h5><pre class="line-numbers language-none"><code class="language-none">河南上蔡张龙午村今天主要是看论文，看了三篇论文，知道扩散模型，大致完成什么工作，但是不知道里面得公式推导的方法，这是需要改进的点。自己确实混，不过加油吧，今天女足赢了海地，虽然她们踢得一般，加油吧！！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="7月31日，人间观察7087天"><a href="#7月31日，人间观察7087天" class="headerlink" title="7月31日，人间观察7087天"></a>7月31日，人间观察7087天</h5><pre class="line-numbers language-none"><code class="language-none">河南上蔡张龙午村今天的任务比较重，要完成python神经网络编程的阅读，要完成论文的分析，还要写实验报告，若时间还有，要写操作系统课设all is well<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="8月1日，人间观察7088天"><a href="#8月1日，人间观察7088天" class="headerlink" title="8月1日，人间观察7088天"></a>8月1日，人间观察7088天</h5><pre class="line-numbers language-none"><code class="language-none">是你锻炼了，身体才会开始健壮。是你阅读了，大脑才会开始充实。是你朴素了，财富才会慢慢积累。是你思考了，机会才会逐渐显现。是你上路了，道路才会一直延申。是你解除恶习了，正缘才会开始。一切的改变，必定是从你开始。别指望所谓的贵人、机会、命运来拯救你，只有你变了，才会遇见贵人，机会、命运才会降临。一切，都是因你而变<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="8月9日，人间观察7096天"><a href="#8月9日，人间观察7096天" class="headerlink" title="8月9日，人间观察7096天"></a>8月9日，人间观察7096天</h5><p>周三：0分，两飞</p><pre class="line-numbers language-none"><code class="language-none">do something fun完成了OS课程设计，接下来要修改论文代码，平时没事的时候多积累一些知识<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="8月10日，人间观察7097天"><a href="#8月10日，人间观察7097天" class="headerlink" title="8月10日，人间观察7097天"></a>8月10日，人间观察7097天</h5><p>周四：0分，一天王者</p><h5 id="8月11日，人间观察7098天"><a href="#8月11日，人间观察7098天" class="headerlink" title="8月11日，人间观察7098天"></a>8月11日，人间观察7098天</h5><p>周五：15分</p><pre class="line-numbers language-none"><code class="language-none">早上跑了一会步，复现了k近邻算法，不是很用心。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="8月12日，人间观察7099天"><a href="#8月12日，人间观察7099天" class="headerlink" title="8月12日，人间观察7099天"></a>8月12日，人间观察7099天</h5><p>周六：30分</p><pre class="line-numbers language-none"><code class="language-none">用心的时候，能做的事做的真的很快<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="8月13日，人间观察7100天"><a href="#8月13日，人间观察7100天" class="headerlink" title="8月13日，人间观察7100天"></a>8月13日，人间观察7100天</h5><p>周日：50分</p><pre class="line-numbers language-none"><code class="language-none">上午效率较差，低于下午的效率<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="8月14日，人间观察7101天"><a href="#8月14日，人间观察7101天" class="headerlink" title="8月14日，人间观察7101天"></a>8月14日，人间观察7101天</h5><p>周一：</p><pre class="line-numbers language-none"><code class="language-none">上午的时候，一直在玩，不在状态，下午好一点<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="8月19日，人间观察7106天"><a href="#8月19日，人间观察7106天" class="headerlink" title="8月19日，人间观察7106天"></a>8月19日，人间观察7106天</h5><p>周六：知道自己做的不对，却不想改变，再这样下去是不是要完蛋</p><pre class="line-numbers language-none"><code class="language-none">最相信我的人竟然不是我自己<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="8月25日，人间观察7112天"><a href="#8月25日，人间观察7112天" class="headerlink" title="8月25日，人间观察7112天"></a>8月25日，人间观察7112天</h5><p>周五：在武大信部图书馆，评分80，再接再厉</p><pre class="line-numbers language-none"><code class="language-none">xiaolingcoding.com programmercarl.com 这两个网站对于软件类算法题以及面试八股整理的比较好 有需要的可以参考参考算法加机器学习基础目前有几个主线任务：1.算法，代码随想录作为过关，jack_cui的leetcode作为复习，预计30天左右2.百度飞桨实践，这个真的不能敷衍预计需要60天3.jack_cui的网站博客全刷，他真的有好多好玩的预计60天4.实验室任务，那个真的很简单，不要害怕，一定会有科研产出的。2天<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="8月26日，人间观察7113天"><a href="#8月26日，人间观察7113天" class="headerlink" title="8月26日，人间观察7113天"></a>8月26日，人间观察7113天</h5><p>周六：主要在五大信部图书馆，评分60，斗了一会电子蛐蛐，然后不是很专心。</p><pre class="line-numbers language-none"><code class="language-none">刷了一些代码随想录，看了一会实验室的任务，主要问题是不专心，跑步跑了两圈，体能下降明显。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="8月27日，人间观察7114天"><a href="#8月27日，人间观察7114天" class="headerlink" title="8月27日，人间观察7114天"></a>8月27日，人间观察7114天</h5><p>周日：评分70，看手机看的少</p><pre class="line-numbers language-none"><code class="language-none">今天我需要把滤波器攻击的论文分析一下代码随想录的题目，复习一下，并且把链表刷一遍，滤波器代码没有分析完毕，代码随想录今天还行，百度飞桨不是很仔细，状态有点迷糊<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>去跑一会步</p><h5 id="8月28日，人间观察7115天"><a href="#8月28日，人间观察7115天" class="headerlink" title="8月28日，人间观察7115天"></a>8月28日，人间观察7115天</h5><p>周一：评分0，飞鲲梅开二度，身体被掏空</p><pre class="line-numbers language-none"><code class="language-none">完成了泰隆的考试题，觉得前面的一些基础知识，还是很重要的<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="8月29日，人间观察7116天"><a href="#8月29日，人间观察7116天" class="headerlink" title="8月29日，人间观察7116天"></a>8月29日，人间观察7116天</h5><p>周二：评分40，上午还行，一回到寝室，就什么也学不进去了</p><pre class="line-numbers language-none"><code class="language-none">加油，今天要完成代码随想录复习以及学习未完成今日目标人都是要死的，所以你还在等什么呢<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="8月30日，人间观察7117天"><a href="#8月30日，人间观察7117天" class="headerlink" title="8月30日，人间观察7117天"></a>8月30日，人间观察7117天</h5><p>周三：60</p><pre class="line-numbers language-none"><code class="language-none">今天来到图书馆，不要回去了呀上午不仔细地看了一篇论文，改了一个代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="9月1日，人间观察7118天"><a href="#9月1日，人间观察7118天" class="headerlink" title="9月1日，人间观察7118天"></a>9月1日，人间观察7118天</h5><p>周五：70</p><pre class="line-numbers language-none"><code class="language-none">完成了滤波器一些问题，还有一些问题需要解决代码随想录网站(远远不达标)jack的网站没时间看了已经，还有百度飞桨无论如何，请全力以赴<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="9月2日，人间观察7119天"><a href="#9月2日，人间观察7119天" class="headerlink" title="9月2日，人间观察7119天"></a>9月2日，人间观察7119天</h5><p>周六：60分，两飞</p><pre class="line-numbers language-none"><code class="language-none">解决滤波器问题(完全解决)，你要深入思考呀百度飞桨，jack cui不知道怎么说，反正觉得自己很差劲代码随想录刷了一点，但不够<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="9月3日，人间观察7120天"><a href="#9月3日，人间观察7120天" class="headerlink" title="9月3日，人间观察7120天"></a>9月3日，人间观察7120天</h5><p>周日：30分</p><pre class="line-numbers language-none"><code class="language-none">今天上午是怎么了，不能因为昨天晚上的事情就萎靡不振吧。解决了滤波器的代码问题，应该就可以完成了晚上要看看代码炒股明天要进行觉悟的培训<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="9月4日，人间观察7121天"><a href="#9月4日，人间观察7121天" class="headerlink" title="9月4日，人间观察7121天"></a>9月4日，人间观察7121天</h5><p>周一：10分</p><pre class="line-numbers language-none"><code class="language-none">今天上午玩了一上午的王者，下午的时候去看了腾讯ai，但不多，也觉得没有什么作用今天晚上的来到信部图书馆，待会要跑一会步，加油吧，今天能出来已经很不错了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="9月5日，人间观察7122天"><a href="#9月5日，人间观察7122天" class="headerlink" title="9月5日，人间观察7122天"></a>9月5日，人间观察7122天</h5><p>周二：60分</p><pre class="line-numbers language-none"><code class="language-none">今天上午在图书馆无所事事，想着吃饭(但是今天上午能出来)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一晌贪欢</title>
      <link href="/2023/06/23/yi-shang-tan-huan/"/>
      <url>/2023/06/23/yi-shang-tan-huan/</url>
      
        <content type="html"><![CDATA[<h5 id="阴阳怪气："><a href="#阴阳怪气：" class="headerlink" title="阴阳怪气："></a>阴阳怪气：</h5><ol><li>人生本就五颜六色，你却卡在了黄色和绿色。</li><li>癞蛤蟆沾点海水，真当自己是海鲜了。</li><li>多照照镜子，你就明白其中的原因了。</li><li>上帝往人间洒满智慧，唯独你打开了伞。</li><li>你一来，这一锅粥都不能要了。</li><li>其实做人挺有趣的，你不妨试一试。</li><li>小东西，长的挺随机的。</li></ol><h5 id="执子之手，与子偕老："><a href="#执子之手，与子偕老：" class="headerlink" title="执子之手，与子偕老："></a>执子之手，与子偕老：</h5><h5 id="顶级享受："><a href="#顶级享受：" class="headerlink" title="顶级享受："></a>顶级享受：</h5><ol><li>高二那年，自己用微积分推导出了流体力学方程，后来查到已经被称作伯努利流体方程。那一瞬间与先贤齐肩的感觉，一直记到现在。</li><li>博士论文通过的那一瞬间，你要知道，你亲手推动了人类的前进，在这个方向上，你是人类历史上到达这里的第一人。</li></ol><h5 id="鸡汤来喽"><a href="#鸡汤来喽" class="headerlink" title="鸡汤来喽:"></a>鸡汤来喽:</h5><ol><li><p>看似不起波澜的日复一日，一定会在某一天让你看到坚持的意义，穷则独善其身，达则兼济天下，没有谁的一生是一帆风顺的，起起伏伏跌跌撞撞才是常有的状态，再贵的东西除以365都会变得很便宜。写作文的时候要分开头、中间、结尾，人生也是，从出生入学、三十而立到老了入土为安，每一个人都想努力活成自己想要的样子，你能作茧自缚就能破茧成蝶，人生就是一场自我完善的修行，这一切的苦难和折磨都是对自己的磨练，曾经所有的哭泣和悲欢喜乐，都是塑造一个更加完美的自己。有句话是这样说的：太阳升起时事业和工作就要投身，太阳落下时就是自我完善复盘的时候。你要相信，所有的事与愿违和苦难都是未来惊喜的铺垫，无论你现在混成什么模样，都要相信自己前途无量，然后努力拼搏，千万别让温水煮了你的将军梦，人生就一次，别认输！</p></li><li><p>人在年轻的时候可以逃避很多东西，但在承担责任的那一刻，你就没有资格年轻了，工作你得有，家庭你得顾，孩子你得护，形象你得树。十年前，连多愁善感都要渲染的惊天动地，十年后，越痛越不动声色，越苦越保持沉默。与买桂花同载酒，终不似，少年游，时间磨去了年少轻狂，也渐渐沉淀了冷暖自知。去做和你年龄相匹配的事，这叫责任，也是一个人活着的价值。风景依旧在，人已非少年。</p></li><li><p>这些年你可能经历了人生的至暗时刻，也许满是心酸，也许疲惫不堪，也许很多遗憾。但请你找到一个目标，务必坚持下去，千百次的站起来。那些带着晨间的寂静，不眠的星光，孤军奋战的清醒。你若决定灿烂，那么山无遮，海无栏，光总会撒在你的身上。尽管眼下十分艰难，但日后这段经历，说不定会开花结果，我们终其一生，并不是为了满足所有人。只要你喜欢，每一秒都是豆蔻年华，我们不用活在他人的言语之下，外界的声音只是参考。山有顶峰，湖有彼岸。在人生漫漫长路中，万物皆有回转，当我们任务余味苦涩，请你相信一切皆有回甘。向未来张望的时光，也许孤独而漫长，努力过后回事晴朗，尽管走，走到灯火通明，走到春暖花开，走到苦尽甘来，我们终将成为更好地自己。在苦难的时候别忘记了，给自己点燃一盏名叫希望的灯，用尽全力，过完这平凡但不平庸的一生。</p></li><li><p>爱自己的方式有很多，给自己一点时间吧，好好的缓一缓，然后就好好爱自己，把期望降低，把依赖变少，我相信你一定会过的很好。你要活着自己的世界里，这短暂的一生要为自己而活，去经历去后悔去改变，不要被别人左右，勇敢的去尝试一切。想表白就表白，想发照片就发照片，想穿什么就穿什么，想做什么就做什么，干嘛非得活在别人的嘴里呢。活在自己的世界里，不也挺好的吗，总有一天，你会发现，能让你重新振作起来的人，只有你自己。所以千万不要再自卑和焦虑中，度过这一生，你要坦然地接受不完美的自己，勇敢的面对这个社会，说句实话，没有人会在意你，就像你没那么在意别人一样。你只需要大大方方地做自己就好了，毕竟我们都是人，终点都是面临死亡，所以在只有一次的人生里，我希望你无论几岁，都可以顺着自己的心意而活。</p></li></ol><h5 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h5><ol><li>你委屈了可以摔门而出，妈妈委屈了只能做着家务，偷偷掉眼泪。 ——三毛</li><li>不要踩着父母的肩膀看过世间的繁华之后，嫌弃它们从未读书识字。 ——余华</li><li>你讨厌父亲的平庸，殊不知，他也曾是怀揣梦想的少年。</li><li>人生的三种境界：接受父母的平凡，接受自己的平凡，接受子女的平凡。 ——梁晓声</li><li>一个好的家庭不是多么殷实富有，而是一代一代的向上托举，让下一代更上一层楼，代代相承。</li><li>当有一天，生你养你的两个人都走了，这世间再也没有人真心地疼你了，也没有人在意你过的好不好。父母在，人生上有来往，父母去，人生只剩归途。  ——丰子恺</li><li>此生最大地遗憾，在父母本该享福地年纪，我们依旧是个不成器的样子，依旧是他们的负担和最放不下的牵挂。</li></ol><h5 id="歇后语"><a href="#歇后语" class="headerlink" title="歇后语"></a>歇后语</h5><p>1.骑自行车去酒吧——该省省该花花</p><p>2.厕所里打地铺——离死不远了</p><p>3.小刀割屁股——开了眼了</p><p>4.皮裤套棉裤，必定有缘故</p><p>5.驴——光屁股拉磨，转着圈丢人</p><p>6.被窝里放屁——能文能武</p><h5 id="诗词："><a href="#诗词：" class="headerlink" title="诗词："></a>诗词：</h5><p>1.失之东隅，收之桑榆。</p><p>2.朝乾夕惕，功不唐捐。</p><p>3.浮生若梦，为欢几何</p><p>4.东隅已逝，桑榆非晚</p><ol start="5"><li></li></ol><pre class="line-numbers language-none"><code class="language-none">使我们视而不见的光亮对于我们就是黑暗当我们清醒时，曙光才会破晓来日方长，太阳只是颗启明星《瓦尔登湖》梭罗<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6.我见青山多妩媚，料青山见我应如是。 辛弃疾《贺新郎  甚矣吾衰矣》</p><p>7.众里寻他千百度，慕然回首，那人却在，灯火阑珊处。辛弃疾《青玉案  元夕》</p><p>8.竹杖芒鞋轻胜马，谁怕，一蓑烟雨任平生。      苏轼《定风波》</p><p>9.欲买桂花同载酒，终不似，少年游。刘过《唐多令  芦叶满汀洲》</p><p>10.当时年少春衫薄。骑马倚斜桥，满楼红袖招。韦庄《菩萨蛮  如今却忆江南乐》</p><p>11.毕竟几人真得鹿，不知终日梦为鱼。黄庭坚</p><p>12.人生如逆旅，我亦是行人。苏轼《临江仙  送钱穆父》</p><p>13.一朝春尽红颜老，花落人亡两不知。《葬花词》</p><p>14.云想衣裳花想容，春风拂槛露华浓。李白《清平调》</p><p>15.寄蜉蝣于天地，渺沧海之一粟。苏轼《赤壁赋》</p><p>16.须知少年青云志，曾许人间第一流。吴庆坻《题三十计小象》</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
